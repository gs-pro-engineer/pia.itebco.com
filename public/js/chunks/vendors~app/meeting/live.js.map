{"version":3,"file":"js/chunks/vendors~app/meeting/live.js?id=b373f3b89d51997ebbd3","sources":["webpack:///./node_modules/bent/src/browser.js","webpack:///./node_modules/bent/src/core.js","webpack:///./node_modules/cookie/index.js","webpack:///./node_modules/core-util-is/lib/util.js","webpack:///./node_modules/events/events.js","webpack:///./node_modules/inherits/inherits_browser.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/microsoft.cognitiveservices.speech.sdk.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/CertChecks.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/ConsoleLoggingListener.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/Exports.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/FileAudioSource.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/IRecorder.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/MicAudioSource.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/PCMRecorder.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/ProxyInfo.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/ReplayableAudioNode.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/RestConfigBase.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/RestMessageAdapter.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/WebsocketConnection.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.browser/WebsocketMessageAdapter.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/AddedLmIntent.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/AgentConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/CognitiveSubscriptionKeyAuthentication.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/CognitiveTokenAuthentication.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ConnectionFactoryBase.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/DialogConnectorFactory.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/DialogServiceAdapter.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/DialogServiceTurnState.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/DialogServiceTurnStateManager.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/DynamicGrammarBuilder.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/DynamicGrammarInterfaces.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/EnumTranslation.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Exports.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/HeaderNames.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/IAuthentication.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/IConnectionFactory.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ISynthesisConnectionFactory.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/IntentConnectionFactory.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/IntentServiceRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/QueryParameterNames.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/RecognitionEvents.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/RecognizerConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/RequestSession.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/ActivityResponsePayload.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/DetailedSpeechPhrase.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/Enums.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/IntentResponse.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/SimpleSpeechPhrase.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/SpeechDetected.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/SpeechHypothesis.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/SpeechKeyword.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/SynthesisAudioMetadata.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/TranslationHypothesis.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/TranslationPhrase.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/TranslationSynthesisEnd.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceMessages/TurnStatusPayload.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceRecognizerBase.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/ServiceTelemetryListener.Internal.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SpeakerIdMessageAdapter.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SpeakerRecognitionConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SpeechConnectionFactory.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SpeechConnectionMessage.Internal.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SpeechContext.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SpeechServiceInterfaces.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SpeechServiceRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SpeechSynthesisConnectionFactory.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SynthesisAdapterBase.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SynthesisContext.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SynthesisEvents.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SynthesisTurn.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/SynthesizerConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/TranscriberConnectionFactory.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationConnectionConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationConnectionFactory.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationConnectionMessage.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationManager.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationRequestSession.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationServiceAdapter.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationTranslatorEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationTranslatorInterfaces.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationTranslatorRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ConversationWebsocketMessageFormatter.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/Exports.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ServiceMessages/CommandResponsePayload.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ServiceMessages/Exports.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ServiceMessages/ParticipantResponsePayload.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/ServiceMessages/TranslationResponsePayload.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/TranscriberRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/TranscriptionServiceRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/TranslationConnectionFactory.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/TranslationServiceRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/TranslationStatus.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/WebsocketMessageFormatter.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/AudioSourceEvents.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/BackgroundError.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/ChunkedArrayBufferStream.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/ConnectionEvents.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/ConnectionMessage.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/ConnectionOpenResponse.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/DialogEvents.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/Error.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/EventSource.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/Events.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/Exports.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/Guid.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/IAudioDestination.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/IAudioSource.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/IConnection.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/IDetachable.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/IDictionary.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/IDisposable.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/IErrorMessages.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/IEventSource.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/ITimer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/IWebsocketMessageFormatter.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/List.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/OCSPEvents.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/PlatformEvent.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/Promise.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/Queue.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/RawWebsocketMessage.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/RiffPcmEncoder.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/Stream.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common/Timeout.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/ActivityReceivedEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/AudioConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/AudioFileWriter.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/AudioInputStream.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/AudioOutputFormat.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/AudioOutputStream.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/AudioStreamFormat.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/BaseAudioPlayer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/PullAudioInputStreamCallback.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/PushAudioOutputStreamCallback.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Audio/SpeakerAudioDestination.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/AutoDetectSourceLanguageConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/AutoDetectSourceLanguageResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/BotFrameworkConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/CancellationDetails.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/CancellationDetailsBase.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/CancellationErrorCodes.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/CancellationEventArgsBase.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/CancellationReason.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Connection.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/ConnectionEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/ConnectionMessage.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/ConnectionMessageEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Contracts.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/ConversationTranscriptionCanceledEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/CustomCommandsConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/DialogServiceConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/DialogServiceConnector.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Exports.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/IntentRecognitionCanceledEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/IntentRecognitionEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/IntentRecognitionResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/IntentRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/KeywordRecognitionModel.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/LanguageUnderstandingModel.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/NoMatchDetails.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/NoMatchReason.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/OutputFormat.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/PhraseListGrammar.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/ProfanityOption.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/PronunciationAssessmentConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/PronunciationAssessmentGradingSystem.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/PronunciationAssessmentGranularity.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/PronunciationAssessmentResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/PropertyCollection.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/PropertyId.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/RecognitionEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/RecognitionResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Recognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/ResultReason.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/ServiceEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/ServicePropertyChannel.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SessionEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SourceLanguageConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeakerIdentificationModel.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeakerRecognitionResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeakerRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeakerVerificationModel.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechRecognitionCanceledEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechRecognitionEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechRecognitionResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechSynthesisBookmarkEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechSynthesisEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechSynthesisOutputFormat.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechSynthesisResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechSynthesisVisemeEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechSynthesisWordBoundaryEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechSynthesizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/SpeechTranslationConfig.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/Conversation.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/ConversationCommon.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/ConversationExpirationEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/ConversationParticipantsChangedEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/ConversationTranscriber.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/ConversationTranslationCanceledEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/ConversationTranslationEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/ConversationTranslationResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/ConversationTranslator.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/Exports.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/IParticipant.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Transcription/ParticipantChangedReason.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/TranslationRecognitionCanceledEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/TranslationRecognitionEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/TranslationRecognitionResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/TranslationRecognizer.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/TranslationSynthesisEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/TranslationSynthesisResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/Translations.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/TurnStatusReceivedEventArgs.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/VoiceProfile.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/VoiceProfileClient.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/VoiceProfileEnrollmentResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/VoiceProfilePhraseResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/VoiceProfileResult.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/sdk/VoiceProfileType.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/node_modules/uuid/index.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/node_modules/uuid/v1.js","webpack:///./node_modules/microsoft-cognitiveservices-speech-sdk/node_modules/uuid/v4.js","webpack:///./node_modules/process-nextick-args/index.js","webpack:///./node_modules/querystringify/index.js","webpack:///./node_modules/readable-stream/duplex-browser.js","webpack:///./node_modules/readable-stream/lib/_stream_duplex.js","webpack:///./node_modules/readable-stream/lib/_stream_passthrough.js","webpack:///./node_modules/readable-stream/lib/_stream_readable.js","webpack:///./node_modules/readable-stream/lib/_stream_transform.js","webpack:///./node_modules/readable-stream/lib/_stream_writable.js","webpack:///./node_modules/readable-stream/lib/internal/streams/BufferList.js","webpack:///./node_modules/readable-stream/lib/internal/streams/destroy.js","webpack:///./node_modules/readable-stream/lib/internal/streams/stream-browser.js","webpack:///./node_modules/readable-stream/node_modules/isarray/index.js","webpack:///./node_modules/readable-stream/node_modules/safe-buffer/index.js","webpack:///./node_modules/readable-stream/passthrough.js","webpack:///./node_modules/readable-stream/readable-browser.js","webpack:///./node_modules/readable-stream/transform.js","webpack:///./node_modules/readable-stream/writable-browser.js","webpack:///./node_modules/requires-port/index.js","webpack:///./node_modules/socket.io-stream/index.js","webpack:///./node_modules/socket.io-stream/lib/blob-read-stream.js","webpack:///./node_modules/socket.io-stream/lib/index.js","webpack:///./node_modules/socket.io-stream/lib/iostream.js","webpack:///./node_modules/socket.io-stream/lib/parser.js","webpack:///./node_modules/socket.io-stream/lib/socket.js","webpack:///./node_modules/socket.io-stream/lib/uuid.js","webpack:///./node_modules/socket.io-stream/node_modules/debug/browser.js","webpack:///./node_modules/socket.io-stream/node_modules/debug/debug.js","webpack:///./node_modules/socket.io-stream/node_modules/ms/index.js","webpack:///./node_modules/stream-browserify/index.js","webpack:///./node_modules/string_decoder/lib/string_decoder.js","webpack:///./node_modules/string_decoder/node_modules/safe-buffer/index.js","webpack:///./node_modules/universal-cookie/es6/Cookies.js","webpack:///./node_modules/universal-cookie/es6/index.js","webpack:///./node_modules/universal-cookie/es6/utils.js","webpack:///./node_modules/url-parse/index.js","webpack:///./node_modules/util-deprecate/browser.js","webpack:///./node_modules/util/node_modules/inherits/inherits_browser.js","webpack:///./node_modules/util/support/isBufferBrowser.js","webpack:///./node_modules/util/util.js"],"sourcesContent":["'use strict'\n/* global fetch, btoa, Headers */\nconst core = require('./core')\n\nclass StatusError extends Error {\n  constructor (res, ...params) {\n    super(...params)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, StatusError)\n    }\n\n    this.name = 'StatusError'\n    this.message = res.statusMessage\n    this.statusCode = res.status\n    this.res = res\n    this.json = res.json.bind(res)\n    this.text = res.text.bind(res)\n    this.arrayBuffer = res.arrayBuffer.bind(res)\n    let buffer\n    const get = () => {\n      if (!buffer) buffer = this.arrayBuffer()\n      return buffer\n    }\n    Object.defineProperty(this, 'responseBody', { get })\n    // match Node.js headers object\n    this.headers = {}\n    for (const [key, value] of res.headers.entries()) {\n      this.headers[key.toLowerCase()] = value\n    }\n  }\n}\n\nconst mkrequest = (statusCodes, method, encoding, headers, baseurl) => async (_url, body, _headers = {}) => {\n  _url = baseurl + (_url || '')\n  let parsed = new URL(_url)\n\n  if (!headers) headers = {}\n  if (parsed.username) {\n    headers.Authorization = 'Basic ' + btoa(parsed.username + ':' + parsed.password)\n    parsed = new URL(parsed.protocol + '//' + parsed.host + parsed.pathname + parsed.search)\n  }\n  if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') {\n    throw new Error(`Unknown protocol, ${parsed.protocol}`)\n  }\n\n  if (body) {\n    if (body instanceof ArrayBuffer ||\n      ArrayBuffer.isView(body) ||\n      typeof body === 'string'\n    ) {\n      // noop\n    } else if (typeof body === 'object') {\n      body = JSON.stringify(body)\n      headers['Content-Type'] = 'application/json'\n    } else {\n      throw new Error('Unknown body type.')\n    }\n  }\n\n  _headers = new Headers({ ...(headers || {}), ..._headers })\n\n  const resp = await fetch(parsed, { method, headers: _headers, body })\n  resp.statusCode = resp.status\n\n  if (!statusCodes.has(resp.status)) {\n    throw new StatusError(resp)\n  }\n\n  if (encoding === 'json') return resp.json()\n  else if (encoding === 'buffer') return resp.arrayBuffer()\n  else if (encoding === 'string') return resp.text()\n  else return resp\n}\n\nmodule.exports = core(mkrequest)\n","'use strict'\nconst encodings = new Set(['json', 'buffer', 'string'])\n\nmodule.exports = mkrequest => (...args) => {\n  const statusCodes = new Set()\n  let method\n  let encoding\n  let headers\n  let baseurl = ''\n\n  args.forEach(arg => {\n    if (typeof arg === 'string') {\n      if (arg.toUpperCase() === arg) {\n        if (method) {\n          const msg = `Can't set method to ${arg}, already set to ${method}.`\n          throw new Error(msg)\n        } else {\n          method = arg\n        }\n      } else if (arg.startsWith('http:') || arg.startsWith('https:')) {\n        baseurl = arg\n      } else {\n        if (encodings.has(arg)) {\n          encoding = arg\n        } else {\n          throw new Error(`Unknown encoding, ${arg}`)\n        }\n      }\n    } else if (typeof arg === 'number') {\n      statusCodes.add(arg)\n    } else if (typeof arg === 'object') {\n      if (Array.isArray(arg) || arg instanceof Set) {\n        arg.forEach(code => statusCodes.add(code))\n      } else {\n        if (headers) {\n          throw new Error('Cannot set headers twice.')\n        }\n        headers = arg\n      }\n    } else {\n      throw new Error(`Unknown type: ${typeof arg}`)\n    }\n  })\n\n  if (!method) method = 'GET'\n  if (statusCodes.size === 0) {\n    statusCodes.add(200)\n  }\n\n  return mkrequest(statusCodes, method, encoding, headers, baseurl)\n}\n","/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\nvar pairSplitRegExp = /; */;\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var pairs = str.split(pairSplitRegExp);\n  var dec = opt.decode || decode;\n\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var eq_idx = pair.indexOf('=');\n\n    // skip things that don't look like key=value\n    if (eq_idx < 0) {\n      continue;\n    }\n\n    var key = pair.substr(0, eq_idx).trim()\n    var val = pair.substr(++eq_idx, pair.length).trim();\n\n    // quoted values\n    if ('\"' == val[0]) {\n      val = val.slice(1, -1);\n    }\n\n    // only assign once\n    if (undefined == obj[key]) {\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('buffer').Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ConsoleLoggingListener } from \"./src/common.browser/Exports\";\nimport { Events } from \"./src/common/Exports\";\n// Common.Storage.SetLocalStorage(new Common.Browser.LocalStorage());\n// Common.Storage.SetSessionStorage(new Common.Browser.SessionStorage());\nEvents.instance.attachListener(new ConsoleLoggingListener());\n// Speech SDK API\nexport * from \"./src/sdk/Exports\";\n\n//# sourceMappingURL=microsoft.cognitiveservices.speech.sdk.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as tls from \"tls\";\nimport * as parse from \"url-parse\";\nimport * as ocsp from \"../../external/ocsp/ocsp\";\nimport { Events, OCSPCacheEntryExpiredEvent, OCSPCacheEntryNeedsRefreshEvent, OCSPCacheFetchErrorEvent, OCSPCacheHitEvent, OCSPCacheMissEvent, OCSPCacheUpdatehCompleteEvent, OCSPCacheUpdateNeededEvent, OCSPDiskCacheHitEvent, OCSPDiskCacheStoreEvent, OCSPMemoryCacheHitEvent, OCSPMemoryCacheStoreEvent, OCSPResponseRetrievedEvent, OCSPStapleReceivedEvent, OCSPVerificationFailedEvent, } from \"../common/Exports\";\nimport Agent from \"agent-base\";\n// @ts-ignore\nimport Cache from \"async-disk-cache\";\nimport HttpsProxyAgent from \"https-proxy-agent\";\nimport * as net from \"net\";\nimport { OCSPCacheUpdateErrorEvent } from \"../common/OCSPEvents\";\nexport class CertCheckAgent {\n    constructor(proxyInfo) {\n        if (!!proxyInfo) {\n            this.privProxyInfo = proxyInfo;\n        }\n        // Initialize this here to allow tests to set the env variable before the cache is constructed.\n        if (!CertCheckAgent.privDiskCache) {\n            CertCheckAgent.privDiskCache = new Cache(\"microsoft-cognitiveservices-speech-sdk-cache\", { supportBuffer: true, location: (typeof process !== \"undefined\" && !!process.env.SPEECH_OCSP_CACHE_ROOT) ? process.env.SPEECH_OCSP_CACHE_ROOT : undefined });\n        }\n    }\n    // Test hook to force the disk cache to be recreated.\n    static forceReinitDiskCache() {\n        CertCheckAgent.privDiskCache = undefined;\n        CertCheckAgent.privMemCache = {};\n    }\n    GetAgent(disableStapling) {\n        const agent = new Agent.Agent(this.CreateConnection);\n        if (this.privProxyInfo !== undefined &&\n            this.privProxyInfo.HostName !== undefined &&\n            this.privProxyInfo.Port > 0) {\n            const proxyName = \"privProxyInfo\";\n            agent[proxyName] = this.privProxyInfo;\n        }\n        return agent;\n    }\n    static GetProxyAgent(proxyInfo) {\n        const httpProxyOptions = {\n            host: proxyInfo.HostName,\n            port: proxyInfo.Port,\n        };\n        if (!!proxyInfo.UserName) {\n            httpProxyOptions.headers = {\n                \"Proxy-Authentication\": \"Basic \" + new Buffer(proxyInfo.UserName + \":\" + (proxyInfo.Password === undefined) ? \"\" : proxyInfo.Password).toString(\"base64\"),\n            };\n        }\n        else {\n            httpProxyOptions.headers = {};\n        }\n        httpProxyOptions.headers.requestOCSP = \"true\";\n        const httpProxyAgent = new HttpsProxyAgent(httpProxyOptions);\n        return httpProxyAgent;\n    }\n    static OCSPCheck(socketPromise, proxyInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let ocspRequest;\n            let stapling;\n            let resolved = false;\n            const socket = yield socketPromise;\n            socket.cork();\n            const tlsSocket = socket;\n            return new Promise((resolve, reject) => {\n                socket.on(\"OCSPResponse\", (data) => {\n                    if (!!data) {\n                        this.onEvent(new OCSPStapleReceivedEvent());\n                        stapling = data;\n                    }\n                });\n                socket.on(\"error\", (error) => {\n                    if (!resolved) {\n                        resolved = true;\n                        socket.destroy();\n                        reject(error);\n                    }\n                });\n                tlsSocket.on(\"secure\", () => __awaiter(this, void 0, void 0, function* () {\n                    const peer = tlsSocket.getPeerCertificate(true);\n                    try {\n                        const issuer = yield this.GetIssuer(peer);\n                        // We always need a request to verify the response.\n                        ocspRequest = ocsp.request.generate(peer.raw, issuer.raw);\n                        // Do we have a result for this certificate in our memory cache?\n                        const sig = ocspRequest.id.toString(\"hex\");\n                        // Stapled response trumps cached response.\n                        if (!stapling) {\n                            const cacheEntry = yield CertCheckAgent.GetResponseFromCache(sig, ocspRequest, proxyInfo);\n                            stapling = cacheEntry;\n                        }\n                        yield this.VerifyOCSPResponse(stapling, ocspRequest, proxyInfo);\n                        socket.uncork();\n                        resolved = true;\n                        resolve(socket);\n                    }\n                    catch (e) {\n                        socket.destroy();\n                        resolved = true;\n                        reject(e);\n                    }\n                }));\n            });\n        });\n    }\n    static GetIssuer(peer) {\n        if (peer.issuerCertificate) {\n            return Promise.resolve(peer.issuerCertificate);\n        }\n        return new Promise((resolve, reject) => {\n            const ocspAgent = new ocsp.Agent({});\n            ocspAgent.fetchIssuer(peer, null, (error, value) => {\n                if (!!error) {\n                    reject(error);\n                    return;\n                }\n                resolve(value);\n            });\n        });\n    }\n    static GetResponseFromCache(signature, ocspRequest, proxyInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cachedResponse = CertCheckAgent.privMemCache[signature];\n            if (!!cachedResponse) {\n                this.onEvent(new OCSPMemoryCacheHitEvent(signature));\n            }\n            // Do we have a result for this certificate on disk in %TMP%?\n            if (!cachedResponse) {\n                try {\n                    const diskCacheResponse = yield CertCheckAgent.privDiskCache.get(signature);\n                    if (!!diskCacheResponse.isCached) {\n                        CertCheckAgent.onEvent(new OCSPDiskCacheHitEvent(signature));\n                        CertCheckAgent.StoreMemoryCacheEntry(signature, diskCacheResponse.value);\n                        cachedResponse = diskCacheResponse.value;\n                    }\n                }\n                catch (error) {\n                    cachedResponse = null;\n                }\n            }\n            if (!cachedResponse) {\n                return cachedResponse;\n            }\n            try {\n                const cachedOcspResponse = ocsp.utils.parseResponse(cachedResponse);\n                const tbsData = cachedOcspResponse.value.tbsResponseData;\n                if (tbsData.responses.length < 1) {\n                    this.onEvent(new OCSPCacheFetchErrorEvent(signature, \"Not enough data in cached response\"));\n                    return;\n                }\n                const cachedStartTime = tbsData.responses[0].thisUpdate;\n                const cachedNextTime = tbsData.responses[0].nextUpdate;\n                if (cachedNextTime < (Date.now() + this.testTimeOffset - 60000)) {\n                    // Cached entry has expired.\n                    this.onEvent(new OCSPCacheEntryExpiredEvent(signature, cachedNextTime));\n                    cachedResponse = null;\n                }\n                else {\n                    // If we're within one day of the next update, or 50% of the way through the validity period,\n                    // background an update to the cache.\n                    const minUpdate = Math.min(24 * 60 * 60 * 1000, (cachedNextTime - cachedStartTime) / 2);\n                    if ((cachedNextTime - (Date.now() + this.testTimeOffset)) < minUpdate) {\n                        this.onEvent(new OCSPCacheEntryNeedsRefreshEvent(signature, cachedStartTime, cachedNextTime));\n                        this.UpdateCache(ocspRequest, proxyInfo).catch((error) => {\n                            // Well, not much we can do here.\n                            this.onEvent(new OCSPCacheUpdateErrorEvent(signature, error.toString()));\n                        });\n                    }\n                    else {\n                        this.onEvent(new OCSPCacheHitEvent(signature, cachedStartTime, cachedNextTime));\n                    }\n                }\n            }\n            catch (error) {\n                this.onEvent(new OCSPCacheFetchErrorEvent(signature, error));\n                cachedResponse = null;\n            }\n            if (!cachedResponse) {\n                this.onEvent(new OCSPCacheMissEvent(signature));\n            }\n            return cachedResponse;\n        });\n    }\n    static VerifyOCSPResponse(cacheValue, ocspRequest, proxyInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let ocspResponse = cacheValue;\n            const sig = ocspRequest.certID.toString(\"hex\");\n            // Do we have a valid response?\n            if (!ocspResponse) {\n                ocspResponse = yield CertCheckAgent.GetOCSPResponse(ocspRequest, proxyInfo);\n            }\n            return new Promise((resolve, reject) => {\n                ocsp.verify({ request: ocspRequest, response: ocspResponse }, (error, result) => {\n                    if (!!error) {\n                        CertCheckAgent.onEvent(new OCSPVerificationFailedEvent(ocspRequest.id.toString(\"hex\"), error));\n                        // Bad Cached Value? One more try without the cache.\n                        if (!!cacheValue) {\n                            this.VerifyOCSPResponse(null, ocspRequest, proxyInfo).then(() => {\n                                resolve();\n                            }, (error) => {\n                                reject(error);\n                            });\n                        }\n                        else {\n                            reject(error);\n                        }\n                    }\n                    else {\n                        if (!cacheValue) {\n                            CertCheckAgent.StoreCacheEntry(ocspRequest.id.toString(\"hex\"), ocspResponse);\n                        }\n                        resolve();\n                    }\n                });\n            });\n        });\n    }\n    static UpdateCache(req, proxyInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const signature = req.id.toString(\"hex\");\n            this.onEvent(new OCSPCacheUpdateNeededEvent(signature));\n            const rawResponse = yield this.GetOCSPResponse(req, proxyInfo);\n            this.StoreCacheEntry(signature, rawResponse);\n            this.onEvent(new OCSPCacheUpdatehCompleteEvent(req.id.toString(\"hex\")));\n        });\n    }\n    static StoreCacheEntry(sig, rawResponse) {\n        this.StoreMemoryCacheEntry(sig, rawResponse);\n        this.StoreDiskCacheEntry(sig, rawResponse);\n    }\n    static StoreMemoryCacheEntry(sig, rawResponse) {\n        this.privMemCache[sig] = rawResponse;\n        this.onEvent(new OCSPMemoryCacheStoreEvent(sig));\n    }\n    static StoreDiskCacheEntry(sig, rawResponse) {\n        this.privDiskCache.set(sig, rawResponse).then(() => {\n            this.onEvent(new OCSPDiskCacheStoreEvent(sig));\n        });\n    }\n    static GetOCSPResponse(req, proxyInfo) {\n        const ocspMethod = \"1.3.6.1.5.5.7.48.1\";\n        let options = {};\n        if (!!proxyInfo) {\n            const agent = CertCheckAgent.GetProxyAgent(proxyInfo);\n            options.agent = agent;\n        }\n        return new Promise((resolve, reject) => {\n            ocsp.utils.getAuthorityInfo(req.cert, ocspMethod, (error, uri) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                const parsedUri = parse.default(uri);\n                parsedUri.path = parsedUri.pathname;\n                options = Object.assign(Object.assign({}, options), parsedUri);\n                ocsp.utils.getResponse(options, req.data, (error, raw) => {\n                    if (error) {\n                        reject(error);\n                        return;\n                    }\n                    this.onEvent(new OCSPResponseRetrievedEvent(req.certID.toString(\"hex\")));\n                    resolve(raw);\n                });\n            });\n        });\n    }\n    CreateConnection(request, options) {\n        const enableOCSP = (typeof process !== \"undefined\" && process.env.NODE_TLS_REJECT_UNAUTHORIZED !== \"0\" && process.env.SPEECH_CONDUCT_OCSP_CHECK !== \"0\") && options.secureEndpoint;\n        let socketPromise;\n        options = Object.assign(Object.assign({}, options), {\n            requestOCSP: !CertCheckAgent.forceDisableOCSPStapling,\n            servername: options.host\n        });\n        if (!!this.privProxyInfo) {\n            const httpProxyAgent = CertCheckAgent.GetProxyAgent(this.privProxyInfo);\n            const baseAgent = httpProxyAgent;\n            socketPromise = new Promise((resolve, reject) => {\n                baseAgent.callback(request, options, (error, socket) => {\n                    if (!!error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve(socket);\n                    }\n                });\n            });\n        }\n        else {\n            if (!!options.secureEndpoint) {\n                socketPromise = Promise.resolve(tls.connect(options));\n            }\n            else {\n                socketPromise = Promise.resolve(net.connect(options));\n            }\n        }\n        if (!!enableOCSP) {\n            return CertCheckAgent.OCSPCheck(socketPromise, this.privProxyInfo);\n        }\n        else {\n            return socketPromise;\n        }\n    }\n}\n// Test hook to enable forcing expiration / refresh to happen.\nCertCheckAgent.testTimeOffset = 0;\n// Test hook to disable stapling for cache testing.\nCertCheckAgent.forceDisableOCSPStapling = false;\n// An in memory cache for recived responses.\nCertCheckAgent.privMemCache = {};\nCertCheckAgent.onEvent = (event) => {\n    Events.instance.onEvent(event);\n};\n\n//# sourceMappingURL=CertChecks.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { EventType } from \"../common/Exports\";\nexport class ConsoleLoggingListener {\n    constructor(logLevelFilter = EventType.Warning) {\n        this.onEvent = (event) => {\n            if (event.eventType >= this.privLogLevelFilter) {\n                const log = this.toString(event);\n                switch (event.eventType) {\n                    case EventType.Debug:\n                        // tslint:disable-next-line:no-console\n                        console.debug(log);\n                        break;\n                    case EventType.Info:\n                        // tslint:disable-next-line:no-console\n                        console.info(log);\n                        break;\n                    case EventType.Warning:\n                        // tslint:disable-next-line:no-console\n                        console.warn(log);\n                        break;\n                    case EventType.Error:\n                        // tslint:disable-next-line:no-console\n                        console.error(log);\n                        break;\n                    default:\n                        // tslint:disable-next-line:no-console\n                        console.log(log);\n                        break;\n                }\n            }\n        };\n        this.toString = (event) => {\n            const logFragments = [\n                `${event.EventTime}`,\n                `${event.Name}`,\n            ];\n            for (const prop in event) {\n                if (prop && event.hasOwnProperty(prop) &&\n                    prop !== \"eventTime\" && prop !== \"eventType\" &&\n                    prop !== \"eventId\" && prop !== \"name\" &&\n                    prop !== \"constructor\") {\n                    const value = event[prop];\n                    let valueToLog = \"<NULL>\";\n                    if (value !== undefined && value !== null) {\n                        if (typeof (value) === \"number\" || typeof (value) === \"string\") {\n                            valueToLog = value.toString();\n                        }\n                        else {\n                            valueToLog = JSON.stringify(value);\n                        }\n                    }\n                    logFragments.push(`${prop}: ${valueToLog}`);\n                }\n            }\n            return logFragments.join(\" | \");\n        };\n        this.privLogLevelFilter = logLevelFilter;\n    }\n}\n\n//# sourceMappingURL=ConsoleLoggingListener.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport * from \"./ConsoleLoggingListener\";\nexport * from \"./IRecorder\";\nexport * from \"./MicAudioSource\";\nexport * from \"./FileAudioSource\";\nexport * from \"./PCMRecorder\";\nexport * from \"./WebsocketConnection\";\nexport * from \"./WebsocketMessageAdapter\";\nexport * from \"./ReplayableAudioNode\";\nexport * from \"./ProxyInfo\";\nexport * from \"./RestMessageAdapter\";\nexport * from \"./RestConfigBase\";\n\n//# sourceMappingURL=Exports.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { connectivity, type, } from \"../common.speech/Exports\";\nimport { AudioSourceErrorEvent, AudioSourceInitializingEvent, AudioSourceOffEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ChunkedArrayBufferStream, createNoDashGuid, Deferred, Events, EventSource, } from \"../common/Exports\";\nimport { AudioStreamFormat } from \"../sdk/Audio/AudioStreamFormat\";\nexport class FileAudioSource {\n    constructor(file, filename, audioSourceId) {\n        this.privStreams = {};\n        this.privHeaderEnd = 44;\n        this.turnOn = () => {\n            if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\n                const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\n                this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\n                return Promise.reject(errorMsg);\n            }\n            this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n            this.onEvent(new AudioSourceReadyEvent(this.privId));\n            return;\n        };\n        this.id = () => {\n            return this.privId;\n        };\n        this.attach = (audioNodeId) => __awaiter(this, void 0, void 0, function* () {\n            this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n            const stream = yield this.upload(audioNodeId);\n            this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n            return Promise.resolve({\n                detach: () => __awaiter(this, void 0, void 0, function* () {\n                    stream.readEnded();\n                    delete this.privStreams[audioNodeId];\n                    this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                    yield this.turnOff();\n                }),\n                id: () => {\n                    return audioNodeId;\n                },\n                read: () => {\n                    return stream.read();\n                },\n            });\n        });\n        this.detach = (audioNodeId) => {\n            if (audioNodeId && this.privStreams[audioNodeId]) {\n                this.privStreams[audioNodeId].close();\n                delete this.privStreams[audioNodeId];\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n            }\n        };\n        this.turnOff = () => {\n            for (const streamId in this.privStreams) {\n                if (streamId) {\n                    const stream = this.privStreams[streamId];\n                    if (stream && !stream.isClosed) {\n                        stream.close();\n                    }\n                }\n            }\n            this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n            return Promise.resolve();\n        };\n        this.onEvent = (event) => {\n            this.privEvents.onEvent(event);\n            Events.instance.onEvent(event);\n        };\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n        this.privEvents = new EventSource();\n        this.privSource = file;\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\n            this.privFilename = file.name;\n        }\n        else {\n            this.privFilename = filename || \"unknown.wav\";\n        }\n        // Read the header.\n        this.privAudioFormatPromise = this.readHeader();\n    }\n    get format() {\n        return this.privAudioFormatPromise;\n    }\n    get blob() {\n        return Promise.resolve(this.privSource);\n    }\n    get events() {\n        return this.privEvents;\n    }\n    get deviceInfo() {\n        return this.privAudioFormatPromise.then((result) => {\n            return Promise.resolve({\n                bitspersample: result.bitsPerSample,\n                channelcount: result.channels,\n                connectivity: connectivity.Unknown,\n                manufacturer: \"Speech SDK\",\n                model: \"File\",\n                samplerate: result.samplesPerSec,\n                type: type.File,\n            });\n        });\n    }\n    readHeader() {\n        // Read the wave header.\n        const maxHeaderSize = 512;\n        const header = this.privSource.slice(0, maxHeaderSize);\n        const headerResult = new Deferred();\n        const processHeader = (header) => {\n            const view = new DataView(header);\n            const getWord = (index) => {\n                return String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\n            };\n            // RIFF 4 bytes.\n            if (\"RIFF\" !== getWord(0)) {\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n                return;\n            }\n            // length, 4 bytes\n            // RIFF Type & fmt 8 bytes\n            if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n                return;\n            }\n            const formatSize = view.getInt32(16, true);\n            const channelCount = view.getUint16(22, true);\n            const sampleRate = view.getUint32(24, true);\n            const bitsPerSample = view.getUint16(34, true);\n            // Confirm if header is 44 bytes long.\n            let pos = 36 + Math.max(formatSize - 16, 0);\n            for (; getWord(pos) !== \"data\"; pos += 2) {\n                if (pos > maxHeaderSize - 8) {\n                    headerResult.reject(\"Invalid WAV header in file, data block was not found\");\n                    return;\n                }\n            }\n            this.privHeaderEnd = pos + 8;\n            headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));\n        };\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\n            const reader = new FileReader();\n            reader.onload = (event) => {\n                const header = event.target.result;\n                processHeader(header);\n            };\n            reader.readAsArrayBuffer(header);\n        }\n        else {\n            const h = header;\n            processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\n        }\n        return headerResult.promise;\n    }\n    upload(audioNodeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const onerror = (error) => {\n                const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\n                this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\n                throw new Error(errorMsg);\n            };\n            try {\n                yield this.turnOn();\n                const format = yield this.privAudioFormatPromise;\n                const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n                this.privStreams[audioNodeId] = stream;\n                const chunk = this.privSource.slice(this.privHeaderEnd);\n                const processFile = (buff) => {\n                    if (stream.isClosed) {\n                        return; // output stream was closed (somebody called TurnOff). We're done here.\n                    }\n                    stream.writeStreamChunk({\n                        buffer: buff,\n                        isEnd: false,\n                        timeReceived: Date.now(),\n                    });\n                    stream.close();\n                };\n                if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\n                    const reader = new FileReader();\n                    reader.onerror = (ev) => { onerror(ev.toString()); };\n                    reader.onload = (event) => {\n                        const fileBuffer = event.target.result;\n                        processFile(fileBuffer);\n                    };\n                    reader.readAsArrayBuffer(chunk);\n                }\n                else {\n                    const c = chunk;\n                    processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\n                }\n                return stream;\n            }\n            catch (e) {\n                onerror(e);\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=FileAudioSource.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=IRecorder.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { connectivity, type } from \"../common.speech/Exports\";\nimport { AudioSourceErrorEvent, AudioSourceInitializingEvent, AudioSourceOffEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ChunkedArrayBufferStream, createNoDashGuid, Deferred, Events, EventSource, } from \"../common/Exports\";\nimport { AudioStreamFormat, AudioStreamFormatImpl, } from \"../sdk/Audio/AudioStreamFormat\";\nexport const AudioWorkletSourceURLPropertyName = \"MICROPHONE-WorkletSourceUrl\";\nexport class MicAudioSource {\n    constructor(privRecorder, deviceId, audioSourceId, mediaStream) {\n        this.privRecorder = privRecorder;\n        this.deviceId = deviceId;\n        this.privStreams = {};\n        this.turnOn = () => {\n            if (this.privInitializeDeferral) {\n                return this.privInitializeDeferral.promise;\n            }\n            this.privInitializeDeferral = new Deferred();\n            try {\n                this.createAudioContext();\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    const typedError = error;\n                    this.privInitializeDeferral.reject(typedError.name + \": \" + typedError.message);\n                }\n                else {\n                    this.privInitializeDeferral.reject(error);\n                }\n                return this.privInitializeDeferral.promise;\n            }\n            const nav = window.navigator;\n            let getUserMedia = (nav.getUserMedia ||\n                nav.webkitGetUserMedia ||\n                nav.mozGetUserMedia ||\n                nav.msGetUserMedia);\n            if (!!nav.mediaDevices) {\n                getUserMedia = (constraints, successCallback, errorCallback) => {\n                    nav.mediaDevices\n                        .getUserMedia(constraints)\n                        .then(successCallback)\n                        .catch(errorCallback);\n                };\n            }\n            if (!getUserMedia) {\n                const errorMsg = \"Browser does not support getUserMedia.\";\n                this.privInitializeDeferral.reject(errorMsg);\n                this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\n            }\n            else {\n                const next = () => {\n                    this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n                    if (this.privMediaStream && this.privMediaStream.active) {\n                        this.onEvent(new AudioSourceReadyEvent(this.privId));\n                        this.privInitializeDeferral.resolve();\n                    }\n                    else {\n                        getUserMedia({ audio: this.deviceId ? { deviceId: this.deviceId } : true, video: false }, (mediaStream) => {\n                            this.privMediaStream = mediaStream;\n                            this.onEvent(new AudioSourceReadyEvent(this.privId));\n                            this.privInitializeDeferral.resolve();\n                        }, (error) => {\n                            const errorMsg = `Error occurred during microphone initialization: ${error}`;\n                            this.privInitializeDeferral.reject(errorMsg);\n                            this.onEvent(new AudioSourceErrorEvent(this.privId, errorMsg));\n                        });\n                    }\n                };\n                if (this.privContext.state === \"suspended\") {\n                    // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\n                    // https://github.com/WebAudio/web-audio-api/issues/790\n                    this.privContext.resume()\n                        .then(next)\n                        .catch((reason) => {\n                        this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);\n                    });\n                }\n                else {\n                    next();\n                }\n            }\n            return this.privInitializeDeferral.promise;\n        };\n        this.id = () => {\n            return this.privId;\n        };\n        this.attach = (audioNodeId) => {\n            this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n            return this.listen(audioNodeId).then((stream) => {\n                this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n                return {\n                    detach: () => __awaiter(this, void 0, void 0, function* () {\n                        stream.readEnded();\n                        delete this.privStreams[audioNodeId];\n                        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                        return this.turnOff();\n                    }),\n                    id: () => {\n                        return audioNodeId;\n                    },\n                    read: () => {\n                        return stream.read();\n                    },\n                };\n            });\n        };\n        this.detach = (audioNodeId) => {\n            if (audioNodeId && this.privStreams[audioNodeId]) {\n                this.privStreams[audioNodeId].close();\n                delete this.privStreams[audioNodeId];\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n            }\n        };\n        this.listen = (audioNodeId) => __awaiter(this, void 0, void 0, function* () {\n            yield this.turnOn();\n            const stream = new ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);\n            this.privStreams[audioNodeId] = stream;\n            try {\n                this.privRecorder.record(this.privContext, this.privMediaStream, stream);\n            }\n            catch (error) {\n                this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));\n                throw error;\n            }\n            const result = stream;\n            return result;\n        });\n        this.onEvent = (event) => {\n            this.privEvents.onEvent(event);\n            Events.instance.onEvent(event);\n        };\n        this.createAudioContext = () => {\n            if (!!this.privContext) {\n                return;\n            }\n            this.privContext = AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec);\n        };\n        this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n        this.privEvents = new EventSource();\n        this.privMediaStream = mediaStream || null;\n        this.privIsClosing = false;\n    }\n    get format() {\n        return Promise.resolve(MicAudioSource.AUDIOFORMAT);\n    }\n    get blob() {\n        return Promise.reject(\"Not implemented for Mic input\");\n    }\n    turnOff() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const streamId in this.privStreams) {\n                if (streamId) {\n                    const stream = this.privStreams[streamId];\n                    if (stream) {\n                        stream.close();\n                    }\n                }\n            }\n            this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n            if (this.privInitializeDeferral) {\n                // Correctly handle when browser forces mic off before turnOn() completes\n                yield this.privInitializeDeferral;\n                this.privInitializeDeferral = null;\n            }\n            yield this.destroyAudioContext();\n            return;\n        });\n    }\n    get events() {\n        return this.privEvents;\n    }\n    get deviceInfo() {\n        return this.getMicrophoneLabel().then((label) => {\n            return {\n                bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,\n                channelcount: MicAudioSource.AUDIOFORMAT.channels,\n                connectivity: connectivity.Unknown,\n                manufacturer: \"Speech SDK\",\n                model: label,\n                samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,\n                type: type.Microphones,\n            };\n        });\n    }\n    setProperty(name, value) {\n        if (name === AudioWorkletSourceURLPropertyName) {\n            this.privRecorder.setWorkletUrl(value);\n        }\n        else {\n            throw new Error(\"Property '\" + name + \"' is not supported on Microphone.\");\n        }\n    }\n    getMicrophoneLabel() {\n        const defaultMicrophoneName = \"microphone\";\n        // If we did this already, return the value.\n        if (this.privMicrophoneLabel !== undefined) {\n            return Promise.resolve(this.privMicrophoneLabel);\n        }\n        // If the stream isn't currently running, we can't query devices because security.\n        if (this.privMediaStream === undefined || !this.privMediaStream.active) {\n            return Promise.resolve(defaultMicrophoneName);\n        }\n        // Setup a default\n        this.privMicrophoneLabel = defaultMicrophoneName;\n        // Get the id of the device running the audio track.\n        const microphoneDeviceId = this.privMediaStream.getTracks()[0].getSettings().deviceId;\n        // If the browser doesn't support getting the device ID, set a default and return.\n        if (undefined === microphoneDeviceId) {\n            return Promise.resolve(this.privMicrophoneLabel);\n        }\n        const deferred = new Deferred();\n        // Enumerate the media devices.\n        navigator.mediaDevices.enumerateDevices().then((devices) => {\n            for (const device of devices) {\n                if (device.deviceId === microphoneDeviceId) {\n                    // Found the device\n                    this.privMicrophoneLabel = device.label;\n                    break;\n                }\n            }\n            deferred.resolve(this.privMicrophoneLabel);\n        }, () => deferred.resolve(this.privMicrophoneLabel));\n        return deferred.promise;\n    }\n    destroyAudioContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.privContext) {\n                return;\n            }\n            this.privRecorder.releaseMediaResources(this.privContext);\n            // This pattern brought to you by a bug in the TypeScript compiler where it\n            // confuses the (\"close\" in this.privContext) with this.privContext always being null as the alternate.\n            // https://github.com/Microsoft/TypeScript/issues/11498\n            let hasClose = false;\n            if (\"close\" in this.privContext) {\n                hasClose = true;\n            }\n            if (hasClose) {\n                if (!this.privIsClosing) {\n                    // The audio context close may take enough time that the close is called twice\n                    this.privIsClosing = true;\n                    yield this.privContext.close();\n                    this.privContext = null;\n                    this.privIsClosing = false;\n                }\n            }\n            else if (null !== this.privContext && this.privContext.state === \"running\") {\n                // Suspend actually takes a callback, but analogous to the\n                // resume method, it'll be only fired if suspend is called\n                // in a direct response to a user action. The later is not always\n                // the case, as TurnOff is also called, when we receive an\n                // end-of-speech message from the service. So, doing a best effort\n                // fire-and-forget here.\n                yield this.privContext.suspend();\n            }\n        });\n    }\n}\nMicAudioSource.AUDIOFORMAT = AudioStreamFormat.getDefaultInputFormat();\n\n//# sourceMappingURL=MicAudioSource.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RiffPcmEncoder } from \"../common/Exports\";\nexport class PcmRecorder {\n    constructor(stopInputOnRelease) {\n        this.record = (context, mediaStream, outputStream) => {\n            const desiredSampleRate = 16000;\n            const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\n            let needHeader = true;\n            const micInput = context.createMediaStreamSource(mediaStream);\n            if (!this.privSpeechProcessorScript) {\n                const workletScript = `class SP extends AudioWorkletProcessor {\r\n                constructor(options) {\r\n                  super(options);\r\n                }\r\n                process(inputs, outputs) {\r\n                  const input = inputs[0];\r\n                  const output = [];\r\n                  for (let channel = 0; channel < input.length; channel += 1) {\r\n                    output[channel] = input[channel];\r\n                  }\r\n                  this.port.postMessage(output[0]);\r\n                  return true;\r\n                }\r\n              }\r\n              registerProcessor('speech-processor', SP);`; // tslint:disable-line:max-line-length\n                const blob = new Blob([workletScript], { type: \"application/javascript; charset=utf-8\" });\n                this.privSpeechProcessorScript = URL.createObjectURL(blob);\n            }\n            // https://webaudio.github.io/web-audio-api/#audioworklet\n            // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\n            if (!!this.privSpeechProcessorScript && !!context.audioWorklet) {\n                context.audioWorklet\n                    .addModule(this.privSpeechProcessorScript)\n                    .then(() => {\n                    const workletNode = new AudioWorkletNode(context, \"speech-processor\");\n                    workletNode.port.onmessage = (ev) => {\n                        const inputFrame = ev.data;\n                        if (outputStream && !outputStream.isClosed) {\n                            const waveFrame = waveStreamEncoder.encode(inputFrame);\n                            if (!!waveFrame) {\n                                outputStream.writeStreamChunk({\n                                    buffer: waveFrame,\n                                    isEnd: false,\n                                    timeReceived: Date.now(),\n                                });\n                                needHeader = false;\n                            }\n                        }\n                    };\n                    micInput.connect(workletNode);\n                    workletNode.connect(context.destination);\n                    this.privMediaResources = {\n                        scriptProcessorNode: workletNode,\n                        source: micInput,\n                        stream: mediaStream,\n                    };\n                })\n                    .catch(() => {\n                    const scriptNode = (() => {\n                        let bufferSize = 0;\n                        try {\n                            return context.createScriptProcessor(bufferSize, 1, 1);\n                        }\n                        catch (error) {\n                            // Webkit (<= version 31) requires a valid bufferSize.\n                            bufferSize = 2048;\n                            let audioSampleRate = context.sampleRate;\n                            while (bufferSize < 16384 && audioSampleRate >= (2 * desiredSampleRate)) {\n                                bufferSize <<= 1;\n                                audioSampleRate >>= 1;\n                            }\n                            return context.createScriptProcessor(bufferSize, 1, 1);\n                        }\n                    })();\n                    scriptNode.onaudioprocess = (event) => {\n                        const inputFrame = event.inputBuffer.getChannelData(0);\n                        if (outputStream && !outputStream.isClosed) {\n                            const waveFrame = waveStreamEncoder.encode(inputFrame);\n                            if (!!waveFrame) {\n                                outputStream.writeStreamChunk({\n                                    buffer: waveFrame,\n                                    isEnd: false,\n                                    timeReceived: Date.now(),\n                                });\n                                needHeader = false;\n                            }\n                        }\n                    };\n                    micInput.connect(scriptNode);\n                    scriptNode.connect(context.destination);\n                    this.privMediaResources = {\n                        scriptProcessorNode: scriptNode,\n                        source: micInput,\n                        stream: mediaStream,\n                    };\n                });\n            }\n            else {\n                throw new Error(\"Unable to start audio worklet node for PCMRecorder\");\n            }\n        };\n        this.releaseMediaResources = (context) => {\n            if (this.privMediaResources) {\n                if (this.privMediaResources.scriptProcessorNode) {\n                    this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\n                    this.privMediaResources.scriptProcessorNode = null;\n                }\n                if (this.privMediaResources.source) {\n                    this.privMediaResources.source.disconnect();\n                    if (this.privStopInputOnRelease) {\n                        this.privMediaResources.stream.getTracks().forEach((track) => track.stop());\n                    }\n                    this.privMediaResources.source = null;\n                }\n            }\n        };\n        this.privStopInputOnRelease = stopInputOnRelease;\n    }\n    setWorkletUrl(url) {\n        this.privSpeechProcessorScript = url;\n    }\n}\n\n//# sourceMappingURL=PCMRecorder.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { PropertyId } from \"../sdk/Exports\";\nexport class ProxyInfo {\n    constructor(proxyHostName, proxyPort, proxyUserName, proxyPassword) {\n        this.privProxyHostName = proxyHostName;\n        this.privProxyPort = proxyPort;\n        this.privProxyUserName = proxyUserName;\n        this.privProxyPassword = proxyPassword;\n    }\n    static fromParameters(parameters) {\n        return new ProxyInfo(parameters.getProperty(PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(parameters.getProperty(PropertyId.SpeechServiceConnection_ProxyPort), 10), parameters.getProperty(PropertyId.SpeechServiceConnection_ProxyUserName), parameters.getProperty(PropertyId.SpeechServiceConnection_ProxyPassword));\n    }\n    static fromRecognizerConfig(config) {\n        return this.fromParameters(config.parameters);\n    }\n    get HostName() {\n        return this.privProxyHostName;\n    }\n    get Port() {\n        return this.privProxyPort;\n    }\n    get UserName() {\n        return this.privProxyUserName;\n    }\n    get Password() {\n        return this.privProxyPassword;\n    }\n}\n\n//# sourceMappingURL=ProxyInfo.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class ReplayableAudioNode {\n    constructor(audioSource, bytesPerSecond) {\n        this.privBuffers = [];\n        this.privReplayOffset = 0;\n        this.privLastShrinkOffset = 0;\n        this.privBufferStartOffset = 0;\n        this.privBufferSerial = 0;\n        this.privBufferedBytes = 0;\n        this.privReplay = false;\n        this.privLastChunkAcquiredTime = 0;\n        this.id = () => {\n            return this.privAudioNode.id();\n        };\n        this.privAudioNode = audioSource;\n        this.privBytesPerSecond = bytesPerSecond;\n    }\n    // Reads and returns the next chunk of audio buffer.\n    // If replay of existing buffers are needed, read() will first seek and replay\n    // existing content, and upoin completion it will read new content from the underlying\n    // audio node, saving that content into the replayable buffers.\n    read() {\n        // if there is a replay request to honor.\n        if (!!this.privReplay && this.privBuffers.length !== 0) {\n            // Find the start point in the buffers.\n            // Offsets are in 100ns increments.\n            // So how many bytes do we need to seek to get the right offset?\n            const offsetToSeek = this.privReplayOffset - this.privBufferStartOffset;\n            let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n            if (0 !== (bytesToSeek % 2)) {\n                bytesToSeek++;\n            }\n            let i = 0;\n            while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n                bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n            }\n            if (i < this.privBuffers.length) {\n                const retVal = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);\n                this.privReplayOffset += (retVal.byteLength / this.privBytesPerSecond) * 1e+7;\n                // If we've reached the end of the buffers, stop replaying.\n                if (i === this.privBuffers.length - 1) {\n                    this.privReplay = false;\n                }\n                return Promise.resolve({\n                    buffer: retVal,\n                    isEnd: false,\n                    timeReceived: this.privBuffers[i].chunk.timeReceived,\n                });\n            }\n        }\n        return this.privAudioNode.read()\n            .then((result) => {\n            if (result && result.buffer) {\n                this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes));\n                this.privBufferedBytes += result.buffer.byteLength;\n            }\n            return result;\n        });\n    }\n    detach() {\n        this.privBuffers = undefined;\n        return this.privAudioNode.detach();\n    }\n    replay() {\n        if (this.privBuffers && 0 !== this.privBuffers.length) {\n            this.privReplay = true;\n            this.privReplayOffset = this.privLastShrinkOffset;\n        }\n    }\n    // Shrinks the existing audio buffers to start at the new offset, or at the\n    // beginning of the buffer closest to the requested offset.\n    // A replay request will start from the last shrink point.\n    shrinkBuffers(offset) {\n        if (this.privBuffers === undefined || this.privBuffers.length === 0) {\n            return;\n        }\n        this.privLastShrinkOffset = offset;\n        // Find the start point in the buffers.\n        // Offsets are in 100ns increments.\n        // So how many bytes do we need to seek to get the right offset?\n        const offsetToSeek = offset - this.privBufferStartOffset;\n        let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n        let i = 0;\n        while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n            bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n        }\n        this.privBufferStartOffset = Math.round(offset - ((bytesToSeek / this.privBytesPerSecond) * 1e+7));\n        this.privBuffers = this.privBuffers.slice(i);\n    }\n    // Finds the time a buffer of audio was first seen by offset.\n    findTimeAtOffset(offset) {\n        if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {\n            return 0;\n        }\n        for (const value of this.privBuffers) {\n            const startOffset = (value.byteOffset / this.privBytesPerSecond) * 1e7;\n            const endOffset = startOffset + ((value.chunk.buffer.byteLength / this.privBytesPerSecond) * 1e7);\n            if (offset >= startOffset && offset <= endOffset) {\n                return value.chunk.timeReceived;\n            }\n        }\n        return 0;\n    }\n}\n// Primary use of this class is to help debugging problems with the replay\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\n// the ArrayBuffer directly.\n// tslint:disable-next-line:max-classes-per-file\nclass BufferEntry {\n    constructor(chunk, serial, byteOffset) {\n        this.chunk = chunk;\n        this.serial = serial;\n        this.byteOffset = byteOffset;\n    }\n}\n\n//# sourceMappingURL=ReplayableAudioNode.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class RestConfigBase {\n    static get requestOptions() {\n        return RestConfigBase.privDefaultRequestOptions;\n    }\n    static get configParams() {\n        return RestConfigBase.privDefaultParams;\n    }\n    static get restErrors() {\n        return RestConfigBase.privRestErrors;\n    }\n}\nRestConfigBase.privDefaultRequestOptions = {\n    headers: {\n        Accept: \"application/json\",\n    },\n    ignoreCache: false,\n    timeout: 10000,\n};\nRestConfigBase.privRestErrors = {\n    authInvalidSubscriptionKey: \"You must specify either an authentication token to use, or a Cognitive Speech subscription key.\",\n    authInvalidSubscriptionRegion: \"You must specify the Cognitive Speech region to use.\",\n    invalidArgs: \"Required input not found: {arg}.\",\n    invalidCreateJoinConversationResponse: \"Creating/Joining conversation failed with HTTP {status}.\",\n    invalidParticipantRequest: \"The requested participant was not found.\",\n    permissionDeniedConnect: \"Required credentials not found.\",\n    permissionDeniedConversation: \"Invalid operation: only the host can {command} the conversation.\",\n    permissionDeniedParticipant: \"Invalid operation: only the host can {command} a participant.\",\n    permissionDeniedSend: \"Invalid operation: the conversation is not in a connected state.\",\n    permissionDeniedStart: \"Invalid operation: there is already an active conversation.\",\n};\nRestConfigBase.privDefaultParams = {\n    apiVersion: \"api-version\",\n    authorization: \"Authorization\",\n    clientAppId: \"X-ClientAppId\",\n    contentTypeKey: \"Content-Type\",\n    correlationId: \"X-CorrelationId\",\n    languageCode: \"language\",\n    nickname: \"nickname\",\n    profanity: \"profanity\",\n    requestId: \"X-RequestId\",\n    roomId: \"roomid\",\n    sessionToken: \"token\",\n    subscriptionKey: \"Ocp-Apim-Subscription-Key\",\n    subscriptionRegion: \"Ocp-Apim-Subscription-Region\",\n    token: \"X-CapitoToken\",\n};\n\n//# sourceMappingURL=RestConfigBase.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ArgumentNullError, Deferred } from \"../common/Exports\";\nimport bent from \"bent\";\nexport var RestRequestType;\n(function (RestRequestType) {\n    RestRequestType[\"Get\"] = \"GET\";\n    RestRequestType[\"Post\"] = \"POST\";\n    RestRequestType[\"Delete\"] = \"DELETE\";\n    RestRequestType[\"File\"] = \"file\";\n})(RestRequestType || (RestRequestType = {}));\n// accept rest operations via request method and return abstracted objects from server response\nexport class RestMessageAdapter {\n    constructor(configParams) {\n        if (!configParams) {\n            throw new ArgumentNullError(\"configParams\");\n        }\n        this.privHeaders = configParams.headers;\n        this.privIgnoreCache = configParams.ignoreCache;\n    }\n    static extractHeaderValue(headerKey, headers) {\n        let headerValue = \"\";\n        try {\n            const arr = headers.trim().split(/[\\r\\n]+/);\n            const headerMap = {};\n            arr.forEach((line) => {\n                const parts = line.split(\": \");\n                const header = parts.shift().toLowerCase();\n                const value = parts.join(\": \");\n                headerMap[header] = value;\n            });\n            headerValue = headerMap[headerKey.toLowerCase()];\n        }\n        catch (e) {\n            // ignore the error\n        }\n        return headerValue;\n    }\n    set options(configParams) {\n        this.privHeaders = configParams.headers;\n        this.privIgnoreCache = configParams.ignoreCache;\n    }\n    setHeaders(key, value) {\n        this.privHeaders[key] = value;\n    }\n    request(method, uri, queryParams = {}, body = null, binaryBody = null) {\n        const responseReceivedDeferral = new Deferred();\n        const requestCommand = method === RestRequestType.File ? \"POST\" : method;\n        const handleRestResponse = (data, j = {}) => {\n            const d = data;\n            return {\n                data: JSON.stringify(j),\n                headers: JSON.stringify(data.headers),\n                json: j,\n                ok: data.statusCode >= 200 && data.statusCode < 300,\n                status: data.statusCode,\n                statusText: j.error ? j.error.message : d.statusText ? d.statusText : d.statusMessage\n            };\n        };\n        const blobToArrayBuffer = (blob) => {\n            const reader = new FileReader();\n            reader.readAsArrayBuffer(blob);\n            return new Promise((resolve) => {\n                reader.onloadend = () => {\n                    resolve(reader.result);\n                };\n            });\n        };\n        const send = (postData) => {\n            const sendRequest = bent(uri, requestCommand, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404);\n            const params = this.queryParams(queryParams) === \"\" ? \"\" : \"?\" + this.queryParams(queryParams);\n            sendRequest(params, postData).then((data) => __awaiter(this, void 0, void 0, function* () {\n                if (method === RestRequestType.Delete || data.statusCode === 204) {\n                    // No JSON from Delete and reset (204) operations\n                    responseReceivedDeferral.resolve(handleRestResponse(data));\n                }\n                else {\n                    const j = yield data.json();\n                    responseReceivedDeferral.resolve(handleRestResponse(data, j));\n                }\n            })).catch((error) => {\n                responseReceivedDeferral.reject(error);\n            });\n        };\n        if (this.privIgnoreCache) {\n            this.privHeaders[\"Cache-Control\"] = \"no-cache\";\n        }\n        if (method === RestRequestType.File && binaryBody) {\n            const contentType = \"multipart/form-data\";\n            this.privHeaders[\"content-type\"] = contentType;\n            this.privHeaders[\"Content-Type\"] = contentType;\n            if (typeof (Blob) !== \"undefined\" && binaryBody instanceof Blob) {\n                blobToArrayBuffer(binaryBody).then((res) => {\n                    send(res);\n                }).catch((error) => {\n                    responseReceivedDeferral.reject(error);\n                });\n            }\n            else {\n                send(binaryBody);\n            }\n        }\n        else {\n            if (method === RestRequestType.Post && body) {\n                this.privHeaders[\"content-type\"] = \"application/json\";\n                this.privHeaders[\"Content-Type\"] = \"application/json\";\n            }\n            send(body);\n        }\n        return responseReceivedDeferral.promise;\n    }\n    withQuery(url, params = {}) {\n        const queryString = this.queryParams(params);\n        return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\n    }\n    queryParams(params = {}) {\n        return Object.keys(params)\n            .map((k) => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k]))\n            .join(\"&\");\n    }\n}\n\n//# sourceMappingURL=RestMessageAdapter.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ArgumentNullError, createNoDashGuid, } from \"../common/Exports\";\nimport { WebsocketMessageAdapter } from \"./WebsocketMessageAdapter\";\nexport class WebsocketConnection {\n    constructor(uri, queryParameters, headers, messageFormatter, proxyInfo, enableCompression = false, connectionId) {\n        this.privIsDisposed = false;\n        this.isDisposed = () => {\n            return this.privIsDisposed;\n        };\n        this.state = () => {\n            return this.privConnectionMessageAdapter.state;\n        };\n        this.open = () => {\n            return this.privConnectionMessageAdapter.open();\n        };\n        this.send = (message) => {\n            return this.privConnectionMessageAdapter.send(message);\n        };\n        this.read = () => {\n            return this.privConnectionMessageAdapter.read();\n        };\n        if (!uri) {\n            throw new ArgumentNullError(\"uri\");\n        }\n        if (!messageFormatter) {\n            throw new ArgumentNullError(\"messageFormatter\");\n        }\n        this.privMessageFormatter = messageFormatter;\n        let queryParams = \"\";\n        let i = 0;\n        if (queryParameters) {\n            for (const paramName in queryParameters) {\n                if (paramName) {\n                    queryParams += ((i === 0) && (uri.indexOf(\"?\") === -1)) ? \"?\" : \"&\";\n                    const val = encodeURIComponent(queryParameters[paramName]);\n                    queryParams += `${paramName}=${val}`;\n                    i++;\n                }\n            }\n        }\n        if (headers) {\n            for (const headerName in headers) {\n                if (headerName) {\n                    queryParams += ((i === 0) && (uri.indexOf(\"?\") === -1)) ? \"?\" : \"&\";\n                    const val = encodeURIComponent(headers[headerName]);\n                    queryParams += `${headerName}=${val}`;\n                    i++;\n                }\n            }\n        }\n        this.privUri = uri + queryParams;\n        this.privId = connectionId ? connectionId : createNoDashGuid();\n        this.privConnectionMessageAdapter = new WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, proxyInfo, headers, enableCompression);\n    }\n    dispose() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.privIsDisposed = true;\n            if (this.privConnectionMessageAdapter) {\n                yield this.privConnectionMessageAdapter.close();\n            }\n        });\n    }\n    get id() {\n        return this.privId;\n    }\n    get events() {\n        return this.privConnectionMessageAdapter.events;\n    }\n}\n\n//# sourceMappingURL=WebsocketConnection.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\nimport { ArgumentNullError, BackgroundEvent, ConnectionClosedEvent, ConnectionErrorEvent, ConnectionEstablishedEvent, ConnectionMessageReceivedEvent, ConnectionMessageSentEvent, ConnectionOpenResponse, ConnectionStartEvent, ConnectionState, Deferred, Events, EventSource, MessageType, Queue, RawWebsocketMessage, } from \"../common/Exports\";\n// Node.JS specific web socket / browser support.\nimport ws from \"ws\";\nimport { CertCheckAgent } from \"./CertChecks\";\nexport class WebsocketMessageAdapter {\n    constructor(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {\n        this.open = () => {\n            if (this.privConnectionState === ConnectionState.Disconnected) {\n                return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);\n            }\n            if (this.privConnectionEstablishDeferral) {\n                return this.privConnectionEstablishDeferral.promise;\n            }\n            this.privConnectionEstablishDeferral = new Deferred();\n            this.privCertificateValidatedDeferral = new Deferred();\n            this.privConnectionState = ConnectionState.Connecting;\n            try {\n                if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\n                    // Browser handles cert checks.\n                    this.privCertificateValidatedDeferral.resolve();\n                    this.privWebsocketClient = new WebSocket(this.privUri);\n                }\n                else {\n                    const options = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression };\n                    // The ocsp library will handle validation for us and fail the connection if needed.\n                    this.privCertificateValidatedDeferral.resolve();\n                    const checkAgent = new CertCheckAgent(this.proxyInfo);\n                    options.agent = checkAgent.GetAgent();\n                    this.privWebsocketClient = new ws(this.privUri, options);\n                }\n                this.privWebsocketClient.binaryType = \"arraybuffer\";\n                this.privReceivingMessageQueue = new Queue();\n                this.privDisconnectDeferral = new Deferred();\n                this.privSendMessageQueue = new Queue();\n                this.processSendQueue().catch((reason) => {\n                    Events.instance.onEvent(new BackgroundEvent(reason));\n                });\n            }\n            catch (error) {\n                this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error));\n                return this.privConnectionEstablishDeferral.promise;\n            }\n            this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\n            this.privWebsocketClient.onopen = (e) => {\n                this.privCertificateValidatedDeferral.promise.then(() => {\n                    this.privConnectionState = ConnectionState.Connected;\n                    this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\n                    this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\n                }, (error) => {\n                    this.privConnectionEstablishDeferral.reject(error);\n                });\n            };\n            this.privWebsocketClient.onerror = (e) => {\n                this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\n                this.privLastErrorReceived = e.message;\n            };\n            this.privWebsocketClient.onclose = (e) => {\n                if (this.privConnectionState === ConnectionState.Connecting) {\n                    this.privConnectionState = ConnectionState.Disconnected;\n                    // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\n                    this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\n                }\n                else {\n                    this.privConnectionState = ConnectionState.Disconnected;\n                    this.privWebsocketClient = null;\n                    this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\n                }\n                this.onClose(e.code, e.reason).catch((reason) => {\n                    Events.instance.onEvent(new BackgroundEvent(reason));\n                });\n            };\n            this.privWebsocketClient.onmessage = (e) => {\n                const networkReceivedTime = new Date().toISOString();\n                if (this.privConnectionState === ConnectionState.Connected) {\n                    const deferred = new Deferred();\n                    // let id = ++this.idCounter;\n                    this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);\n                    if (e.data instanceof ArrayBuffer) {\n                        const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\n                        this.privMessageFormatter\n                            .toConnectionMessage(rawMessage)\n                            .then((connectionMessage) => {\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n                            deferred.resolve(connectionMessage);\n                        }, (error) => {\n                            // TODO: Events for these ?\n                            deferred.reject(`Invalid binary message format. Error: ${error}`);\n                        });\n                    }\n                    else {\n                        const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\n                        this.privMessageFormatter\n                            .toConnectionMessage(rawMessage)\n                            .then((connectionMessage) => {\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n                            deferred.resolve(connectionMessage);\n                        }, (error) => {\n                            // TODO: Events for these ?\n                            deferred.reject(`Invalid text message format. Error: ${error}`);\n                        });\n                    }\n                }\n            };\n            return this.privConnectionEstablishDeferral.promise;\n        };\n        this.send = (message) => {\n            if (this.privConnectionState !== ConnectionState.Connected) {\n                return Promise.reject(`Cannot send on connection that is in ${ConnectionState[this.privConnectionState]} state`);\n            }\n            const messageSendStatusDeferral = new Deferred();\n            const messageSendDeferral = new Deferred();\n            this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);\n            this.privMessageFormatter\n                .fromConnectionMessage(message)\n                .then((rawMessage) => {\n                messageSendDeferral.resolve({\n                    Message: message,\n                    RawWebsocketMessage: rawMessage,\n                    sendStatusDeferral: messageSendStatusDeferral,\n                });\n            }, (error) => {\n                messageSendDeferral.reject(`Error formatting the message. ${error}`);\n            });\n            return messageSendStatusDeferral.promise;\n        };\n        this.read = () => {\n            if (this.privConnectionState !== ConnectionState.Connected) {\n                return Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`);\n            }\n            return this.privReceivingMessageQueue.dequeue();\n        };\n        this.close = (reason) => {\n            if (this.privWebsocketClient) {\n                if (this.privConnectionState !== ConnectionState.Disconnected) {\n                    this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\n                }\n            }\n            else {\n                return Promise.resolve();\n            }\n            return this.privDisconnectDeferral.promise;\n        };\n        this.sendRawMessage = (sendItem) => {\n            try {\n                // indicates we are draining the queue and it came with no message;\n                if (!sendItem) {\n                    return Promise.resolve();\n                }\n                this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));\n                // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\n                if (this.isWebsocketOpen) {\n                    this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\n                }\n                else {\n                    return Promise.reject(\"websocket send error: Websocket not ready \" + this.privConnectionId + \" \" + sendItem.Message.id + \" \" + new Error().stack);\n                }\n                return Promise.resolve();\n            }\n            catch (e) {\n                return Promise.reject(`websocket send error: ${e}`);\n            }\n        };\n        this.onEvent = (event) => {\n            this.privConnectionEvents.onEvent(event);\n            Events.instance.onEvent(event);\n        };\n        if (!uri) {\n            throw new ArgumentNullError(\"uri\");\n        }\n        if (!messageFormatter) {\n            throw new ArgumentNullError(\"messageFormatter\");\n        }\n        this.proxyInfo = proxyInfo;\n        this.privConnectionEvents = new EventSource();\n        this.privConnectionId = connectionId;\n        this.privMessageFormatter = messageFormatter;\n        this.privConnectionState = ConnectionState.None;\n        this.privUri = uri;\n        this.privHeaders = headers;\n        this.privEnableCompression = enableCompression;\n        // Add the connection ID to the headers\n        this.privHeaders[HeaderNames.ConnectionId] = this.privConnectionId;\n        this.privLastErrorReceived = \"\";\n    }\n    get state() {\n        return this.privConnectionState;\n    }\n    get events() {\n        return this.privConnectionEvents;\n    }\n    onClose(code, reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const closeReason = `Connection closed. ${code}: ${reason}`;\n            this.privConnectionState = ConnectionState.Disconnected;\n            this.privDisconnectDeferral.resolve();\n            yield this.privReceivingMessageQueue.drainAndDispose((pendingReceiveItem) => {\n                // TODO: Events for these ?\n                // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\n            }, closeReason);\n            yield this.privSendMessageQueue.drainAndDispose((pendingSendItem) => {\n                pendingSendItem.sendStatusDeferral.reject(closeReason);\n            }, closeReason);\n        });\n    }\n    processSendQueue() {\n        return __awaiter(this, void 0, void 0, function* () {\n            while (true) {\n                const itemToSend = this.privSendMessageQueue.dequeue();\n                const sendItem = yield itemToSend;\n                // indicates we are draining the queue and it came with no message;\n                if (!sendItem) {\n                    return;\n                }\n                try {\n                    yield this.sendRawMessage(sendItem);\n                    sendItem.sendStatusDeferral.resolve();\n                }\n                catch (sendError) {\n                    sendItem.sendStatusDeferral.reject(sendError);\n                }\n            }\n        });\n    }\n    get isWebsocketOpen() {\n        return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\n    }\n}\nWebsocketMessageAdapter.forceNpmWebSocket = false;\n\n//# sourceMappingURL=WebsocketMessageAdapter.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * @class AddedLmIntent\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class AddedLmIntent {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param modelImpl - The model.\n     * @param intentName - The intent name.\n     */\n    constructor(modelImpl, intentName) {\n        this.modelImpl = modelImpl;\n        this.intentName = intentName;\n    }\n}\n\n//# sourceMappingURL=AddedLmIntent.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Represents the JSON used in the agent.config message sent to the speech service.\n */\nexport class AgentConfig {\n    toJsonString() {\n        return JSON.stringify(this.iPrivConfig);\n    }\n    get() {\n        return this.iPrivConfig;\n    }\n    /**\n     * Setter for the agent.config object.\n     * @param value a JSON serializable object.\n     */\n    set(value) {\n        this.iPrivConfig = value;\n    }\n}\n\n//# sourceMappingURL=AgentConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ArgumentNullError, } from \"../common/Exports\";\nimport { HeaderNames } from \"./HeaderNames\";\nimport { AuthInfo } from \"./IAuthentication\";\n/**\n * @class\n */\nexport class CognitiveSubscriptionKeyAuthentication {\n    /**\n     * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.\n     * @constructor\n     * @param {string} subscriptionKey - The subscription key\n     */\n    constructor(subscriptionKey) {\n        /**\n         * Fetches the subscription key.\n         * @member\n         * @function\n         * @public\n         * @param {string} authFetchEventId - The id to fetch.\n         */\n        this.fetch = (authFetchEventId) => {\n            return Promise.resolve(this.privAuthInfo);\n        };\n        /**\n         * Fetches the subscription key.\n         * @member\n         * @function\n         * @public\n         * @param {string} authFetchEventId - The id to fetch.\n         */\n        this.fetchOnExpiry = (authFetchEventId) => {\n            return Promise.resolve(this.privAuthInfo);\n        };\n        if (!subscriptionKey) {\n            throw new ArgumentNullError(\"subscriptionKey\");\n        }\n        this.privAuthInfo = new AuthInfo(HeaderNames.AuthKey, subscriptionKey);\n    }\n}\n\n//# sourceMappingURL=CognitiveSubscriptionKeyAuthentication.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ArgumentNullError } from \"../common/Exports\";\nimport { AuthInfo } from \"./IAuthentication\";\nconst AuthHeader = \"Authorization\";\nexport class CognitiveTokenAuthentication {\n    constructor(fetchCallback, fetchOnExpiryCallback) {\n        this.fetch = (authFetchEventId) => {\n            return this.privFetchCallback(authFetchEventId).then((token) => new AuthInfo(AuthHeader, token));\n        };\n        this.fetchOnExpiry = (authFetchEventId) => {\n            return this.privFetchOnExpiryCallback(authFetchEventId).then((token) => new AuthInfo(AuthHeader, token));\n        };\n        if (!fetchCallback) {\n            throw new ArgumentNullError(\"fetchCallback\");\n        }\n        if (!fetchOnExpiryCallback) {\n            throw new ArgumentNullError(\"fetchOnExpiryCallback\");\n        }\n        this.privFetchCallback = fetchCallback;\n        this.privFetchOnExpiryCallback = fetchOnExpiryCallback;\n    }\n}\n\n//# sourceMappingURL=CognitiveTokenAuthentication.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ServicePropertiesPropertyName, } from \"../common.speech/Exports\";\nimport { PropertyId } from \"../sdk/Exports\";\nimport { QueryParameterNames } from \"./QueryParameterNames\";\nexport class ConnectionFactoryBase {\n    setCommonUrlParams(config, queryParams, endpoint) {\n        this.setUrlParameter(PropertyId.SpeechServiceConnection_EnableAudioLogging, QueryParameterNames.EnableAudioLogging, config, queryParams, endpoint);\n        this.setUrlParameter(PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, QueryParameterNames.EnableWordLevelTimestamps, config, queryParams, endpoint);\n        this.setUrlParameter(PropertyId.SpeechServiceResponse_ProfanityOption, QueryParameterNames.Profanity, config, queryParams, endpoint);\n        this.setUrlParameter(PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, QueryParameterNames.InitialSilenceTimeoutMs, config, queryParams, endpoint);\n        this.setUrlParameter(PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, QueryParameterNames.EndSilenceTimeoutMs, config, queryParams, endpoint);\n        this.setUrlParameter(PropertyId.SpeechServiceResponse_StablePartialResultThreshold, QueryParameterNames.StableIntermediateThreshold, config, queryParams, endpoint);\n        const serviceProperties = JSON.parse(config.parameters.getProperty(ServicePropertiesPropertyName, \"{}\"));\n        Object.keys(serviceProperties).forEach((value, num, array) => {\n            queryParams[value] = serviceProperties[value];\n        });\n    }\n    setUrlParameter(propId, parameterName, config, queryParams, endpoint) {\n        const value = config.parameters.getProperty(propId, undefined);\n        if (value && (!endpoint || endpoint.search(parameterName) === -1)) {\n            queryParams[parameterName] = value.toLocaleLowerCase();\n        }\n    }\n}\n\n//# sourceMappingURL=ConnectionFactoryBase.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar _a;\nimport { ProxyInfo, WebsocketConnection, } from \"../common.browser/Exports\";\nimport { OutputFormatPropertyName } from \"../common.speech/Exports\";\nimport { DialogServiceConfig, OutputFormat, PropertyId } from \"../sdk/Exports\";\nimport { ConnectionFactoryBase } from \"./ConnectionFactoryBase\";\nimport { WebsocketMessageFormatter } from \"./Exports\";\nimport { HeaderNames } from \"./HeaderNames\";\nimport { QueryParameterNames } from \"./QueryParameterNames\";\nexport class DialogConnectionFactory extends ConnectionFactoryBase {\n    constructor() {\n        super(...arguments);\n        this.create = (config, authInfo, connectionId) => {\n            const applicationId = config.parameters.getProperty(PropertyId.Conversation_ApplicationId, \"\");\n            const dialogType = config.parameters.getProperty(PropertyId.Conversation_DialogType);\n            const region = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Region);\n            const language = config.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-US\");\n            const requestTurnStatus = config.parameters.getProperty(PropertyId.Conversation_Request_Bot_Status_Messages, \"true\");\n            const queryParams = {};\n            queryParams[HeaderNames.ConnectionId] = connectionId;\n            queryParams[QueryParameterNames.Format] = config.parameters.getProperty(OutputFormatPropertyName, OutputFormat[OutputFormat.Simple]).toLowerCase();\n            queryParams[QueryParameterNames.Language] = language;\n            queryParams[QueryParameterNames.RequestBotStatusMessages] = requestTurnStatus;\n            if (applicationId) {\n                queryParams[QueryParameterNames.BotId] = applicationId;\n                if (dialogType === DialogServiceConfig.DialogTypes.CustomCommands) {\n                    queryParams[HeaderNames.CustomCommandsAppId] = applicationId;\n                }\n            }\n            const resourceInfix = dialogType === DialogServiceConfig.DialogTypes.CustomCommands ? \"commands/\"\n                : \"\";\n            const version = dialogType === DialogServiceConfig.DialogTypes.CustomCommands ? \"v1\"\n                : dialogType === DialogServiceConfig.DialogTypes.BotFramework ? \"v3\"\n                    : \"v0\";\n            const headers = {};\n            if (authInfo.token != null && authInfo.token !== \"\") {\n                headers[authInfo.headerName] = authInfo.token;\n            }\n            // The URL used for connection is chosen in a priority order of specification:\n            //  1. If a custom endpoint is provided, that URL is used verbatim.\n            //  2. If a custom host is provided (e.g. \"wss://my.custom.endpoint.com:1123\"), a URL is constructed from it.\n            //  3. If no custom connection details are provided, a URL is constructed from default values.\n            let endpoint = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint, \"\");\n            if (!endpoint) {\n                const hostSuffix = (region && region.toLowerCase().startsWith(\"china\")) ? \".azure.cn\" : \".microsoft.com\";\n                const host = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Host, `wss://${region}.${DialogConnectionFactory.Constants.BaseUrl}${hostSuffix}`);\n                const standardizedHost = host.endsWith(\"/\") ? host : host + \"/\";\n                endpoint = `${standardizedHost}${resourceInfix}${DialogConnectionFactory.Constants.ApiKey}/${version}`;\n            }\n            this.setCommonUrlParams(config, queryParams, endpoint);\n            const enableCompression = config.parameters.getProperty(\"SPEECH-EnableWebsocketCompression\", \"false\") === \"true\";\n            return new WebsocketConnection(endpoint, queryParams, headers, new WebsocketMessageFormatter(), ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);\n        };\n    }\n}\nDialogConnectionFactory.Constants = (_a = class {\n    },\n    _a.ApiKey = \"api\",\n    _a.BaseUrl = \"convai.speech\",\n    _a);\n\n//# sourceMappingURL=DialogConnectorFactory.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents\";\nimport { BackgroundEvent, createGuid, createNoDashGuid, Deferred, Events, EventSource, MessageType, ServiceEvent, } from \"../common/Exports\";\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\nimport { ActivityReceivedEventArgs, CancellationErrorCode, CancellationReason, DialogServiceConfig, PropertyCollection, PropertyId, RecognitionEventArgs, ResultReason, SessionEventArgs, SpeechRecognitionCanceledEventArgs, SpeechRecognitionEventArgs, SpeechRecognitionResult, TurnStatusReceivedEventArgs, } from \"../sdk/Exports\";\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, RecognitionStatus, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechDetected, SpeechHypothesis, SpeechKeyword, } from \"./Exports\";\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\n    constructor(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {\n        super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\n        this.sendAgentConfig = (connection) => {\n            if (this.agentConfig && !this.agentConfigSent) {\n                if (this.privRecognizerConfig\n                    .parameters\n                    .getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\n                    const config = this.agentConfig.get();\n                    config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\n                    this.agentConfig.set(config);\n                }\n                this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\n                const agentConfigJson = this.agentConfig.toJsonString();\n                // guard against sending this multiple times on one connection\n                this.agentConfigSent = true;\n                return connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent.config\", this.privRequestSession.requestId, \"application/json\", agentConfigJson));\n            }\n            return;\n        };\n        this.sendAgentContext = (connection) => {\n            const guid = createGuid();\n            const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\n            const agentContext = {\n                channelData: \"\",\n                context: {\n                    interactionId: guid\n                },\n                messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\n                version: 0.5\n            };\n            const agentContextJson = JSON.stringify(agentContext);\n            return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.agent.context\", this.privRequestSession.requestId, \"application/json\", agentContextJson));\n        };\n        this.handleResponseMessage = (responseMessage) => {\n            // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\n            // event according to the message type that's specified.\n            const responsePayload = JSON.parse(responseMessage.textBody);\n            switch (responsePayload.messageType.toLowerCase()) {\n                case \"message\":\n                    const responseRequestId = responseMessage.requestId.toUpperCase();\n                    const activityPayload = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\n                    const turn = this.privTurnStateManager.GetTurn(responseRequestId);\n                    // update the conversation Id\n                    if (activityPayload.conversationId) {\n                        const updateAgentConfig = this.agentConfig.get();\n                        updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\n                        this.agentConfig.set(updateAgentConfig);\n                    }\n                    const pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\n                    const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\n                    if (!!this.privDialogServiceConnector.activityReceived) {\n                        try {\n                            this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\n                            /* tslint:disable:no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    break;\n                case \"messagestatus\":\n                    if (!!this.privDialogServiceConnector.turnStatusReceived) {\n                        try {\n                            this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new TurnStatusReceivedEventArgs(responseMessage.textBody));\n                            /* tslint:disable:no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    break;\n                default:\n                    Events.instance.onEvent(new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\n                    break;\n            }\n        };\n        this.privEvents = new EventSource();\n        this.privDialogServiceConnector = dialogServiceConnector;\n        this.receiveMessageOverride = this.receiveDialogMessageOverride;\n        this.privTurnStateManager = new DialogServiceTurnStateManager();\n        this.recognizeOverride = this.listenOnce;\n        this.postConnectImplOverride = this.dialogConnectImpl;\n        this.configConnectionOverride = this.configConnection;\n        this.disconnectOverride = this.privDisconnect;\n        this.privDialogAudioSource = audioSource;\n        this.agentConfigSent = false;\n        this.privLastResult = null;\n        this.connectionEvents.attach((connectionEvent) => __awaiter(this, void 0, void 0, function* () {\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\n                this.terminateMessageLoop = true;\n            }\n        }));\n    }\n    sendMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const interactionGuid = createGuid();\n            const requestId = createNoDashGuid();\n            const agentMessage = {\n                context: {\n                    interactionId: interactionGuid\n                },\n                messagePayload: JSON.parse(message),\n                version: 0.5\n            };\n            const agentMessageJson = JSON.stringify(agentMessage);\n            const connection = yield this.fetchConnection();\n            yield connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent\", requestId, \"application/json\", agentMessageJson));\n        });\n    }\n    privDisconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n            this.terminateMessageLoop = true;\n            this.agentConfigSent = false;\n            return;\n        });\n    }\n    processTypeSpecificMessages(connectionMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const resultProps = new PropertyCollection();\n            if (connectionMessage.messageType === MessageType.Text) {\n                resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n            }\n            let result;\n            let processed;\n            switch (connectionMessage.path.toLowerCase()) {\n                case \"speech.phrase\":\n                    const speechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n                    this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\n                    if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\n                        const args = this.fireEventForResult(speechPhrase, resultProps);\n                        this.privLastResult = args.result;\n                        if (!!this.privDialogServiceConnector.recognized) {\n                            try {\n                                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\n                                /* tslint:disable:no-empty */\n                            }\n                            catch (error) {\n                                // Not going to let errors in the event handler\n                                // trip things up.\n                            }\n                        }\n                    }\n                    processed = true;\n                    break;\n                case \"speech.hypothesis\":\n                    const hypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n                    const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n                    result = new SpeechRecognitionResult(this.privRequestSession.requestId, ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);\n                    this.privRequestSession.onHypothesis(offset);\n                    const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n                    if (!!this.privDialogServiceConnector.recognizing) {\n                        try {\n                            this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\n                            /* tslint:disable:no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    processed = true;\n                    break;\n                case \"speech.keyword\":\n                    const keyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\n                    result = new SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, undefined, undefined, undefined, undefined, connectionMessage.textBody, resultProps);\n                    if (keyword.Status !== \"Accepted\") {\n                        this.privLastResult = result;\n                    }\n                    const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\n                    if (!!this.privDialogServiceConnector.recognized) {\n                        try {\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\n                            /* tslint:disable:no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    processed = true;\n                    break;\n                case \"audio\":\n                    {\n                        const audioRequestId = connectionMessage.requestId.toUpperCase();\n                        const turn = this.privTurnStateManager.GetTurn(audioRequestId);\n                        try {\n                            // Empty binary message signals end of stream.\n                            if (!connectionMessage.binaryBody) {\n                                turn.endAudioStream();\n                            }\n                            else {\n                                turn.audioStream.write(connectionMessage.binaryBody);\n                            }\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    processed = true;\n                    break;\n                case \"response\":\n                    {\n                        this.handleResponseMessage(connectionMessage);\n                    }\n                    processed = true;\n                    break;\n                default:\n                    break;\n            }\n            return processed;\n        });\n    }\n    // Cancels recognition.\n    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.terminateMessageLoop = true;\n            if (!!this.privRequestSession.isRecognizing) {\n                yield this.privRequestSession.onStopRecognizing();\n            }\n            if (!!this.privDialogServiceConnector.canceled) {\n                const properties = new PropertyCollection();\n                properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n                const cancelEvent = new SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n                try {\n                    this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\n                    /* tslint:disable:no-empty */\n                }\n                catch (_a) { }\n                if (!!this.privSuccessCallback) {\n                    const result = new SpeechRecognitionResult(undefined, // ResultId\n                    ResultReason.Canceled, undefined, // Text\n                    undefined, // Duration\n                    undefined, // Offset\n                    undefined, // Language\n                    undefined, // Language Detection Confidence\n                    undefined, // Speaker Id\n                    error, undefined, // Json\n                    properties);\n                    try {\n                        this.privSuccessCallback(result);\n                        this.privSuccessCallback = undefined;\n                        /* tslint:disable:no-empty */\n                    }\n                    catch (_b) { }\n                }\n            }\n        });\n    }\n    listenOnce(recoMode, successCallback, errorCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.privRecognizerConfig.recognitionMode = recoMode;\n            this.privSuccessCallback = successCallback;\n            this.privErrorCallback = errorCallback;\n            this.privRequestSession.startNewRecognition();\n            this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\n            this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\n            // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n            const conPromise = this.connectImpl();\n            const preAudioPromise = this.sendPreAudioMessages();\n            const node = yield this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\n            const format = yield this.privDialogAudioSource.format;\n            const deviceInfo = yield this.privDialogAudioSource.deviceInfo;\n            const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\n            yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n            this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\n            try {\n                yield conPromise;\n                yield preAudioPromise;\n            }\n            catch (error) {\n                yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\n                return Promise.resolve();\n            }\n            const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n            if (!!this.privRecognizer.sessionStarted) {\n                this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n            }\n            const audioSendPromise = this.sendAudio(audioNode);\n            // /* tslint:disable:no-empty */\n            audioSendPromise.then(() => { }, (error) => __awaiter(this, void 0, void 0, function* () {\n                yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n            }));\n        });\n    }\n    // Establishes a websocket connection to the end point.\n    dialogConnectImpl(connection) {\n        this.privConnectionLoop = this.startMessageLoop();\n        return connection;\n    }\n    receiveDialogMessageOverride() {\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n        const communicationCustodian = new Deferred();\n        const loop = () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const isDisposed = this.isDisposed();\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\n                if (isDisposed || terminateMessageLoop) {\n                    // We're done.\n                    communicationCustodian.resolve(undefined);\n                    return;\n                }\n                const connection = yield this.fetchConnection();\n                const message = yield connection.read();\n                if (!message) {\n                    return loop();\n                }\n                const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n                switch (connectionMessage.path.toLowerCase()) {\n                    case \"turn.start\":\n                        {\n                            const turnRequestId = connectionMessage.requestId.toUpperCase();\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\n                            // turn started by the service\n                            if (turnRequestId !== audioSessionReqId) {\n                                this.privTurnStateManager.StartTurn(turnRequestId);\n                            }\n                            else {\n                                this.privRequestSession.onServiceTurnStartResponse();\n                            }\n                        }\n                        break;\n                    case \"speech.startdetected\":\n                        const speechStartDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\n                        const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n                        if (!!this.privRecognizer.speechStartDetected) {\n                            this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n                        }\n                        break;\n                    case \"speech.enddetected\":\n                        let json;\n                        if (connectionMessage.textBody.length > 0) {\n                            json = connectionMessage.textBody;\n                        }\n                        else {\n                            // If the request was empty, the JSON returned is empty.\n                            json = \"{ Offset: 0 }\";\n                        }\n                        const speechStopDetected = SpeechDetected.fromJSON(json);\n                        this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n                        const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n                        if (!!this.privRecognizer.speechEndDetected) {\n                            this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n                        }\n                        break;\n                    case \"turn.end\":\n                        {\n                            const turnEndRequestId = connectionMessage.requestId.toUpperCase();\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\n                            // turn started by the service\n                            if (turnEndRequestId !== audioSessionReqId) {\n                                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\n                            }\n                            else {\n                                // Audio session turn\n                                const sessionStopEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n                                yield this.privRequestSession.onServiceTurnEndResponse(false);\n                                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                                    if (!!this.privRecognizer.sessionStopped) {\n                                        this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                                    }\n                                }\n                                // report result to promise.\n                                if (!!this.privSuccessCallback && this.privLastResult) {\n                                    try {\n                                        this.privSuccessCallback(this.privLastResult);\n                                        this.privLastResult = null;\n                                    }\n                                    catch (e) {\n                                        if (!!this.privErrorCallback) {\n                                            this.privErrorCallback(e);\n                                        }\n                                    }\n                                    // Only invoke the call back once.\n                                    // and if it's successful don't invoke the\n                                    // error after that.\n                                    this.privSuccessCallback = undefined;\n                                    this.privErrorCallback = undefined;\n                                }\n                            }\n                        }\n                        break;\n                    default:\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\n                            if (!!this.serviceEvents) {\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                            }\n                        }\n                }\n                const ret = loop();\n                return ret;\n            }\n            catch (error) {\n                this.terminateMessageLoop = true;\n                communicationCustodian.resolve();\n            }\n        });\n        loop().catch((reason) => {\n            Events.instance.onEvent(new BackgroundEvent(reason));\n        });\n        return communicationCustodian.promise;\n    }\n    startMessageLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.terminateMessageLoop = false;\n            try {\n                yield this.receiveDialogMessageOverride();\n            }\n            catch (error) {\n                yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n            }\n            return Promise.resolve();\n        });\n    }\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\n    configConnection(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.terminateMessageLoop) {\n                this.terminateMessageLoop = false;\n                return Promise.reject(`Connection to service terminated.`);\n            }\n            yield this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\n            yield this.sendAgentConfig(connection);\n            return connection;\n        });\n    }\n    sendPreAudioMessages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.fetchConnection();\n            this.addKeywordContextData();\n            yield this.sendSpeechContext(connection);\n            yield this.sendAgentContext(connection);\n            yield this.sendWaveHeader(connection);\n        });\n    }\n    fireEventForResult(serviceResult, properties) {\n        const resultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\n        const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n        const result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, undefined, JSON.stringify(serviceResult), properties);\n        const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n        return ev;\n    }\n    onEvent(event) {\n        this.privEvents.onEvent(event);\n        Events.instance.onEvent(event);\n    }\n    addKeywordContextData() {\n        const keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\n        if (keywordPropertyValue === undefined) {\n            return;\n        }\n        const keywordOffsetPropertyValue = this.privRecognizerConfig.parameters\n            .getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\n        const keywordDurationPropertyValue = this.privRecognizerConfig.parameters\n            .getProperty(\"SPEECH-KeywordsToDetect-Durations\");\n        const keywords = keywordPropertyValue.split(\";\");\n        const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\n        const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\n        const keywordDefinitionArray = [];\n        for (let i = 0; i < keywords.length; i++) {\n            const definition = {};\n            definition.text = keywords[i];\n            if (i < keywordOffsets.length) {\n                definition.offset = Number(keywordOffsets[i]);\n            }\n            if (i < keywordDurations.length) {\n                definition.duration = Number(keywordDurations[i]);\n            }\n            keywordDefinitionArray.push(definition);\n        }\n        this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\n        this.speechContext.setSection(\"keywordDetection\", [{\n                clientDetectedKeywords: keywordDefinitionArray,\n                onReject: { action: \"EndOfTurn\" },\n                type: \"startTrigger\"\n            }]);\n    }\n}\n\n//# sourceMappingURL=DialogServiceAdapter.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\nimport { AudioOutputStream } from \"../sdk/Audio/AudioOutputStream\";\nimport { MessageDataStreamType } from \"./ServiceMessages/ActivityResponsePayload\";\nexport class DialogServiceTurnState {\n    constructor(manager, requestId) {\n        this.privRequestId = requestId;\n        this.privIsCompleted = false;\n        this.privAudioStream = null;\n        this.privTurnManager = manager;\n        this.resetTurnEndTimeout();\n        // tslint:disable-next-line:no-console\n        // console.info(\"DialogServiceTurnState debugturn start:\" + this.privRequestId);\n    }\n    get audioStream() {\n        // Called when is needed to stream.\n        this.resetTurnEndTimeout();\n        return this.privAudioStream;\n    }\n    processActivityPayload(payload, audioFormat) {\n        if (payload.messageDataStreamType === MessageDataStreamType.TextToSpeechAudio) {\n            this.privAudioStream = AudioOutputStream.createPullStream();\n            this.privAudioStream.format = (audioFormat !== undefined) ? audioFormat : AudioOutputFormatImpl.getDefaultOutputFormat();\n            // tslint:disable-next-line:no-console\n            // console.info(\"Audio start debugturn:\" + this.privRequestId);\n        }\n        return this.privAudioStream;\n    }\n    endAudioStream() {\n        if (this.privAudioStream !== null && !this.privAudioStream.isClosed) {\n            this.privAudioStream.close();\n        }\n    }\n    complete() {\n        if (this.privTimeoutToken !== undefined) {\n            clearTimeout(this.privTimeoutToken);\n        }\n        this.endAudioStream();\n    }\n    resetTurnEndTimeout() {\n        if (this.privTimeoutToken !== undefined) {\n            clearTimeout(this.privTimeoutToken);\n        }\n        // tslint:disable-next-line:no-console\n        // console.info(\"Timeout reset debugturn:\" + this.privRequestId);\n        this.privTimeoutToken = setTimeout(() => {\n            // tslint:disable-next-line:no-console\n            // console.info(\"Timeout complete debugturn:\" + this.privRequestId);\n            this.privTurnManager.CompleteTurn(this.privRequestId);\n            return;\n        }, 2000);\n    }\n}\n\n//# sourceMappingURL=DialogServiceTurnState.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { InvalidOperationError } from \"../common/Error\";\nimport { DialogServiceTurnState } from \"./DialogServiceTurnState\";\nexport class DialogServiceTurnStateManager {\n    constructor() {\n        this.privTurnMap = new Map();\n        return;\n    }\n    StartTurn(id) {\n        if (this.privTurnMap.has(id)) {\n            throw new InvalidOperationError(\"Service error: There is already a turn with id:\" + id);\n        }\n        const turnState = new DialogServiceTurnState(this, id);\n        this.privTurnMap.set(id, turnState);\n        return this.privTurnMap.get(id);\n    }\n    GetTurn(id) {\n        return this.privTurnMap.get(id);\n    }\n    CompleteTurn(id) {\n        if (!this.privTurnMap.has(id)) {\n            throw new InvalidOperationError(\"Service error: Received turn end for an unknown turn id:\" + id);\n        }\n        const turnState = this.privTurnMap.get(id);\n        turnState.complete();\n        this.privTurnMap.delete(id);\n        return turnState;\n    }\n}\n\n//# sourceMappingURL=DialogServiceTurnStateManager.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Responsible for building the object to be sent to the speech service to support dynamic grammars.\n * @class DynamicGrammarBuilder\n */\nexport class DynamicGrammarBuilder {\n    // Adds one more reference phrases to the dynamic grammar to send.\n    // All added phrases are generic phrases.\n    addPhrase(phrase) {\n        if (!this.privPhrases) {\n            this.privPhrases = [];\n        }\n        if (phrase instanceof Array) {\n            this.privPhrases = this.privPhrases.concat(phrase);\n        }\n        else {\n            this.privPhrases.push(phrase);\n        }\n    }\n    // Clears all phrases stored in the current object.\n    clearPhrases() {\n        this.privPhrases = undefined;\n    }\n    // Adds one or more reference grammars to the current grammar.\n    addReferenceGrammar(grammar) {\n        if (!this.privGrammars) {\n            this.privGrammars = [];\n        }\n        if (grammar instanceof Array) {\n            this.privGrammars = this.privGrammars.concat(grammar);\n        }\n        else {\n            this.privGrammars.push(grammar);\n        }\n    }\n    // clears all grammars stored on the recognizer.\n    clearGrammars() {\n        this.privGrammars = undefined;\n    }\n    // Generates an object that represents the dynamic grammar used by the Speech Service.\n    // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance\n    // of a DynamicGrammarBuilder\n    generateGrammarObject() {\n        if (this.privGrammars === undefined && this.privPhrases === undefined) {\n            return undefined;\n        }\n        const retObj = {};\n        retObj.ReferenceGrammars = this.privGrammars;\n        if (undefined !== this.privPhrases && 0 !== this.privPhrases.length) {\n            const retPhrases = [];\n            this.privPhrases.forEach((value, index, array) => {\n                retPhrases.push({\n                    Text: value,\n                });\n            });\n            retObj.Groups = [{ Type: \"Generic\", Items: retPhrases }];\n        }\n        return retObj;\n    }\n}\n\n//# sourceMappingURL=DynamicGrammarBuilder.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=DynamicGrammarInterfaces.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { CancellationErrorCode, CancellationReason, ResultReason } from \"../sdk/Exports\";\nimport { RecognitionStatus } from \"./Exports\";\nexport class EnumTranslation {\n    static implTranslateRecognitionResult(recognitionStatus) {\n        let reason = ResultReason.Canceled;\n        switch (recognitionStatus) {\n            case RecognitionStatus.Success:\n                reason = ResultReason.RecognizedSpeech;\n                break;\n            case RecognitionStatus.NoMatch:\n            case RecognitionStatus.InitialSilenceTimeout:\n            case RecognitionStatus.BabbleTimeout:\n            case RecognitionStatus.EndOfDictation:\n                reason = ResultReason.NoMatch;\n                break;\n            case RecognitionStatus.Error:\n            default:\n                reason = ResultReason.Canceled;\n                break;\n        }\n        return reason;\n    }\n    static implTranslateCancelResult(recognitionStatus) {\n        let reason = CancellationReason.EndOfStream;\n        switch (recognitionStatus) {\n            case RecognitionStatus.Success:\n            case RecognitionStatus.EndOfDictation:\n            case RecognitionStatus.NoMatch:\n                reason = CancellationReason.EndOfStream;\n                break;\n            case RecognitionStatus.InitialSilenceTimeout:\n            case RecognitionStatus.BabbleTimeout:\n            case RecognitionStatus.Error:\n            default:\n                reason = CancellationReason.Error;\n                break;\n        }\n        return reason;\n    }\n    static implTranslateCancelErrorCode(recognitionStatus) {\n        let reason = CancellationErrorCode.NoError;\n        switch (recognitionStatus) {\n            case RecognitionStatus.Error:\n                reason = CancellationErrorCode.ServiceError;\n                break;\n            case RecognitionStatus.TooManyRequests:\n                reason = CancellationErrorCode.TooManyRequests;\n                break;\n            default:\n                reason = CancellationErrorCode.NoError;\n                break;\n        }\n        return reason;\n    }\n}\n\n//# sourceMappingURL=EnumTranslation.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Make sure not to export internal modules.\n//\nexport * from \"./CognitiveSubscriptionKeyAuthentication\";\nexport * from \"./CognitiveTokenAuthentication\";\nexport * from \"./IAuthentication\";\nexport * from \"./IConnectionFactory\";\nexport * from \"./ISynthesisConnectionFactory\";\nexport * from \"./IntentConnectionFactory\";\nexport * from \"./RecognitionEvents\";\nexport * from \"./ServiceRecognizerBase\";\nexport * from \"./RecognizerConfig\";\nexport * from \"./SpeechServiceInterfaces\";\nexport * from \"./WebsocketMessageFormatter\";\nexport * from \"./SpeechConnectionFactory\";\nexport * from \"./TranscriberConnectionFactory\";\nexport * from \"./TranslationConnectionFactory\";\nexport * from \"./SpeechSynthesisConnectionFactory\";\nexport * from \"./EnumTranslation\";\nexport * from \"./ServiceMessages/Enums\";\nexport * from \"./ServiceMessages/TranslationSynthesisEnd\";\nexport * from \"./ServiceMessages/TranslationHypothesis\";\nexport * from \"./ServiceMessages/TranslationPhrase\";\nexport * from \"./TranslationServiceRecognizer\";\nexport * from \"./ServiceMessages/SpeechDetected\";\nexport * from \"./ServiceMessages/SpeechHypothesis\";\nexport * from \"./ServiceMessages/SpeechKeyword\";\nexport * from \"./SpeechServiceRecognizer\";\nexport * from \"./TranscriptionServiceRecognizer\";\nexport * from \"./ServiceMessages/DetailedSpeechPhrase\";\nexport * from \"./ServiceMessages/SimpleSpeechPhrase\";\nexport * from \"./AddedLmIntent\";\nexport * from \"./IntentServiceRecognizer\";\nexport * from \"./ServiceMessages/IntentResponse\";\nexport * from \"./RequestSession\";\nexport * from \"./SpeechContext\";\nexport * from \"./DynamicGrammarBuilder\";\nexport * from \"./DynamicGrammarInterfaces\";\nexport * from \"./DialogServiceAdapter\";\nexport * from \"./AgentConfig\";\nexport * from \"./Transcription/Exports\";\nexport * from \"./ServiceMessages/SynthesisAudioMetadata\";\nexport * from \"./SynthesisTurn\";\nexport * from \"./SynthesisAdapterBase\";\nexport * from \"./SynthesizerConfig\";\nexport * from \"./SynthesisContext\";\nexport * from \"./SpeakerRecognitionConfig\";\nexport * from \"./SpeakerIdMessageAdapter\";\nexport const OutputFormatPropertyName = \"OutputFormat\";\nexport const CancellationErrorCodePropertyName = \"CancellationErrorCode\";\nexport const ServicePropertiesPropertyName = \"ServiceProperties\";\nexport const ForceDictationPropertyName = \"ForceDictation\";\nexport const AutoDetectSourceLanguagesOpenRangeOptionName = \"OpenRange\";\n\n//# sourceMappingURL=Exports.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class HeaderNames {\n}\nHeaderNames.AuthKey = \"Ocp-Apim-Subscription-Key\";\nHeaderNames.ConnectionId = \"X-ConnectionId\";\nHeaderNames.ContentType = \"Content-Type\";\nHeaderNames.CustomCommandsAppId = \"X-CommandsAppId\";\nHeaderNames.Path = \"Path\";\nHeaderNames.RequestId = \"X-RequestId\";\nHeaderNames.RequestStreamId = \"X-StreamId\";\nHeaderNames.RequestTimestamp = \"X-Timestamp\";\n\n//# sourceMappingURL=HeaderNames.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class AuthInfo {\n    constructor(headerName, token) {\n        this.privHeaderName = headerName;\n        this.privToken = token;\n    }\n    get headerName() {\n        return this.privHeaderName;\n    }\n    get token() {\n        return this.privToken;\n    }\n}\n\n//# sourceMappingURL=IAuthentication.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=IConnectionFactory.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=ISynthesisConnectionFactory.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ProxyInfo, WebsocketConnection, } from \"../common.browser/Exports\";\nimport { PropertyId } from \"../sdk/Exports\";\nimport { ConnectionFactoryBase } from \"./ConnectionFactoryBase\";\nimport { WebsocketMessageFormatter, } from \"./Exports\";\nimport { HeaderNames } from \"./HeaderNames\";\nexport class IntentConnectionFactory extends ConnectionFactoryBase {\n    constructor() {\n        super(...arguments);\n        this.create = (config, authInfo, connectionId) => {\n            let endpoint = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint);\n            if (!endpoint) {\n                const region = config.parameters.getProperty(PropertyId.SpeechServiceConnection_IntentRegion);\n                const hostSuffix = (region && region.toLowerCase().startsWith(\"china\")) ? \".azure.cn\" : \".microsoft.com\";\n                const host = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Host, \"wss://\" + region + \".sr.speech\" + hostSuffix);\n                endpoint = host + \"/speech/recognition/interactive/cognitiveservices/v1\";\n            }\n            const queryParams = {\n                format: \"simple\",\n                language: config.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage),\n            };\n            this.setCommonUrlParams(config, queryParams, endpoint);\n            const headers = {};\n            if (authInfo.token !== undefined && authInfo.token !== \"\") {\n                headers[authInfo.headerName] = authInfo.token;\n            }\n            headers[HeaderNames.ConnectionId] = connectionId;\n            config.parameters.setProperty(PropertyId.SpeechServiceConnection_Url, endpoint);\n            const enableCompression = config.parameters.getProperty(\"SPEECH-EnableWebsocketCompression\", \"false\") === \"true\";\n            return new WebsocketConnection(endpoint, queryParams, headers, new WebsocketMessageFormatter(), ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);\n        };\n    }\n    getSpeechRegionFromIntentRegion(intentRegion) {\n        switch (intentRegion) {\n            case \"West US\":\n            case \"US West\":\n            case \"westus\":\n                return \"uswest\";\n            case \"West US 2\":\n            case \"US West 2\":\n            case \"westus2\":\n                return \"uswest2\";\n            case \"South Central US\":\n            case \"US South Central\":\n            case \"southcentralus\":\n                return \"ussouthcentral\";\n            case \"West Central US\":\n            case \"US West Central\":\n            case \"westcentralus\":\n                return \"uswestcentral\";\n            case \"East US\":\n            case \"US East\":\n            case \"eastus\":\n                return \"useast\";\n            case \"East US 2\":\n            case \"US East 2\":\n            case \"eastus2\":\n                return \"useast2\";\n            case \"West Europe\":\n            case \"Europe West\":\n            case \"westeurope\":\n                return \"europewest\";\n            case \"North Europe\":\n            case \"Europe North\":\n            case \"northeurope\":\n                return \"europenorth\";\n            case \"Brazil South\":\n            case \"South Brazil\":\n            case \"southbrazil\":\n                return \"brazilsouth\";\n            case \"Australia East\":\n            case \"East Australia\":\n            case \"eastaustralia\":\n                return \"australiaeast\";\n            case \"Southeast Asia\":\n            case \"Asia Southeast\":\n            case \"southeastasia\":\n                return \"asiasoutheast\";\n            case \"East Asia\":\n            case \"Asia East\":\n            case \"eastasia\":\n                return \"asiaeast\";\n            default:\n                return intentRegion;\n        }\n    }\n}\n\n//# sourceMappingURL=IntentConnectionFactory.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { MessageType, } from \"../common/Exports\";\nimport { CancellationErrorCode, IntentRecognitionCanceledEventArgs, IntentRecognitionEventArgs, IntentRecognitionResult, PropertyCollection, PropertyId, ResultReason, } from \"../sdk/Exports\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, IntentResponse, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechHypothesis, } from \"./Exports\";\n// tslint:disable-next-line:max-classes-per-file\nexport class IntentServiceRecognizer extends ServiceRecognizerBase {\n    constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n        super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\n        this.privIntentRecognizer = recognizer;\n        this.privIntentDataSent = false;\n    }\n    setIntents(addedIntents, umbrellaIntent) {\n        this.privAddedLmIntents = addedIntents;\n        this.privUmbrellaIntent = umbrellaIntent;\n        this.privIntentDataSent = true;\n    }\n    processTypeSpecificMessages(connectionMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result;\n            let ev;\n            let processed = false;\n            const resultProps = new PropertyCollection();\n            if (connectionMessage.messageType === MessageType.Text) {\n                resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n            }\n            switch (connectionMessage.path.toLowerCase()) {\n                case \"speech.hypothesis\":\n                    const speechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n                    result = new IntentRecognitionResult(undefined, this.privRequestSession.requestId, ResultReason.RecognizingIntent, speechHypothesis.Text, speechHypothesis.Duration, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, speechHypothesis.Language, speechHypothesis.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);\n                    this.privRequestSession.onHypothesis(result.offset);\n                    ev = new IntentRecognitionEventArgs(result, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n                    if (!!this.privIntentRecognizer.recognizing) {\n                        try {\n                            this.privIntentRecognizer.recognizing(this.privIntentRecognizer, ev);\n                            /* tslint:disable:no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    processed = true;\n                    break;\n                case \"speech.phrase\":\n                    const simple = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n                    result = new IntentRecognitionResult(undefined, this.privRequestSession.requestId, EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus), simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);\n                    ev = new IntentRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n                    const sendEvent = () => {\n                        if (!!this.privIntentRecognizer.recognized) {\n                            try {\n                                this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\n                                /* tslint:disable:no-empty */\n                            }\n                            catch (error) {\n                                // Not going to let errors in the event handler\n                                // trip things up.\n                            }\n                        }\n                        // report result to promise.\n                        if (!!this.privSuccessCallback) {\n                            try {\n                                this.privSuccessCallback(result);\n                            }\n                            catch (e) {\n                                if (!!this.privErrorCallback) {\n                                    this.privErrorCallback(e);\n                                }\n                            }\n                            // Only invoke the call back once.\n                            // and if it's successful don't invoke the\n                            // error after that.\n                            this.privSuccessCallback = undefined;\n                            this.privErrorCallback = undefined;\n                        }\n                    };\n                    // If intent data was sent, the terminal result for this recognizer is an intent being found.\n                    // If no intent data was sent, the terminal event is speech recognition being successful.\n                    if (false === this.privIntentDataSent || ResultReason.NoMatch === ev.result.reason) {\n                        // Advance the buffers.\n                        this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\n                        sendEvent();\n                    }\n                    else {\n                        // Squirrel away the args, when the response event arrives it will build upon them\n                        // and then return\n                        this.privPendingIntentArgs = ev;\n                    }\n                    processed = true;\n                    break;\n                case \"response\":\n                    // Response from LUIS\n                    ev = this.privPendingIntentArgs;\n                    this.privPendingIntentArgs = undefined;\n                    if (undefined === ev) {\n                        if (\"\" === connectionMessage.textBody) {\n                            // This condition happens if there is nothing but silence in the\n                            // audio sent to the service.\n                            return;\n                        }\n                        // Odd... Not sure this can happen\n                        ev = new IntentRecognitionEventArgs(new IntentRecognitionResult(), 0 /*TODO*/, this.privRequestSession.sessionId);\n                    }\n                    const intentResponse = IntentResponse.fromJSON(connectionMessage.textBody);\n                    // If LUIS didn't return anything, send the existing event, else\n                    // modify it to show the match.\n                    // See if the intent found is in the list of intents asked for.\n                    let addedIntent = this.privAddedLmIntents[intentResponse.topScoringIntent.intent];\n                    if (this.privUmbrellaIntent !== undefined) {\n                        addedIntent = this.privUmbrellaIntent;\n                    }\n                    if (null !== intentResponse && addedIntent !== undefined) {\n                        const intentId = addedIntent.intentName === undefined ? intentResponse.topScoringIntent.intent : addedIntent.intentName;\n                        let reason = ev.result.reason;\n                        if (undefined !== intentId) {\n                            reason = ResultReason.RecognizedIntent;\n                        }\n                        // make sure, properties is set.\n                        const properties = (undefined !== ev.result.properties) ?\n                            ev.result.properties : new PropertyCollection();\n                        properties.setProperty(PropertyId.LanguageUnderstandingServiceResponse_JsonResult, connectionMessage.textBody);\n                        ev = new IntentRecognitionEventArgs(new IntentRecognitionResult(intentId, ev.result.resultId, reason, ev.result.text, ev.result.duration, ev.result.offset, undefined, undefined, ev.result.errorDetails, ev.result.json, properties), ev.offset, ev.sessionId);\n                    }\n                    this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\n                    if (!!this.privIntentRecognizer.recognized) {\n                        try {\n                            this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\n                            /* tslint:disable:no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    // report result to promise.\n                    if (!!this.privSuccessCallback) {\n                        try {\n                            this.privSuccessCallback(ev.result);\n                        }\n                        catch (e) {\n                            if (!!this.privErrorCallback) {\n                                this.privErrorCallback(e);\n                            }\n                        }\n                        // Only invoke the call back once.\n                        // and if it's successful don't invoke the\n                        // error after that.\n                        this.privSuccessCallback = undefined;\n                        this.privErrorCallback = undefined;\n                    }\n                    processed = true;\n                    break;\n                default:\n                    break;\n            }\n            return processed;\n        });\n    }\n    // Cancels recognition.\n    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n        const properties = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        if (!!this.privIntentRecognizer.canceled) {\n            const cancelEvent = new IntentRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, undefined, sessionId);\n            try {\n                this.privIntentRecognizer.canceled(this.privIntentRecognizer, cancelEvent);\n                /* tslint:disable:no-empty */\n            }\n            catch (_a) { }\n        }\n        if (!!this.privSuccessCallback) {\n            const result = new IntentRecognitionResult(undefined, // Intent Id\n            requestId, ResultReason.Canceled, undefined, // Text\n            undefined, // Duration\n            undefined, // Offset\n            undefined, // Language\n            undefined, // LanguageDetectionConfidence\n            error, undefined, // Json\n            properties);\n            try {\n                this.privSuccessCallback(result);\n                this.privSuccessCallback = undefined;\n                /* tslint:disable:no-empty */\n            }\n            catch (_b) { }\n        }\n    }\n}\n\n//# sourceMappingURL=IntentServiceRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class QueryParameterNames {\n}\nQueryParameterNames.BotId = \"botid\";\nQueryParameterNames.CustomSpeechDeploymentId = \"cid\";\nQueryParameterNames.CustomVoiceDeploymentId = \"deploymentId\";\nQueryParameterNames.EnableAudioLogging = \"storeAudio\";\nQueryParameterNames.EnableLanguageId = \"lidEnabled\";\nQueryParameterNames.EnableWordLevelTimestamps = \"wordLevelTimestamps\";\nQueryParameterNames.EndSilenceTimeoutMs = \"endSilenceTimeoutMs\";\nQueryParameterNames.Format = \"format\";\nQueryParameterNames.InitialSilenceTimeoutMs = \"initialSilenceTimeoutMs\";\nQueryParameterNames.Language = \"language\";\nQueryParameterNames.Profanity = \"profanity\";\nQueryParameterNames.RequestBotStatusMessages = \"enableBotMessageStatus\";\nQueryParameterNames.StableIntermediateThreshold = \"stableIntermediateThreshold\";\nQueryParameterNames.StableTranslation = \"stableTranslation\";\nQueryParameterNames.TestHooks = \"testhooks\";\n\n//# sourceMappingURL=QueryParameterNames.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// tslint:disable:max-classes-per-file\nimport { EventType, PlatformEvent } from \"../common/Exports\";\nexport class SpeechRecognitionEvent extends PlatformEvent {\n    constructor(eventName, requestId, sessionId, eventType = EventType.Info) {\n        super(eventName, eventType);\n        this.privRequestId = requestId;\n        this.privSessionId = sessionId;\n    }\n    get requestId() {\n        return this.privRequestId;\n    }\n    get sessionId() {\n        return this.privSessionId;\n    }\n}\nexport class RecognitionTriggeredEvent extends SpeechRecognitionEvent {\n    constructor(requestId, sessionId, audioSourceId, audioNodeId) {\n        super(\"RecognitionTriggeredEvent\", requestId, sessionId);\n        this.privAudioSourceId = audioSourceId;\n        this.privAudioNodeId = audioNodeId;\n    }\n    get audioSourceId() {\n        return this.privAudioSourceId;\n    }\n    get audioNodeId() {\n        return this.privAudioNodeId;\n    }\n}\nexport class ListeningStartedEvent extends SpeechRecognitionEvent {\n    constructor(requestId, sessionId, audioSourceId, audioNodeId) {\n        super(\"ListeningStartedEvent\", requestId, sessionId);\n        this.privAudioSourceId = audioSourceId;\n        this.privAudioNodeId = audioNodeId;\n    }\n    get audioSourceId() {\n        return this.privAudioSourceId;\n    }\n    get audioNodeId() {\n        return this.privAudioNodeId;\n    }\n}\nexport class ConnectingToServiceEvent extends SpeechRecognitionEvent {\n    constructor(requestId, authFetchEventid, sessionId) {\n        super(\"ConnectingToServiceEvent\", requestId, sessionId);\n        this.privAuthFetchEventid = authFetchEventid;\n    }\n    get authFetchEventid() {\n        return this.privAuthFetchEventid;\n    }\n}\nexport class RecognitionStartedEvent extends SpeechRecognitionEvent {\n    constructor(requestId, audioSourceId, audioNodeId, authFetchEventId, sessionId) {\n        super(\"RecognitionStartedEvent\", requestId, sessionId);\n        this.privAudioSourceId = audioSourceId;\n        this.privAudioNodeId = audioNodeId;\n        this.privAuthFetchEventId = authFetchEventId;\n    }\n    get audioSourceId() {\n        return this.privAudioSourceId;\n    }\n    get audioNodeId() {\n        return this.privAudioNodeId;\n    }\n    get authFetchEventId() {\n        return this.privAuthFetchEventId;\n    }\n}\nexport var RecognitionCompletionStatus;\n(function (RecognitionCompletionStatus) {\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"Success\"] = 0] = \"Success\";\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"AudioSourceError\"] = 1] = \"AudioSourceError\";\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"AudioSourceTimeout\"] = 2] = \"AudioSourceTimeout\";\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"AuthTokenFetchError\"] = 3] = \"AuthTokenFetchError\";\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"AuthTokenFetchTimeout\"] = 4] = \"AuthTokenFetchTimeout\";\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"UnAuthorized\"] = 5] = \"UnAuthorized\";\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"ConnectTimeout\"] = 6] = \"ConnectTimeout\";\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"ConnectError\"] = 7] = \"ConnectError\";\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"ClientRecognitionActivityTimeout\"] = 8] = \"ClientRecognitionActivityTimeout\";\n    RecognitionCompletionStatus[RecognitionCompletionStatus[\"UnknownError\"] = 9] = \"UnknownError\";\n})(RecognitionCompletionStatus || (RecognitionCompletionStatus = {}));\nexport class RecognitionEndedEvent extends SpeechRecognitionEvent {\n    constructor(requestId, audioSourceId, audioNodeId, authFetchEventId, sessionId, serviceTag, status, error) {\n        super(\"RecognitionEndedEvent\", requestId, sessionId, status === RecognitionCompletionStatus.Success ? EventType.Info : EventType.Error);\n        this.privAudioSourceId = audioSourceId;\n        this.privAudioNodeId = audioNodeId;\n        this.privAuthFetchEventId = authFetchEventId;\n        this.privStatus = status;\n        this.privError = error;\n        this.privServiceTag = serviceTag;\n    }\n    get audioSourceId() {\n        return this.privAudioSourceId;\n    }\n    get audioNodeId() {\n        return this.privAudioNodeId;\n    }\n    get authFetchEventId() {\n        return this.privAuthFetchEventId;\n    }\n    get serviceTag() {\n        return this.privServiceTag;\n    }\n    get status() {\n        return this.privStatus;\n    }\n    get error() {\n        return this.privError;\n    }\n}\n\n//# sourceMappingURL=RecognitionEvents.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// tslint:disable:max-classes-per-file\nimport { PropertyId } from \"../sdk/Exports\";\nexport var RecognitionMode;\n(function (RecognitionMode) {\n    RecognitionMode[RecognitionMode[\"Interactive\"] = 0] = \"Interactive\";\n    RecognitionMode[RecognitionMode[\"Conversation\"] = 1] = \"Conversation\";\n    RecognitionMode[RecognitionMode[\"Dictation\"] = 2] = \"Dictation\";\n})(RecognitionMode || (RecognitionMode = {}));\nexport var SpeechResultFormat;\n(function (SpeechResultFormat) {\n    SpeechResultFormat[SpeechResultFormat[\"Simple\"] = 0] = \"Simple\";\n    SpeechResultFormat[SpeechResultFormat[\"Detailed\"] = 1] = \"Detailed\";\n})(SpeechResultFormat || (SpeechResultFormat = {}));\nexport class RecognizerConfig {\n    constructor(speechServiceConfig, parameters) {\n        this.privRecognitionMode = RecognitionMode.Interactive;\n        this.privSpeechServiceConfig = speechServiceConfig ? speechServiceConfig : new SpeechServiceConfig(new Context(null));\n        this.privParameters = parameters;\n        this.privMaxRetryCount = parseInt(parameters.getProperty(\"SPEECH-Error-MaxRetryCount\", \"4\"), 10);\n    }\n    get parameters() {\n        return this.privParameters;\n    }\n    get recognitionMode() {\n        return this.privRecognitionMode;\n    }\n    set recognitionMode(value) {\n        this.privRecognitionMode = value;\n        this.privRecognitionActivityTimeout = value === RecognitionMode.Interactive ? 8000 : 25000;\n        this.privSpeechServiceConfig.Recognition = RecognitionMode[value];\n    }\n    get SpeechServiceConfig() {\n        return this.privSpeechServiceConfig;\n    }\n    get recognitionActivityTimeout() {\n        return this.privRecognitionActivityTimeout;\n    }\n    get isContinuousRecognition() {\n        return this.privRecognitionMode !== RecognitionMode.Interactive;\n    }\n    get autoDetectSourceLanguages() {\n        return this.parameters.getProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, undefined);\n    }\n    get maxRetryCount() {\n        return this.privMaxRetryCount;\n    }\n}\n// The config is serialized and sent as the Speech.Config\nexport class SpeechServiceConfig {\n    constructor(context) {\n        this.serialize = () => {\n            return JSON.stringify(this, (key, value) => {\n                if (value && typeof value === \"object\") {\n                    const replacement = {};\n                    for (const k in value) {\n                        if (Object.hasOwnProperty.call(value, k)) {\n                            replacement[k && k.charAt(0).toLowerCase() + k.substring(1)] = value[k];\n                        }\n                    }\n                    return replacement;\n                }\n                return value;\n            });\n        };\n        this.context = context;\n    }\n    get Context() {\n        return this.context;\n    }\n    get Recognition() {\n        return this.recognition;\n    }\n    set Recognition(value) {\n        this.recognition = value.toLowerCase();\n    }\n}\nexport class Context {\n    constructor(os) {\n        this.system = new System();\n        this.os = os;\n    }\n}\nexport class System {\n    constructor() {\n        // Note: below will be patched for official builds.\n        const SPEECHSDK_CLIENTSDK_VERSION = \"1.18.1\";\n        this.name = \"SpeechSDK\";\n        this.version = SPEECHSDK_CLIENTSDK_VERSION;\n        this.build = \"JavaScript\";\n        this.lang = \"JavaScript\";\n    }\n}\nexport class OS {\n    constructor(platform, name, version) {\n        this.platform = platform;\n        this.name = name;\n        this.version = version;\n    }\n}\nexport class Device {\n    constructor(manufacturer, model, version) {\n        this.manufacturer = manufacturer;\n        this.model = model;\n        this.version = version;\n    }\n}\nexport var connectivity;\n(function (connectivity) {\n    connectivity[\"Bluetooth\"] = \"Bluetooth\";\n    connectivity[\"Wired\"] = \"Wired\";\n    connectivity[\"WiFi\"] = \"WiFi\";\n    connectivity[\"Cellular\"] = \"Cellular\";\n    connectivity[\"InBuilt\"] = \"InBuilt\";\n    connectivity[\"Unknown\"] = \"Unknown\";\n})(connectivity || (connectivity = {}));\nexport var type;\n(function (type) {\n    type[\"Phone\"] = \"Phone\";\n    type[\"Speaker\"] = \"Speaker\";\n    type[\"Car\"] = \"Car\";\n    type[\"Headset\"] = \"Headset\";\n    type[\"Thermostat\"] = \"Thermostat\";\n    type[\"Microphones\"] = \"Microphones\";\n    type[\"Deskphone\"] = \"Deskphone\";\n    type[\"RemoteControl\"] = \"RemoteControl\";\n    type[\"Unknown\"] = \"Unknown\";\n    type[\"File\"] = \"File\";\n    type[\"Stream\"] = \"Stream\";\n})(type || (type = {}));\n\n//# sourceMappingURL=RecognizerConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { createNoDashGuid, Deferred, Events } from \"../common/Exports\";\nimport { ConnectingToServiceEvent, ListeningStartedEvent, RecognitionStartedEvent, RecognitionTriggeredEvent, } from \"./RecognitionEvents\";\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\nexport class RequestSession {\n    constructor(audioSourceId) {\n        this.privIsDisposed = false;\n        this.privDetachables = new Array();\n        this.privIsAudioNodeDetached = false;\n        this.privIsRecognizing = false;\n        this.privIsSpeechEnded = false;\n        this.privTurnStartAudioOffset = 0;\n        this.privLastRecoOffset = 0;\n        this.privHypothesisReceived = false;\n        this.privBytesSent = 0;\n        this.privRecogNumber = 0;\n        this.privInTurn = false;\n        this.privConnectionAttempts = 0;\n        this.onPreConnectionStart = (authFetchEventId, connectionId) => {\n            this.privAuthFetchEventId = authFetchEventId;\n            this.privSessionId = connectionId;\n            this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\n        };\n        this.onServiceTurnStartResponse = () => {\n            if (!!this.privTurnDeferral && !!this.privInTurn) {\n                // What? How are we starting a turn with another not done?\n                this.privTurnDeferral.reject(\"Another turn started before current completed.\");\n                // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n                /* tslint:disable:no-empty */\n                this.privTurnDeferral.promise.then().catch(() => { });\n            }\n            this.privInTurn = true;\n            this.privTurnDeferral = new Deferred();\n        };\n        this.getTelemetry = () => {\n            if (this.privServiceTelemetryListener.hasTelemetry) {\n                return this.privServiceTelemetryListener.getTelemetry();\n            }\n            else {\n                return null;\n            }\n        };\n        this.onEvent = (event) => {\n            if (!!this.privServiceTelemetryListener) {\n                this.privServiceTelemetryListener.onEvent(event);\n            }\n            Events.instance.onEvent(event);\n        };\n        this.privAudioSourceId = audioSourceId;\n        this.privRequestId = createNoDashGuid();\n        this.privAudioNodeId = createNoDashGuid();\n        this.privTurnDeferral = new Deferred();\n        // We're not in a turn, so resolve.\n        this.privTurnDeferral.resolve();\n    }\n    get sessionId() {\n        return this.privSessionId;\n    }\n    get requestId() {\n        return this.privRequestId;\n    }\n    get audioNodeId() {\n        return this.privAudioNodeId;\n    }\n    get turnCompletionPromise() {\n        return this.privTurnDeferral.promise;\n    }\n    get isSpeechEnded() {\n        return this.privIsSpeechEnded;\n    }\n    get isRecognizing() {\n        return this.privIsRecognizing;\n    }\n    get currentTurnAudioOffset() {\n        return this.privTurnStartAudioOffset;\n    }\n    get recogNumber() {\n        return this.privRecogNumber;\n    }\n    get numConnectionAttempts() {\n        return this.privConnectionAttempts;\n    }\n    // The number of bytes sent for the current connection.\n    // Counter is reset to 0 each time a connection is established.\n    get bytesSent() {\n        return this.privBytesSent;\n    }\n    listenForServiceTelemetry(eventSource) {\n        if (!!this.privServiceTelemetryListener) {\n            this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\n        }\n    }\n    startNewRecognition() {\n        this.privIsSpeechEnded = false;\n        this.privIsRecognizing = true;\n        this.privTurnStartAudioOffset = 0;\n        this.privLastRecoOffset = 0;\n        this.privRequestId = createNoDashGuid();\n        this.privRecogNumber++;\n        this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\n        this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n    }\n    onAudioSourceAttachCompleted(audioNode, isError, error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.privAudioNode = audioNode;\n            this.privIsAudioNodeDetached = false;\n            if (isError) {\n                yield this.onComplete();\n            }\n            else {\n                this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n            }\n        });\n    }\n    onAuthCompleted(isError, error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (isError) {\n                yield this.onComplete();\n            }\n        });\n    }\n    onConnectionEstablishCompleted(statusCode, reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (statusCode === 200) {\n                this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\n                if (!!this.privAudioNode) {\n                    this.privAudioNode.replay();\n                }\n                this.privTurnStartAudioOffset = this.privLastRecoOffset;\n                this.privBytesSent = 0;\n                return;\n            }\n            else if (statusCode === 403) {\n                yield this.onComplete();\n            }\n        });\n    }\n    onServiceTurnEndResponse(continuousRecognition) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.privTurnDeferral.resolve();\n            if (!continuousRecognition || this.isSpeechEnded) {\n                yield this.onComplete();\n                this.privInTurn = false;\n            }\n            else {\n                // Start a new request set.\n                this.privTurnStartAudioOffset = this.privLastRecoOffset;\n                this.privRequestId = createNoDashGuid();\n                this.privAudioNode.replay();\n            }\n        });\n    }\n    onHypothesis(offset) {\n        if (!this.privHypothesisReceived) {\n            this.privHypothesisReceived = true;\n            this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\n        }\n    }\n    onPhraseRecognized(offset) {\n        this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\n        this.onServiceRecognized(offset);\n    }\n    onServiceRecognized(offset) {\n        this.privLastRecoOffset = offset;\n        this.privHypothesisReceived = false;\n        this.privAudioNode.shrinkBuffers(offset);\n        this.privConnectionAttempts = 0;\n    }\n    onAudioSent(bytesSent) {\n        this.privBytesSent += bytesSent;\n    }\n    onRetryConnection() {\n        this.privConnectionAttempts++;\n    }\n    dispose(error) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.privIsDisposed) {\n                // we should have completed by now. If we did not its an unknown error.\n                this.privIsDisposed = true;\n                for (const detachable of this.privDetachables) {\n                    yield detachable.detach();\n                }\n                (_a = this.privServiceTelemetryListener) === null || _a === void 0 ? void 0 : _a.dispose();\n                this.privIsRecognizing = false;\n            }\n        });\n    }\n    onStopRecognizing() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.onComplete();\n        });\n    }\n    // Should be called with the audioNode for this session has indicated that it is out of speech.\n    onSpeechEnded() {\n        this.privIsSpeechEnded = true;\n    }\n    onComplete() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!!this.privIsRecognizing) {\n                this.privIsRecognizing = false;\n                yield this.detachAudioNode();\n            }\n        });\n    }\n    detachAudioNode() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.privIsAudioNodeDetached) {\n                this.privIsAudioNodeDetached = true;\n                if (this.privAudioNode) {\n                    yield this.privAudioNode.detach();\n                }\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=RequestSession.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// response\nexport class ActivityPayloadResponse {\n    constructor(json) {\n        this.privActivityResponse = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new ActivityPayloadResponse(json);\n    }\n    get conversationId() {\n        return this.privActivityResponse.conversationId;\n    }\n    get messageDataStreamType() {\n        return this.privActivityResponse.messageDataStreamType;\n    }\n    get messagePayload() {\n        return this.privActivityResponse.messagePayload;\n    }\n    get version() {\n        return this.privActivityResponse.version;\n    }\n}\nexport var MessageDataStreamType;\n(function (MessageDataStreamType) {\n    MessageDataStreamType[MessageDataStreamType[\"None\"] = 0] = \"None\";\n    MessageDataStreamType[MessageDataStreamType[\"TextToSpeechAudio\"] = 1] = \"TextToSpeechAudio\";\n})(MessageDataStreamType || (MessageDataStreamType = {}));\n\n//# sourceMappingURL=ActivityResponsePayload.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RecognitionStatus } from \"../Exports\";\nexport class DetailedSpeechPhrase {\n    constructor(json) {\n        this.privDetailedSpeechPhrase = JSON.parse(json);\n        this.privDetailedSpeechPhrase.RecognitionStatus = RecognitionStatus[this.privDetailedSpeechPhrase.RecognitionStatus];\n    }\n    static fromJSON(json) {\n        return new DetailedSpeechPhrase(json);\n    }\n    getJsonWithCorrectedOffsets(baseOffset) {\n        if (!!this.privDetailedSpeechPhrase.NBest && !!this.privDetailedSpeechPhrase.NBest[0].Words) {\n            const firstWordOffset = this.privDetailedSpeechPhrase.NBest[0].Words[0].Offset;\n            if (firstWordOffset && firstWordOffset < baseOffset) {\n                const offset = baseOffset - firstWordOffset;\n                for (const details of this.privDetailedSpeechPhrase.NBest) {\n                    for (const word of details.Words) {\n                        word.Offset += offset;\n                    }\n                }\n            }\n        }\n        return JSON.stringify(this.privDetailedSpeechPhrase);\n    }\n    get RecognitionStatus() {\n        return this.privDetailedSpeechPhrase.RecognitionStatus;\n    }\n    get NBest() {\n        return this.privDetailedSpeechPhrase.NBest;\n    }\n    get Duration() {\n        return this.privDetailedSpeechPhrase.Duration;\n    }\n    get Offset() {\n        return this.privDetailedSpeechPhrase.Offset;\n    }\n    get Language() {\n        return this.privDetailedSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;\n    }\n    get LanguageDetectionConfidence() {\n        return this.privDetailedSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;\n    }\n}\n\n//# sourceMappingURL=DetailedSpeechPhrase.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * @class SynthesisStatus\n * @private\n */\nexport var SynthesisStatus;\n(function (SynthesisStatus) {\n    /**\n     * The response contains valid audio data.\n     * @member SynthesisStatus.Success\n     */\n    SynthesisStatus[SynthesisStatus[\"Success\"] = 0] = \"Success\";\n    /**\n     * Indicates the end of audio data. No valid audio data is included in the message.\n     * @member SynthesisStatus.SynthesisEnd\n     */\n    SynthesisStatus[SynthesisStatus[\"SynthesisEnd\"] = 1] = \"SynthesisEnd\";\n    /**\n     * Indicates an error occurred during synthesis data processing.\n     * @member SynthesisStatus.Error\n     */\n    SynthesisStatus[SynthesisStatus[\"Error\"] = 2] = \"Error\";\n})(SynthesisStatus || (SynthesisStatus = {}));\nexport var RecognitionStatus;\n(function (RecognitionStatus) {\n    RecognitionStatus[RecognitionStatus[\"Success\"] = 0] = \"Success\";\n    RecognitionStatus[RecognitionStatus[\"NoMatch\"] = 1] = \"NoMatch\";\n    RecognitionStatus[RecognitionStatus[\"InitialSilenceTimeout\"] = 2] = \"InitialSilenceTimeout\";\n    RecognitionStatus[RecognitionStatus[\"BabbleTimeout\"] = 3] = \"BabbleTimeout\";\n    RecognitionStatus[RecognitionStatus[\"Error\"] = 4] = \"Error\";\n    RecognitionStatus[RecognitionStatus[\"EndOfDictation\"] = 5] = \"EndOfDictation\";\n    RecognitionStatus[RecognitionStatus[\"TooManyRequests\"] = 6] = \"TooManyRequests\";\n})(RecognitionStatus || (RecognitionStatus = {}));\n\n//# sourceMappingURL=Enums.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// response\nexport class IntentResponse {\n    constructor(json) {\n        this.privIntentResponse = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new IntentResponse(json);\n    }\n    get query() {\n        return this.privIntentResponse.query;\n    }\n    get topScoringIntent() {\n        return this.privIntentResponse.topScoringIntent;\n    }\n    get entities() {\n        return this.privIntentResponse.entities;\n    }\n}\n\n//# sourceMappingURL=IntentResponse.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RecognitionStatus } from \"../Exports\";\nexport class SimpleSpeechPhrase {\n    constructor(json) {\n        this.privSimpleSpeechPhrase = JSON.parse(json);\n        this.privSimpleSpeechPhrase.RecognitionStatus = RecognitionStatus[this.privSimpleSpeechPhrase.RecognitionStatus];\n    }\n    static fromJSON(json) {\n        return new SimpleSpeechPhrase(json);\n    }\n    get RecognitionStatus() {\n        return this.privSimpleSpeechPhrase.RecognitionStatus;\n    }\n    get DisplayText() {\n        return this.privSimpleSpeechPhrase.DisplayText;\n    }\n    get Offset() {\n        return this.privSimpleSpeechPhrase.Offset;\n    }\n    get Duration() {\n        return this.privSimpleSpeechPhrase.Duration;\n    }\n    get Language() {\n        return this.privSimpleSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;\n    }\n    get LanguageDetectionConfidence() {\n        return this.privSimpleSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;\n    }\n    get SpeakerId() {\n        return this.privSimpleSpeechPhrase.SpeakerId;\n    }\n}\n\n//# sourceMappingURL=SimpleSpeechPhrase.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class SpeechDetected {\n    constructor(json) {\n        this.privSpeechStartDetected = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new SpeechDetected(json);\n    }\n    get Offset() {\n        return this.privSpeechStartDetected.Offset;\n    }\n}\n\n//# sourceMappingURL=SpeechDetected.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class SpeechHypothesis {\n    constructor(json) {\n        this.privSpeechHypothesis = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new SpeechHypothesis(json);\n    }\n    get Text() {\n        return this.privSpeechHypothesis.Text;\n    }\n    get Offset() {\n        return this.privSpeechHypothesis.Offset;\n    }\n    get Duration() {\n        return this.privSpeechHypothesis.Duration;\n    }\n    get Language() {\n        return this.privSpeechHypothesis.PrimaryLanguage === undefined ? undefined : this.privSpeechHypothesis.PrimaryLanguage.Language;\n    }\n    get LanguageDetectionConfidence() {\n        return this.privSpeechHypothesis.PrimaryLanguage === undefined ? undefined : this.privSpeechHypothesis.PrimaryLanguage.Confidence;\n    }\n    get SpeakerId() {\n        return this.privSpeechHypothesis.SpeakerId;\n    }\n}\n\n//# sourceMappingURL=SpeechHypothesis.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class SpeechKeyword {\n    constructor(json) {\n        this.privSpeechKeyword = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new SpeechKeyword(json);\n    }\n    get Status() {\n        return this.privSpeechKeyword.Status;\n    }\n    get Text() {\n        return this.privSpeechKeyword.Text;\n    }\n    get Offset() {\n        return this.privSpeechKeyword.Offset;\n    }\n    get Duration() {\n        return this.privSpeechKeyword.Duration;\n    }\n}\n\n//# sourceMappingURL=SpeechKeyword.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport var MetadataType;\n(function (MetadataType) {\n    MetadataType[\"WordBoundary\"] = \"WordBoundary\";\n    MetadataType[\"Bookmark\"] = \"Bookmark\";\n    MetadataType[\"Viseme\"] = \"Viseme\";\n})(MetadataType || (MetadataType = {}));\nexport class SynthesisAudioMetadata {\n    constructor(json) {\n        this.privSynthesisAudioMetadata = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new SynthesisAudioMetadata(json);\n    }\n    get Metadata() {\n        return this.privSynthesisAudioMetadata.Metadata;\n    }\n}\n\n//# sourceMappingURL=SynthesisAudioMetadata.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { TranslationStatus } from \"../TranslationStatus\";\nexport class TranslationHypothesis {\n    constructor(json) {\n        this.privTranslationHypothesis = JSON.parse(json);\n        this.privTranslationHypothesis.Translation.TranslationStatus = TranslationStatus[this.privTranslationHypothesis.Translation.TranslationStatus];\n    }\n    static fromJSON(json) {\n        return new TranslationHypothesis(json);\n    }\n    get Duration() {\n        return this.privTranslationHypothesis.Duration;\n    }\n    get Offset() {\n        return this.privTranslationHypothesis.Offset;\n    }\n    get Text() {\n        return this.privTranslationHypothesis.Text;\n    }\n    get Translation() {\n        return this.privTranslationHypothesis.Translation;\n    }\n}\n\n//# sourceMappingURL=TranslationHypothesis.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RecognitionStatus } from \"../Exports\";\nimport { TranslationStatus } from \"../TranslationStatus\";\nexport class TranslationPhrase {\n    constructor(json) {\n        this.privTranslationPhrase = JSON.parse(json);\n        this.privTranslationPhrase.RecognitionStatus = RecognitionStatus[this.privTranslationPhrase.RecognitionStatus];\n        if (this.privTranslationPhrase.Translation !== undefined) {\n            this.privTranslationPhrase.Translation.TranslationStatus = TranslationStatus[this.privTranslationPhrase.Translation.TranslationStatus];\n        }\n    }\n    static fromJSON(json) {\n        return new TranslationPhrase(json);\n    }\n    get RecognitionStatus() {\n        return this.privTranslationPhrase.RecognitionStatus;\n    }\n    get Offset() {\n        return this.privTranslationPhrase.Offset;\n    }\n    get Duration() {\n        return this.privTranslationPhrase.Duration;\n    }\n    get Text() {\n        return this.privTranslationPhrase.Text;\n    }\n    get Translation() {\n        return this.privTranslationPhrase.Translation;\n    }\n}\n\n//# sourceMappingURL=TranslationPhrase.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { SynthesisStatus } from \"../Exports\";\nexport class TranslationSynthesisEnd {\n    constructor(json) {\n        this.privSynthesisEnd = JSON.parse(json);\n        this.privSynthesisEnd.SynthesisStatus = SynthesisStatus[this.privSynthesisEnd.SynthesisStatus];\n    }\n    static fromJSON(json) {\n        return new TranslationSynthesisEnd(json);\n    }\n    get SynthesisStatus() {\n        return this.privSynthesisEnd.SynthesisStatus;\n    }\n    get FailureReason() {\n        return this.privSynthesisEnd.FailureReason;\n    }\n}\n\n//# sourceMappingURL=TranslationSynthesisEnd.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class TurnStatusResponsePayload {\n    constructor(json) {\n        this.privMessageStatusResponse = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new TurnStatusResponsePayload(json);\n    }\n    get interactionId() {\n        return this.privMessageStatusResponse.interactionId;\n    }\n    get conversationId() {\n        return this.privMessageStatusResponse.conversationId;\n    }\n    get statusCode() {\n        // Payloads may contain a limited set of textual representations or a numeric status\n        // code. The textual values are here converted into numeric ones.\n        switch (this.privMessageStatusResponse.statusCode) {\n            case \"Success\":\n                return 200;\n            case \"Failed\":\n                return 400;\n            case \"TimedOut\":\n                return 429;\n            default:\n                return this.privMessageStatusResponse.statusCode;\n        }\n    }\n}\n\n//# sourceMappingURL=TurnStatusPayload.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\nimport { ArgumentNullError, ConnectionState, createNoDashGuid, EventSource, MessageType, ServiceEvent, Timeout } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyId, RecognitionEventArgs, SessionEventArgs, } from \"../sdk/Exports\";\nimport { AgentConfig, DynamicGrammarBuilder, RequestSession, SpeechContext, SpeechDetected, type } from \"./Exports\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class ServiceRecognizerBase {\n    constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n        this.privSetTimeout = setTimeout;\n        this.privIsLiveAudio = false;\n        this.recognizeOverride = undefined;\n        this.disconnectOverride = undefined;\n        this.receiveMessageOverride = undefined;\n        this.sendSpeechContext = (connection) => {\n            const speechContextJson = this.speechContext.toJSON();\n            if (speechContextJson) {\n                return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.context\", this.privRequestSession.requestId, \"application/json\", speechContextJson));\n            }\n            return;\n        };\n        this.sendPrePayloadJSONOverride = undefined;\n        this.postConnectImplOverride = undefined;\n        this.configConnectionOverride = undefined;\n        this.sendSpeechServiceConfig = (connection, requestSession, SpeechServiceConfigJson) => {\n            // filter out anything that is not required for the service to work.\n            if (ServiceRecognizerBase.telemetryDataEnabled !== true) {\n                const withTelemetry = JSON.parse(SpeechServiceConfigJson);\n                const replacement = {\n                    context: {\n                        system: withTelemetry.context.system,\n                    },\n                };\n                SpeechServiceConfigJson = JSON.stringify(replacement);\n            }\n            if (this.privRecognizerConfig.parameters.getProperty(\"TranscriptionService_SingleChannel\", \"false\").toLowerCase() === \"true\") {\n                const json = JSON.parse(SpeechServiceConfigJson);\n                json.context.DisableReferenceChannel = \"True\";\n                json.context.MicSpec = \"1_0_0\";\n                SpeechServiceConfigJson = JSON.stringify(json);\n            }\n            if (SpeechServiceConfigJson) {\n                return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.config\", requestSession.requestId, \"application/json\", SpeechServiceConfigJson));\n            }\n            return;\n        };\n        if (!authentication) {\n            throw new ArgumentNullError(\"authentication\");\n        }\n        if (!connectionFactory) {\n            throw new ArgumentNullError(\"connectionFactory\");\n        }\n        if (!audioSource) {\n            throw new ArgumentNullError(\"audioSource\");\n        }\n        if (!recognizerConfig) {\n            throw new ArgumentNullError(\"recognizerConfig\");\n        }\n        this.privMustReportEndOfStream = false;\n        this.privAuthentication = authentication;\n        this.privConnectionFactory = connectionFactory;\n        this.privAudioSource = audioSource;\n        this.privRecognizerConfig = recognizerConfig;\n        this.privIsDisposed = false;\n        this.privRecognizer = recognizer;\n        this.privRequestSession = new RequestSession(this.privAudioSource.id());\n        this.privConnectionEvents = new EventSource();\n        this.privServiceEvents = new EventSource();\n        this.privDynamicGrammar = new DynamicGrammarBuilder();\n        this.privSpeechContext = new SpeechContext(this.privDynamicGrammar);\n        this.privAgentConfig = new AgentConfig();\n        if (typeof (Blob) !== \"undefined\" && typeof (Worker) !== \"undefined\") {\n            this.privSetTimeout = Timeout.setTimeout;\n        }\n        this.connectionEvents.attach((connectionEvent) => __awaiter(this, void 0, void 0, function* () {\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\n                const connectionClosedEvent = connectionEvent;\n                if (connectionClosedEvent.statusCode === 1003 ||\n                    connectionClosedEvent.statusCode === 1007 ||\n                    connectionClosedEvent.statusCode === 1002 ||\n                    connectionClosedEvent.statusCode === 4000 ||\n                    this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) {\n                    yield this.cancelRecognitionLocal(CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, connectionClosedEvent.reason + \" websocket error code: \" + connectionClosedEvent.statusCode);\n                }\n            }\n        }));\n    }\n    get audioSource() {\n        return this.privAudioSource;\n    }\n    get speechContext() {\n        return this.privSpeechContext;\n    }\n    get dynamicGrammar() {\n        return this.privDynamicGrammar;\n    }\n    get agentConfig() {\n        return this.privAgentConfig;\n    }\n    set conversationTranslatorToken(token) {\n        this.privRecognizerConfig.parameters.setProperty(PropertyId.ConversationTranslator_Token, token);\n    }\n    set authentication(auth) {\n        this.privAuthentication = this.authentication;\n    }\n    isDisposed() {\n        return this.privIsDisposed;\n    }\n    dispose(reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.privIsDisposed = true;\n            if (this.privConnectionConfigurationPromise) {\n                try {\n                    const connection = yield this.privConnectionConfigurationPromise;\n                    yield connection.dispose(reason);\n                }\n                catch (error) {\n                    // The connection is in a bad state. But we're trying to kill it, so...\n                    return;\n                }\n            }\n        });\n    }\n    get connectionEvents() {\n        return this.privConnectionEvents;\n    }\n    get serviceEvents() {\n        return this.privServiceEvents;\n    }\n    get recognitionMode() {\n        return this.privRecognizerConfig.recognitionMode;\n    }\n    recognize(recoMode, successCallback, errorCallBack) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.recognizeOverride !== undefined) {\n                return this.recognizeOverride(recoMode, successCallback, errorCallBack);\n            }\n            // Clear the existing configuration promise to force a re-transmission of config and context.\n            this.privConnectionConfigurationPromise = null;\n            this.privRecognizerConfig.recognitionMode = recoMode;\n            this.privSuccessCallback = successCallback;\n            this.privErrorCallback = errorCallBack;\n            this.privRequestSession.startNewRecognition();\n            this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);\n            // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n            const conPromise = this.connectImpl();\n            let audioNode;\n            try {\n                const audioStreamNode = yield this.audioSource.attach(this.privRequestSession.audioNodeId);\n                const format = yield this.audioSource.format;\n                const deviceInfo = yield this.audioSource.deviceInfo;\n                this.privIsLiveAudio = deviceInfo.type && deviceInfo.type === type.Microphones;\n                audioNode = new ReplayableAudioNode(audioStreamNode, format.avgBytesPerSec);\n                yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n                this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\n            }\n            catch (error) {\n                yield this.privRequestSession.onStopRecognizing();\n                throw error;\n            }\n            try {\n                yield conPromise;\n            }\n            catch (error) {\n                yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\n                return;\n            }\n            const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n            if (!!this.privRecognizer.sessionStarted) {\n                this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n            }\n            const messageRetrievalPromise = this.receiveMessage();\n            const audioSendPromise = this.sendAudio(audioNode);\n            audioSendPromise.catch((error) => __awaiter(this, void 0, void 0, function* () {\n                yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n            }));\n            return;\n        });\n    }\n    stopRecognizing() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privRequestSession.isRecognizing) {\n                try {\n                    yield this.audioSource.turnOff();\n                    yield this.sendFinalAudio();\n                    yield this.privRequestSession.onStopRecognizing();\n                    yield this.privRequestSession.turnCompletionPromise;\n                }\n                finally {\n                    yield this.privRequestSession.dispose();\n                }\n            }\n            return;\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.connectImpl();\n            return Promise.resolve();\n        });\n    }\n    connectAsync(cb, err) {\n        this.connectImpl().then((connection) => {\n            try {\n                if (!!cb) {\n                    cb();\n                }\n            }\n            catch (e) {\n                if (!!err) {\n                    err(e);\n                }\n            }\n        }, (reason) => {\n            try {\n                if (!!err) {\n                    err(reason);\n                }\n                /* tslint:disable:no-empty */\n            }\n            catch (error) {\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n            if (this.disconnectOverride !== undefined) {\n                yield this.disconnectOverride();\n            }\n            try {\n                yield (yield this.privConnectionPromise).dispose();\n            }\n            catch (error) {\n            }\n            this.privConnectionPromise = null;\n        });\n    }\n    sendMessage(message) { }\n    sendNetworkMessage(path, payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const type = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n            const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n            const connection = yield this.fetchConnection();\n            return connection.send(new SpeechConnectionMessage(type, path, this.privRequestSession.requestId, contentType, payload));\n        });\n    }\n    set activityTemplate(messagePayload) { this.privActivityTemplate = messagePayload; }\n    get activityTemplate() { return this.privActivityTemplate; }\n    sendTelemetryData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const telemetryData = this.privRequestSession.getTelemetry();\n            if (ServiceRecognizerBase.telemetryDataEnabled !== true ||\n                this.privIsDisposed ||\n                null === telemetryData) {\n                return;\n            }\n            if (!!ServiceRecognizerBase.telemetryData) {\n                try {\n                    ServiceRecognizerBase.telemetryData(telemetryData);\n                    /* tslint:disable:no-empty */\n                }\n                catch (_a) { }\n            }\n            const connection = yield this.fetchConnection();\n            yield connection.send(new SpeechConnectionMessage(MessageType.Text, \"telemetry\", this.privRequestSession.requestId, \"application/json\", telemetryData));\n        });\n    }\n    // Cancels recognition.\n    cancelRecognitionLocal(cancellationReason, errorCode, error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!!this.privRequestSession.isRecognizing) {\n                yield this.privRequestSession.onStopRecognizing();\n                this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, cancellationReason, errorCode, error);\n            }\n        });\n    }\n    receiveMessage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.privIsDisposed) {\n                    // We're done.\n                    return;\n                }\n                let connection = yield this.fetchConnection();\n                const message = yield connection.read();\n                if (this.receiveMessageOverride !== undefined) {\n                    return this.receiveMessageOverride();\n                }\n                // indicates we are draining the queue and it came with no message;\n                if (!message) {\n                    if (!this.privRequestSession.isRecognizing) {\n                        return;\n                    }\n                    else {\n                        return this.receiveMessage();\n                    }\n                }\n                this.privServiceHasSentMessage = true;\n                const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n                if (connectionMessage.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase()) {\n                    switch (connectionMessage.path.toLowerCase()) {\n                        case \"turn.start\":\n                            this.privMustReportEndOfStream = true;\n                            this.privRequestSession.onServiceTurnStartResponse();\n                            break;\n                        case \"speech.startdetected\":\n                            const speechStartDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\n                            const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n                            if (!!this.privRecognizer.speechStartDetected) {\n                                this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n                            }\n                            break;\n                        case \"speech.enddetected\":\n                            let json;\n                            if (connectionMessage.textBody.length > 0) {\n                                json = connectionMessage.textBody;\n                            }\n                            else {\n                                // If the request was empty, the JSON returned is empty.\n                                json = \"{ Offset: 0 }\";\n                            }\n                            const speechStopDetected = SpeechDetected.fromJSON(json);\n                            // Only shrink the buffers for continuous recognition.\n                            // For single shot, the speech.phrase message will come after the speech.end and it should own buffer shrink.\n                            if (this.privRecognizerConfig.isContinuousRecognition) {\n                                this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n                            }\n                            const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n                            if (!!this.privRecognizer.speechEndDetected) {\n                                this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n                            }\n                            break;\n                        case \"turn.end\":\n                            yield this.sendTelemetryData();\n                            if (this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream) {\n                                this.privMustReportEndOfStream = false;\n                                yield this.cancelRecognitionLocal(CancellationReason.EndOfStream, CancellationErrorCode.NoError, undefined);\n                            }\n                            const sessionStopEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n                            yield this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition);\n                            if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                                if (!!this.privRecognizer.sessionStopped) {\n                                    this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                                }\n                                return;\n                            }\n                            else {\n                                connection = yield this.fetchConnection();\n                                yield this.sendPrePayloadJSON(connection);\n                            }\n                            break;\n                        default:\n                            if (!(yield this.processTypeSpecificMessages(connectionMessage))) {\n                                // here are some messages that the derived class has not processed, dispatch them to connect class\n                                if (!!this.privServiceEvents) {\n                                    this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                                }\n                            }\n                    }\n                }\n                return this.receiveMessage();\n            }\n            catch (error) {\n                return null;\n            }\n        });\n    }\n    // Encapsulated for derived service recognizers that need to send additional JSON\n    sendPrePayloadJSON(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.sendPrePayloadJSONOverride !== undefined) {\n                return this.sendPrePayloadJSONOverride(connection);\n            }\n            yield this.sendSpeechContext(connection);\n            yield this.sendWaveHeader(connection);\n            return;\n        });\n    }\n    sendWaveHeader(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const format = yield this.audioSource.format;\n            // this.writeBufferToConsole(format.header);\n            return connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, \"audio/x-wav\", format.header));\n        });\n    }\n    // Establishes a websocket connection to the end point.\n    connectImpl() {\n        if (this.privConnectionPromise) {\n            return this.privConnectionPromise.then((connection) => {\n                if (connection.state() === ConnectionState.Disconnected) {\n                    this.privConnectionId = null;\n                    this.privConnectionPromise = null;\n                    this.privServiceHasSentMessage = false;\n                    return this.connectImpl();\n                }\n                return this.privConnectionPromise;\n            }, (error) => {\n                this.privConnectionId = null;\n                this.privConnectionPromise = null;\n                this.privServiceHasSentMessage = false;\n                return this.connectImpl();\n            });\n        }\n        this.privConnectionPromise = this.retryableConnect();\n        // Attach an empty handler to allow the promise to run in the background while\n        // other startup events happen. It'll eventually be awaited on.\n        this.privConnectionPromise.catch(() => { });\n        if (this.postConnectImplOverride !== undefined) {\n            return this.postConnectImplOverride(this.privConnectionPromise);\n        }\n        return this.privConnectionPromise;\n    }\n    fetchConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privConnectionConfigurationPromise) {\n                return this.privConnectionConfigurationPromise.then((connection) => {\n                    if (connection.state() === ConnectionState.Disconnected) {\n                        this.privConnectionId = null;\n                        this.privConnectionConfigurationPromise = null;\n                        this.privServiceHasSentMessage = false;\n                        return this.fetchConnection();\n                    }\n                    return this.privConnectionConfigurationPromise;\n                }, (error) => {\n                    this.privConnectionId = null;\n                    this.privConnectionConfigurationPromise = null;\n                    this.privServiceHasSentMessage = false;\n                    return this.fetchConnection();\n                });\n            }\n            this.privConnectionConfigurationPromise = this.configureConnection();\n            return yield this.privConnectionConfigurationPromise;\n        });\n    }\n    sendAudio(audioStreamNode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const audioFormat = yield this.audioSource.format;\n            // The time we last sent data to the service.\n            let nextSendTime = Date.now();\n            // Max amount to send before we start to throttle\n            const fastLaneSizeMs = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-TransmitLengthBeforThrottleMs\", \"5000\");\n            const maxSendUnthrottledBytes = audioFormat.avgBytesPerSec / 1000 * parseInt(fastLaneSizeMs, 10);\n            const startRecogNumber = this.privRequestSession.recogNumber;\n            const readAndUploadCycle = () => __awaiter(this, void 0, void 0, function* () {\n                // If speech is done, stop sending audio.\n                if (!this.privIsDisposed &&\n                    !this.privRequestSession.isSpeechEnded &&\n                    this.privRequestSession.isRecognizing &&\n                    this.privRequestSession.recogNumber === startRecogNumber) {\n                    const connection = yield this.fetchConnection();\n                    const audioStreamChunk = yield audioStreamNode.read();\n                    // we have a new audio chunk to upload.\n                    if (this.privRequestSession.isSpeechEnded) {\n                        // If service already recognized audio end then don't send any more audio\n                        return;\n                    }\n                    let payload;\n                    let sendDelay;\n                    if (!audioStreamChunk || audioStreamChunk.isEnd) {\n                        payload = null;\n                        sendDelay = 0;\n                    }\n                    else {\n                        payload = audioStreamChunk.buffer;\n                        this.privRequestSession.onAudioSent(payload.byteLength);\n                        if (maxSendUnthrottledBytes >= this.privRequestSession.bytesSent) {\n                            sendDelay = 0;\n                        }\n                        else {\n                            sendDelay = Math.max(0, nextSendTime - Date.now());\n                        }\n                    }\n                    if (0 !== sendDelay) {\n                        yield this.delay(sendDelay);\n                    }\n                    if (payload !== null) {\n                        nextSendTime = Date.now() + (payload.byteLength * 1000 / (audioFormat.avgBytesPerSec * 2));\n                    }\n                    // Are we still alive?\n                    if (!this.privIsDisposed &&\n                        !this.privRequestSession.isSpeechEnded &&\n                        this.privRequestSession.isRecognizing &&\n                        this.privRequestSession.recogNumber === startRecogNumber) {\n                        connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, null, payload)).catch(() => {\n                            this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => { });\n                        });\n                        if (!(audioStreamChunk === null || audioStreamChunk === void 0 ? void 0 : audioStreamChunk.isEnd)) {\n                            // this.writeBufferToConsole(payload);\n                            // Regardless of success or failure, schedule the next upload.\n                            // If the underlying connection was broken, the next cycle will\n                            // get a new connection and re-transmit missing audio automatically.\n                            return readAndUploadCycle();\n                        }\n                        else {\n                            // the audio stream has been closed, no need to schedule next\n                            // read-upload cycle.\n                            if (!this.privIsLiveAudio) {\n                                this.privRequestSession.onSpeechEnded();\n                            }\n                        }\n                    }\n                }\n            });\n            return readAndUploadCycle();\n        });\n    }\n    retryableConnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let isUnAuthorized = false;\n            this.privAuthFetchEventId = createNoDashGuid();\n            const sessionId = this.privRequestSession.sessionId;\n            this.privConnectionId = (sessionId !== undefined) ? sessionId : createNoDashGuid();\n            this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);\n            let lastStatusCode = 0;\n            let lastReason = \"\";\n            while (this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount) {\n                // Get the auth information for the connection. This is a bit of overkill for the current API surface, but leaving the plumbing in place to be able to raise a developer-customer\n                // facing event when a connection fails to let them try and provide new auth information.\n                const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n                const auth = yield authPromise;\n                yield this.privRequestSession.onAuthCompleted(false);\n                // Create the connection\n                const connection = this.privConnectionFactory.create(this.privRecognizerConfig, auth, this.privConnectionId);\n                // Attach the telemetry handlers.\n                this.privRequestSession.listenForServiceTelemetry(connection.events);\n                // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n                // it'll stop sending events.\n                connection.events.attach((event) => {\n                    this.connectionEvents.onEvent(event);\n                });\n                const response = yield connection.open();\n                // 200 == everything is fine.\n                if (response.statusCode === 200) {\n                    yield this.privRequestSession.onConnectionEstablishCompleted(response.statusCode);\n                    return Promise.resolve(connection);\n                }\n                else if (response.statusCode === 1006) {\n                    isUnAuthorized = true;\n                }\n                lastStatusCode = response.statusCode;\n                lastReason = response.reason;\n                this.privRequestSession.onRetryConnection();\n            }\n            yield this.privRequestSession.onConnectionEstablishCompleted(lastStatusCode, lastReason);\n            return Promise.reject(`Unable to contact server. StatusCode: ${lastStatusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${lastReason}`);\n        });\n    }\n    delay(delayMs) {\n        return new Promise((resolve, reject) => {\n            this.privSetTimeout(resolve, delayMs);\n        });\n    }\n    writeBufferToConsole(buffer) {\n        let out = \"Buffer Size: \";\n        if (null === buffer) {\n            out += \"null\";\n        }\n        else {\n            const readView = new Uint8Array(buffer);\n            out += buffer.byteLength + \"\\r\\n\";\n            for (let i = 0; i < buffer.byteLength; i++) {\n                out += readView[i].toString(16).padStart(2, \"0\") + \" \";\n            }\n        }\n        // tslint:disable-next-line:no-console\n        console.info(out);\n    }\n    sendFinalAudio() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.fetchConnection();\n            yield connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, null, null));\n            return;\n        });\n    }\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\n    configureConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.connectImpl();\n            if (this.configConnectionOverride !== undefined) {\n                return this.configConnectionOverride(connection);\n            }\n            yield this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\n            yield this.sendPrePayloadJSON(connection);\n            return connection;\n        });\n    }\n}\nServiceRecognizerBase.telemetryDataEnabled = true;\n\n//# sourceMappingURL=ServiceRecognizerBase.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// tslint:disable:max-classes-per-file\nimport { AudioSourceErrorEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ConnectionEstablishedEvent, ConnectionEstablishErrorEvent, ConnectionMessageReceivedEvent, ConnectionStartEvent, } from \"../common/Exports\";\nimport { ConnectingToServiceEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents\";\nexport class ServiceTelemetryListener {\n    constructor(requestId, audioSourceId, audioNodeId) {\n        this.privIsDisposed = false;\n        this.privListeningTriggerMetric = null;\n        this.privMicMetric = null;\n        this.privConnectionEstablishMetric = null;\n        this.onEvent = (e) => {\n            if (this.privIsDisposed) {\n                return;\n            }\n            if (e instanceof RecognitionTriggeredEvent && e.requestId === this.privRequestId) {\n                this.privListeningTriggerMetric = {\n                    End: e.eventTime,\n                    Name: \"ListeningTrigger\",\n                    Start: e.eventTime,\n                };\n            }\n            if (e instanceof AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n                this.privMicStartTime = e.eventTime;\n            }\n            if (e instanceof AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n                this.privMicStartTime = e.eventTime;\n            }\n            if (e instanceof AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId) {\n                if (!this.privMicMetric) {\n                    this.privMicMetric = {\n                        End: e.eventTime,\n                        Error: e.error,\n                        Name: \"Microphone\",\n                        Start: this.privMicStartTime,\n                    };\n                }\n            }\n            if (e instanceof AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n                if (!this.privMicMetric) {\n                    this.privMicMetric = {\n                        End: e.eventTime,\n                        Error: e.error,\n                        Name: \"Microphone\",\n                        Start: this.privMicStartTime,\n                    };\n                }\n            }\n            if (e instanceof AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n                if (!this.privMicMetric) {\n                    this.privMicMetric = {\n                        End: e.eventTime,\n                        Name: \"Microphone\",\n                        Start: this.privMicStartTime,\n                    };\n                }\n            }\n            if (e instanceof ConnectingToServiceEvent && e.requestId === this.privRequestId) {\n                this.privConnectionId = e.sessionId;\n            }\n            if (e instanceof ConnectionStartEvent && e.connectionId === this.privConnectionId) {\n                this.privConnectionStartTime = e.eventTime;\n            }\n            if (e instanceof ConnectionEstablishedEvent && e.connectionId === this.privConnectionId) {\n                if (!this.privConnectionEstablishMetric) {\n                    this.privConnectionEstablishMetric = {\n                        End: e.eventTime,\n                        Id: this.privConnectionId,\n                        Name: \"Connection\",\n                        Start: this.privConnectionStartTime,\n                    };\n                }\n            }\n            if (e instanceof ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId) {\n                if (!this.privConnectionEstablishMetric) {\n                    this.privConnectionEstablishMetric = {\n                        End: e.eventTime,\n                        Error: this.getConnectionError(e.statusCode),\n                        Id: this.privConnectionId,\n                        Name: \"Connection\",\n                        Start: this.privConnectionStartTime,\n                    };\n                }\n            }\n            if (e instanceof ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId) {\n                if (e.message && e.message.headers && e.message.headers.path) {\n                    if (!this.privReceivedMessages[e.message.headers.path]) {\n                        this.privReceivedMessages[e.message.headers.path] = new Array();\n                    }\n                    const maxMessagesToSend = 50;\n                    if (this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend) {\n                        this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);\n                    }\n                }\n            }\n        };\n        this.getTelemetry = () => {\n            const metrics = new Array();\n            if (this.privListeningTriggerMetric) {\n                metrics.push(this.privListeningTriggerMetric);\n            }\n            if (this.privMicMetric) {\n                metrics.push(this.privMicMetric);\n            }\n            if (this.privConnectionEstablishMetric) {\n                metrics.push(this.privConnectionEstablishMetric);\n            }\n            if (this.privPhraseLatencies.length > 0) {\n                metrics.push({\n                    PhraseLatencyMs: this.privPhraseLatencies,\n                });\n            }\n            if (this.privHypothesisLatencies.length > 0) {\n                metrics.push({\n                    FirstHypothesisLatencyMs: this.privHypothesisLatencies,\n                });\n            }\n            const telemetry = {\n                Metrics: metrics,\n                ReceivedMessages: this.privReceivedMessages,\n            };\n            const json = JSON.stringify(telemetry);\n            // We dont want to send the same telemetry again. So clean those out.\n            this.privReceivedMessages = {};\n            this.privListeningTriggerMetric = null;\n            this.privMicMetric = null;\n            this.privConnectionEstablishMetric = null;\n            this.privPhraseLatencies = [];\n            this.privHypothesisLatencies = [];\n            return json;\n        };\n        this.dispose = () => {\n            this.privIsDisposed = true;\n        };\n        this.getConnectionError = (statusCode) => {\n            /*\n            -- Websocket status codes --\n            NormalClosure = 1000,\n            EndpointUnavailable = 1001,\n            ProtocolError = 1002,\n            InvalidMessageType = 1003,\n            Empty = 1005,\n            InvalidPayloadData = 1007,\n            PolicyViolation = 1008,\n            MessageTooBig = 1009,\n            MandatoryExtension = 1010,\n            InternalServerError = 1011\n            */\n            switch (statusCode) {\n                case 400:\n                case 1002:\n                case 1003:\n                case 1005:\n                case 1007:\n                case 1008:\n                case 1009: return \"BadRequest\";\n                case 401: return \"Unauthorized\";\n                case 403: return \"Forbidden\";\n                case 503:\n                case 1001: return \"ServerUnavailable\";\n                case 500:\n                case 1011: return \"ServerError\";\n                case 408:\n                case 504: return \"Timeout\";\n                default: return \"statuscode:\" + statusCode.toString();\n            }\n        };\n        this.privRequestId = requestId;\n        this.privAudioSourceId = audioSourceId;\n        this.privAudioNodeId = audioNodeId;\n        this.privReceivedMessages = {};\n        this.privPhraseLatencies = [];\n        this.privHypothesisLatencies = [];\n    }\n    phraseReceived(audioReceivedTime) {\n        if (audioReceivedTime > 0) { // 0 indicates the time is unknown. Drop it.\n            this.privPhraseLatencies.push(Date.now() - audioReceivedTime);\n        }\n    }\n    hypothesisReceived(audioReceivedTime) {\n        if (audioReceivedTime > 0) { // 0 indicates the time is unknown. Drop it.\n            this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);\n        }\n    }\n    // Determines if there are any telemetry events to send to the service.\n    get hasTelemetry() {\n        return (Object.keys(this.privReceivedMessages).length !== 0 ||\n            this.privListeningTriggerMetric !== null ||\n            this.privMicMetric !== null ||\n            this.privConnectionEstablishMetric !== null ||\n            this.privPhraseLatencies.length !== 0 ||\n            this.privHypothesisLatencies.length !== 0);\n    }\n}\n\n//# sourceMappingURL=ServiceTelemetryListener.Internal.js.map\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { RestConfigBase, RestMessageAdapter, RestRequestType, } from \"../common.browser/Exports\";\nimport { PropertyId, VoiceProfileType, } from \"../sdk/Exports\";\n/**\n * Implements methods for speaker recognition classes, sending requests to endpoint\n * and parsing response into expected format\n * @class SpeakerIdMessageAdapter\n */\nexport class SpeakerIdMessageAdapter {\n    constructor(config) {\n        let endpoint = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint, undefined);\n        if (!endpoint) {\n            const region = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Region, \"westus\");\n            const version = config.parameters.getProperty(PropertyId.SpeakerRecognition_Api_Version, \"2.0\");\n            const hostSuffix = (region && region.toLowerCase().startsWith(\"china\")) ? \".azure.cn\" : \".microsoft.com\";\n            const host = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Host, `https://${region}.api.cognitive${hostSuffix}/speaker/{mode}/v${version}/{dependency}`);\n            endpoint = host + \"/profiles\";\n        }\n        this.privUri = endpoint;\n        const options = RestConfigBase.requestOptions;\n        options.headers[RestConfigBase.configParams.subscriptionKey] = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Key, undefined);\n        this.privRestAdapter = new RestMessageAdapter(options);\n    }\n    /**\n     * Sends create profile request to endpoint.\n     * @function\n     * @param {VoiceProfileType} profileType - type of voice profile to create.\n     * @param {string} lang - language/locale of voice profile\n     * @public\n     * @returns {Promise<IRestResponse>} promised rest response containing id of created profile.\n     */\n    createProfile(profileType, lang) {\n        const uri = this.getOperationUri(profileType);\n        return this.privRestAdapter.request(RestRequestType.Post, uri, {}, { locale: lang });\n    }\n    /**\n     * Sends create enrollment request to endpoint.\n     * @function\n     * @param {VoiceProfile} profileType - voice profile for which to create new enrollment.\n     * @param {IAudioSource} audioSource - audioSource from which to pull data to send\n     * @public\n     * @returns {Promise<IRestResponse>} rest response to enrollment request.\n     */\n    createEnrollment(profile, audioSource) {\n        const uri = this.getOperationUri(profile.profileType) + \"/\" + profile.profileId + \"/enrollments\";\n        return audioSource.blob.then((result) => {\n            return this.privRestAdapter.request(RestRequestType.File, uri, { ignoreMinLength: \"true\" }, null, result);\n        });\n    }\n    /**\n     * Sends verification request to endpoint.\n     * @function\n     * @param {SpeakerVerificationModel} model - voice model to verify against.\n     * @param {IAudioSource} audioSource - audioSource from which to pull data to send\n     * @public\n     * @returns {Promise<IRestResponse>} rest response to enrollment request.\n     */\n    verifySpeaker(model, audioSource) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const uri = this.getOperationUri(model.voiceProfile.profileType) + \"/\" + model.voiceProfile.profileId + \"/verify\";\n            try {\n                const result = yield audioSource.blob;\n                return this.privRestAdapter.request(RestRequestType.File, uri, { ignoreMinLength: \"true\" }, null, result);\n            }\n            catch (e) {\n                return Promise.resolve({ data: e });\n            }\n        });\n    }\n    /**\n     * Sends identification request to endpoint.\n     * @function\n     * @param {SpeakerIdentificationModel} model - voice profiles against which to identify.\n     * @param {IAudioSource} audioSource - audioSource from which to pull data to send\n     * @public\n     * @returns {Promise<IRestResponse>} rest response to enrollment request.\n     */\n    identifySpeaker(model, audioSource) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const uri = this.getOperationUri(VoiceProfileType.TextIndependentIdentification) + \"/identifySingleSpeaker\";\n            try {\n                const result = yield audioSource.blob;\n                return this.privRestAdapter.request(RestRequestType.File, uri, { profileIds: model.voiceProfileIds, ignoreMinLength: \"true\" }, null, result);\n            }\n            catch (e) {\n                return Promise.resolve({ data: e });\n            }\n        });\n    }\n    /**\n     * Sends profile status request to endpoint.\n     * @function\n     * @param {VoiceProfile} profile - voice profile to check.\n     * @public\n     * @returns {Promise<IRestResponse>} rest response to status request\n     */\n    getProfileStatus(profile) {\n        const uri = `${this.getOperationUri(profile.profileType)}/${profile.profileId}`;\n        return this.privRestAdapter.request(RestRequestType.Get, uri, {});\n    }\n    /**\n     * Sends get all profiles request to endpoint.\n     * @function\n     * @param {VoiceProfileType} profileType - type of profiles to return list of\n     * @public\n     * @returns {Promise<IRestResponse>} promised rest response containing all profiles\n     */\n    getProfiles(profileType) {\n        const uri = this.getOperationUri(profileType);\n        return this.privRestAdapter.request(RestRequestType.Get, uri, {});\n    }\n    /**\n     * Sends get activation/auth phrases request to endpoint.\n     * @function\n     * @param {VoiceProfileType} profileType - type of profiles to return phrases for\n     * @param {string} lang - language/locale of voice profile\n     * @public\n     * @returns {Promise<IRestResponse>} promised rest response containing list of valid phrases\n     */\n    getPhrases(profileType, lang) {\n        const uri = `${this.getOperationUri(profileType)}`.replace(`profiles`, `phrases`) + \"/\" + lang;\n        return this.privRestAdapter.request(RestRequestType.Get, uri, {});\n    }\n    /**\n     * Sends delete profile request to endpoint.\n     * @function\n     * @param {VoiceProfile} profile - voice profile to delete.\n     * @public\n     * @returns {Promise<IRestResponse>} rest response to deletion request\n     */\n    deleteProfile(profile) {\n        const uri = this.getOperationUri(profile.profileType) + \"/\" + profile.profileId;\n        return this.privRestAdapter.request(RestRequestType.Delete, uri, {});\n    }\n    /**\n     * Sends reset profile request to endpoint.\n     * @function\n     * @param {VoiceProfile} profile - voice profile to reset enrollments for.\n     * @public\n     * @returns {Promise<IRestResponse>} rest response to reset request\n     */\n    resetProfile(profile) {\n        const uri = this.getOperationUri(profile.profileType) + \"/\" + profile.profileId + \"/reset\";\n        return this.privRestAdapter.request(RestRequestType.Post, uri, {});\n    }\n    getOperationUri(profileType) {\n        const mode = profileType === VoiceProfileType.TextIndependentIdentification ? \"identification\" : \"verification\";\n        const dependency = profileType === VoiceProfileType.TextDependentVerification ? \"text-dependent\" : \"text-independent\";\n        return this.privUri.replace(\"{mode}\", mode).replace(\"{dependency}\", dependency);\n    }\n}\n\n//# sourceMappingURL=SpeakerIdMessageAdapter.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Context } from \"./Exports\";\nexport class SpeakerRecognitionConfig {\n    constructor(context, parameters) {\n        this.privContext = context ? context : new Context(null);\n        this.privParameters = parameters;\n    }\n    get parameters() {\n        return this.privParameters;\n    }\n    get Context() {\n        return this.privContext;\n    }\n}\n\n//# sourceMappingURL=SpeakerRecognitionConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ProxyInfo, WebsocketConnection, } from \"../common.browser/Exports\";\nimport { ForceDictationPropertyName, OutputFormatPropertyName, } from \"../common.speech/Exports\";\nimport { OutputFormat, PropertyId } from \"../sdk/Exports\";\nimport { ConnectionFactoryBase } from \"./ConnectionFactoryBase\";\nimport { RecognitionMode, WebsocketMessageFormatter } from \"./Exports\";\nimport { HeaderNames } from \"./HeaderNames\";\nimport { QueryParameterNames } from \"./QueryParameterNames\";\nexport class SpeechConnectionFactory extends ConnectionFactoryBase {\n    constructor() {\n        super(...arguments);\n        this.interactiveRelativeUri = \"/speech/recognition/interactive/cognitiveservices/v1\";\n        this.conversationRelativeUri = \"/speech/recognition/conversation/cognitiveservices/v1\";\n        this.dictationRelativeUri = \"/speech/recognition/dictation/cognitiveservices/v1\";\n        this.create = (config, authInfo, connectionId) => {\n            let endpoint = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint, undefined);\n            const region = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Region, undefined);\n            const hostSuffix = (region && region.toLowerCase().startsWith(\"china\")) ? \".azure.cn\" : \".microsoft.com\";\n            const host = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Host, \"wss://\" + region + \".stt.speech\" + hostSuffix);\n            const queryParams = {};\n            const endpointId = config.parameters.getProperty(PropertyId.SpeechServiceConnection_EndpointId, undefined);\n            const language = config.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, undefined);\n            if (endpointId) {\n                if (!endpoint || endpoint.search(QueryParameterNames.CustomSpeechDeploymentId) === -1) {\n                    queryParams[QueryParameterNames.CustomSpeechDeploymentId] = endpointId;\n                }\n            }\n            else if (language) {\n                if (!endpoint || endpoint.search(QueryParameterNames.Language) === -1) {\n                    queryParams[QueryParameterNames.Language] = language;\n                }\n            }\n            if (!endpoint || endpoint.search(QueryParameterNames.Format) === -1) {\n                queryParams[QueryParameterNames.Format] = config.parameters.getProperty(OutputFormatPropertyName, OutputFormat[OutputFormat.Simple]).toLowerCase();\n            }\n            if (config.autoDetectSourceLanguages !== undefined) {\n                queryParams[QueryParameterNames.EnableLanguageId] = \"true\";\n            }\n            this.setCommonUrlParams(config, queryParams, endpoint);\n            if (!endpoint) {\n                switch (config.recognitionMode) {\n                    case RecognitionMode.Conversation:\n                        if (config.parameters.getProperty(ForceDictationPropertyName, \"false\") === \"true\") {\n                            endpoint = host + this.dictationRelativeUri;\n                        }\n                        else {\n                            endpoint = host + this.conversationRelativeUri;\n                        }\n                        break;\n                    case RecognitionMode.Dictation:\n                        endpoint = host + this.dictationRelativeUri;\n                        break;\n                    default:\n                        endpoint = host + this.interactiveRelativeUri; // default is interactive\n                        break;\n                }\n            }\n            const headers = {};\n            if (authInfo.token !== undefined && authInfo.token !== \"\") {\n                headers[authInfo.headerName] = authInfo.token;\n            }\n            headers[HeaderNames.ConnectionId] = connectionId;\n            config.parameters.setProperty(PropertyId.SpeechServiceConnection_Url, endpoint);\n            const enableCompression = config.parameters.getProperty(\"SPEECH-EnableWebsocketCompression\", \"false\") === \"true\";\n            return new WebsocketConnection(endpoint, queryParams, headers, new WebsocketMessageFormatter(), ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);\n        };\n    }\n}\n\n//# sourceMappingURL=SpeechConnectionFactory.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ArgumentNullError, ConnectionMessage } from \"../common/Exports\";\nimport { HeaderNames } from \"./HeaderNames\";\nexport class SpeechConnectionMessage extends ConnectionMessage {\n    constructor(messageType, path, requestId, contentType, body, streamId, additionalHeaders, id) {\n        if (!path) {\n            throw new ArgumentNullError(\"path\");\n        }\n        if (!requestId) {\n            throw new ArgumentNullError(\"requestId\");\n        }\n        const headers = {};\n        headers[HeaderNames.Path] = path;\n        headers[HeaderNames.RequestId] = requestId;\n        headers[HeaderNames.RequestTimestamp] = new Date().toISOString();\n        if (contentType) {\n            headers[HeaderNames.ContentType] = contentType;\n        }\n        if (streamId) {\n            headers[HeaderNames.RequestStreamId] = streamId;\n        }\n        if (additionalHeaders) {\n            for (const headerName in additionalHeaders) {\n                if (headerName) {\n                    headers[headerName] = additionalHeaders[headerName];\n                }\n            }\n        }\n        if (id) {\n            super(messageType, body, headers, id);\n        }\n        else {\n            super(messageType, body, headers);\n        }\n        this.privPath = path;\n        this.privRequestId = requestId;\n        this.privContentType = contentType;\n        this.privStreamId = streamId;\n        this.privAdditionalHeaders = additionalHeaders;\n    }\n    get path() {\n        return this.privPath;\n    }\n    get requestId() {\n        return this.privRequestId;\n    }\n    get contentType() {\n        return this.privContentType;\n    }\n    get streamId() {\n        return this.privStreamId;\n    }\n    get additionalHeaders() {\n        return this.privAdditionalHeaders;\n    }\n}\nSpeechConnectionMessage.fromConnectionMessage = (message) => {\n    let path = null;\n    let requestId = null;\n    let contentType = null;\n    let requestTimestamp = null;\n    let streamId = null;\n    const additionalHeaders = {};\n    if (message.headers) {\n        for (const headerName in message.headers) {\n            if (headerName) {\n                if (headerName.toLowerCase() === HeaderNames.Path.toLowerCase()) {\n                    path = message.headers[headerName];\n                }\n                else if (headerName.toLowerCase() === HeaderNames.RequestId.toLowerCase()) {\n                    requestId = message.headers[headerName];\n                }\n                else if (headerName.toLowerCase() === HeaderNames.RequestTimestamp.toLowerCase()) {\n                    requestTimestamp = message.headers[headerName];\n                }\n                else if (headerName.toLowerCase() === HeaderNames.ContentType.toLowerCase()) {\n                    contentType = message.headers[headerName];\n                }\n                else if (headerName.toLowerCase() === HeaderNames.RequestStreamId.toLowerCase()) {\n                    streamId = message.headers[headerName];\n                }\n                else {\n                    additionalHeaders[headerName] = message.headers[headerName];\n                }\n            }\n        }\n    }\n    return new SpeechConnectionMessage(message.messageType, path, requestId, contentType, message.body, streamId, additionalHeaders, message.id);\n};\n\n//# sourceMappingURL=SpeechConnectionMessage.Internal.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Represents the JSON used in the speech.context message sent to the speech service.\n * The dynamic grammar is always refreshed from the encapsulated dynamic grammar object.\n */\nexport class SpeechContext {\n    constructor(dynamicGrammar) {\n        this.privContext = {};\n        this.privDynamicGrammar = dynamicGrammar;\n    }\n    /**\n     * Adds a section to the speech.context object.\n     * @param sectionName Name of the section to add.\n     * @param value JSON serializable object that represents the value.\n     */\n    setSection(sectionName, value) {\n        this.privContext[sectionName] = value;\n    }\n    /**\n     * @Internal\n     * This is only used by pronunciation assessment config.\n     * Do not use externally, object returned will change without warning or notice.\n     */\n    setPronunciationAssessmentParams(params) {\n        if (this.privContext.phraseDetection === undefined) {\n            this.privContext.phraseDetection = {\n                enrichment: {\n                    pronunciationAssessment: {}\n                }\n            };\n        }\n        this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(params);\n        if (this.privContext.phraseOutput === undefined) {\n            this.privContext.phraseOutput = {\n                detailed: {\n                    options: []\n                },\n                format: {}\n            };\n        }\n        this.privContext.phraseOutput.format = \"Detailed\";\n        this.privContext.phraseOutput.detailed.options.push(\"PronunciationAssessment\");\n        if (this.privContext.phraseOutput.detailed.options.indexOf(\"WordTimings\") === -1) {\n            this.privContext.phraseOutput.detailed.options.push(\"WordTimings\");\n        }\n        if (this.privContext.phraseOutput.detailed.options.indexOf(\"SNR\") === -1) {\n            this.privContext.phraseOutput.detailed.options.push(\"SNR\");\n        }\n    }\n    toJSON() {\n        const dgi = this.privDynamicGrammar.generateGrammarObject();\n        this.setSection(\"dgi\", dgi);\n        const ret = JSON.stringify(this.privContext);\n        return ret;\n    }\n}\n\n//# sourceMappingURL=SpeechContext.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=SpeechServiceInterfaces.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationErrorCode, OutputFormat, PropertyCollection, PropertyId, ResultReason, SpeechRecognitionCanceledEventArgs, SpeechRecognitionEventArgs, SpeechRecognitionResult, } from \"../sdk/Exports\";\nimport { CancellationErrorCodePropertyName, DetailedSpeechPhrase, EnumTranslation, OutputFormatPropertyName, RecognitionStatus, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechHypothesis, } from \"./Exports\";\n// tslint:disable-next-line:max-classes-per-file\nexport class SpeechServiceRecognizer extends ServiceRecognizerBase {\n    constructor(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer) {\n        super(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer);\n        this.privSpeechRecognizer = speechRecognizer;\n        if (recognizerConfig.autoDetectSourceLanguages !== undefined) {\n            const sourceLanguages = recognizerConfig.autoDetectSourceLanguages.split(\",\");\n            this.privSpeechContext.setSection(\"languageId\", {\n                languages: sourceLanguages,\n                onSuccess: { action: \"Recognize\" },\n                onUnknown: { action: \"None\" }\n            });\n            this.privSpeechContext.setSection(\"phraseOutput\", {\n                interimResults: {\n                    resultType: \"Auto\"\n                },\n                phraseResults: {\n                    resultType: \"Always\"\n                }\n            });\n        }\n    }\n    processTypeSpecificMessages(connectionMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result;\n            const resultProps = new PropertyCollection();\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n            let processed = false;\n            switch (connectionMessage.path.toLowerCase()) {\n                case \"speech.hypothesis\":\n                case \"speech.fragment\":\n                    const hypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n                    const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n                    result = new SpeechRecognitionResult(this.privRequestSession.requestId, ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, // Speaker Id\n                    undefined, connectionMessage.textBody, resultProps);\n                    this.privRequestSession.onHypothesis(offset);\n                    const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n                    if (!!this.privSpeechRecognizer.recognizing) {\n                        try {\n                            this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, ev);\n                            /* tslint:disable:no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    processed = true;\n                    break;\n                case \"speech.phrase\":\n                    const simple = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n                    const resultReason = EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);\n                    this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);\n                    if (ResultReason.Canceled === resultReason) {\n                        const cancelReason = EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);\n                        yield this.cancelRecognitionLocal(cancelReason, EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus), undefined);\n                    }\n                    else {\n                        if (!(this.privRequestSession.isSpeechEnded && resultReason === ResultReason.NoMatch && simple.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\n                            if (this.privRecognizerConfig.parameters.getProperty(OutputFormatPropertyName) === OutputFormat[OutputFormat.Simple]) {\n                                result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, undefined, // Speaker Id\n                                undefined, connectionMessage.textBody, resultProps);\n                            }\n                            else {\n                                const detailed = DetailedSpeechPhrase.fromJSON(connectionMessage.textBody);\n                                const totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;\n                                const offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);\n                                result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.RecognitionStatus === RecognitionStatus.Success ? detailed.NBest[0].Display : undefined, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, undefined, // Speaker Id\n                                undefined, offsetCorrectedJson, resultProps);\n                            }\n                            const event = new SpeechRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n                            if (!!this.privSpeechRecognizer.recognized) {\n                                try {\n                                    this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, event);\n                                    /* tslint:disable:no-empty */\n                                }\n                                catch (error) {\n                                    // Not going to let errors in the event handler\n                                    // trip things up.\n                                }\n                            }\n                        }\n                        if (!!this.privSuccessCallback) {\n                            try {\n                                this.privSuccessCallback(result);\n                            }\n                            catch (e) {\n                                if (!!this.privErrorCallback) {\n                                    this.privErrorCallback(e);\n                                }\n                            }\n                            // Only invoke the call back once.\n                            // and if it's successful don't invoke the\n                            // error after that.\n                            this.privSuccessCallback = undefined;\n                            this.privErrorCallback = undefined;\n                        }\n                    }\n                    processed = true;\n                    break;\n                default:\n                    break;\n            }\n            return processed;\n        });\n    }\n    // Cancels recognition.\n    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n        const properties = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        if (!!this.privSpeechRecognizer.canceled) {\n            const cancelEvent = new SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n            try {\n                this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, cancelEvent);\n                /* tslint:disable:no-empty */\n            }\n            catch (_a) { }\n        }\n        if (!!this.privSuccessCallback) {\n            const result = new SpeechRecognitionResult(requestId, ResultReason.Canceled, undefined, // Text\n            undefined, // Duration\n            undefined, // Offset\n            undefined, // Language\n            undefined, // Language Detection Confidence\n            undefined, // Speaker Id\n            error, undefined, // Json\n            properties);\n            try {\n                this.privSuccessCallback(result);\n                this.privSuccessCallback = undefined;\n                /* tslint:disable:no-empty */\n            }\n            catch (_b) { }\n        }\n    }\n}\n\n//# sourceMappingURL=SpeechServiceRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ProxyInfo, WebsocketConnection, } from \"../common.browser/Exports\";\nimport { PropertyId } from \"../sdk/Exports\";\nimport { WebsocketMessageFormatter } from \"./Exports\";\nimport { HeaderNames } from \"./HeaderNames\";\nimport { QueryParameterNames } from \"./QueryParameterNames\";\nexport class SpeechSynthesisConnectionFactory {\n    constructor() {\n        this.synthesisUri = \"/cognitiveservices/websocket/v1\";\n        this.create = (config, authInfo, connectionId) => {\n            let endpoint = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint, undefined);\n            const region = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Region, undefined);\n            const hostSuffix = (region && region.toLowerCase().startsWith(\"china\")) ? \".azure.cn\" : \".microsoft.com\";\n            const endpointId = config.parameters.getProperty(PropertyId.SpeechServiceConnection_EndpointId, undefined);\n            const hostPrefix = (endpointId === undefined) ? \"tts\" : \"voice\";\n            const host = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Host, \"wss://\" + region + \".\" + hostPrefix + \".speech\" + hostSuffix);\n            const queryParams = {};\n            if (!endpoint) {\n                endpoint = host + this.synthesisUri;\n            }\n            const headers = {};\n            if (authInfo.token !== undefined && authInfo.token !== \"\") {\n                headers[authInfo.headerName] = authInfo.token;\n            }\n            headers[HeaderNames.ConnectionId] = connectionId;\n            if (endpointId !== undefined) {\n                headers[QueryParameterNames.CustomVoiceDeploymentId] = endpointId;\n            }\n            config.parameters.setProperty(PropertyId.SpeechServiceConnection_Url, endpoint);\n            const enableCompression = config.parameters.getProperty(\"SPEECH-EnableWebsocketCompression\", \"false\") === \"true\";\n            return new WebsocketConnection(endpoint, queryParams, headers, new WebsocketMessageFormatter(), ProxyInfo.fromParameters(config.parameters), enableCompression, connectionId);\n        };\n    }\n}\n\n//# sourceMappingURL=SpeechSynthesisConnectionFactory.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ArgumentNullError, ConnectionState, createNoDashGuid, EventSource, MessageType, ServiceEvent, } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, SpeechSynthesisBookmarkEventArgs, SpeechSynthesisEventArgs, SpeechSynthesisResult, SpeechSynthesisVisemeEventArgs, SpeechSynthesisWordBoundaryEventArgs, } from \"../sdk/Exports\";\nimport { AgentConfig, CancellationErrorCodePropertyName, MetadataType, SynthesisAudioMetadata, SynthesisContext, SynthesisTurn } from \"./Exports\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class SynthesisAdapterBase {\n    constructor(authentication, connectionFactory, synthesizerConfig, speechSynthesizer, audioDestination) {\n        this.speakOverride = undefined;\n        this.receiveMessageOverride = undefined;\n        this.connectImplOverride = undefined;\n        this.configConnectionOverride = undefined;\n        this.sendSynthesisContext = (connection) => {\n            const synthesisContextJson = this.synthesisContext.toJSON();\n            if (synthesisContextJson) {\n                return connection.send(new SpeechConnectionMessage(MessageType.Text, \"synthesis.context\", this.privSynthesisTurn.requestId, \"application/json\", synthesisContextJson));\n            }\n            return;\n        };\n        this.sendSpeechServiceConfig = (connection, SpeechServiceConfigJson) => {\n            if (SpeechServiceConfigJson) {\n                return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.config\", this.privSynthesisTurn.requestId, \"application/json\", SpeechServiceConfigJson));\n            }\n        };\n        this.sendSsmlMessage = (connection, ssml, requestId) => {\n            return connection.send(new SpeechConnectionMessage(MessageType.Text, \"ssml\", requestId, \"application/ssml+xml\", ssml));\n        };\n        if (!authentication) {\n            throw new ArgumentNullError(\"authentication\");\n        }\n        if (!connectionFactory) {\n            throw new ArgumentNullError(\"connectionFactory\");\n        }\n        if (!synthesizerConfig) {\n            throw new ArgumentNullError(\"synthesizerConfig\");\n        }\n        this.privAuthentication = authentication;\n        this.privConnectionFactory = connectionFactory;\n        this.privSynthesizerConfig = synthesizerConfig;\n        this.privIsDisposed = false;\n        this.privSpeechSynthesizer = speechSynthesizer;\n        this.privSessionAudioDestination = audioDestination;\n        this.privSynthesisTurn = new SynthesisTurn();\n        this.privConnectionEvents = new EventSource();\n        this.privServiceEvents = new EventSource();\n        this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\n        this.privAgentConfig = new AgentConfig();\n        this.connectionEvents.attach((connectionEvent) => {\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\n                const connectionClosedEvent = connectionEvent;\n                if (connectionClosedEvent.statusCode !== 1000) {\n                    this.cancelSynthesisLocal(CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, connectionClosedEvent.reason + \" websocket error code: \" + connectionClosedEvent.statusCode);\n                }\n            }\n        });\n    }\n    get synthesisContext() {\n        return this.privSynthesisContext;\n    }\n    get agentConfig() {\n        return this.privAgentConfig;\n    }\n    get connectionEvents() {\n        return this.privConnectionEvents;\n    }\n    get serviceEvents() {\n        return this.privServiceEvents;\n    }\n    set activityTemplate(messagePayload) { this.privActivityTemplate = messagePayload; }\n    get activityTemplate() { return this.privActivityTemplate; }\n    set audioOutputFormat(format) {\n        this.privAudioOutputFormat = format;\n        this.privSynthesisTurn.audioOutputFormat = format;\n        if (this.privSessionAudioDestination !== undefined) {\n            this.privSessionAudioDestination.format = format;\n        }\n        if (this.synthesisContext !== undefined) {\n            this.synthesisContext.audioOutputFormat = format;\n        }\n    }\n    static addHeader(audio, format) {\n        if (!format.hasHeader) {\n            return audio;\n        }\n        format.updateHeader(audio.byteLength);\n        const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\n        tmp.set(new Uint8Array(format.header), 0);\n        tmp.set(new Uint8Array(audio), format.header.byteLength);\n        return tmp.buffer;\n    }\n    isDisposed() {\n        return this.privIsDisposed;\n    }\n    dispose(reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.privIsDisposed = true;\n            if (this.privSessionAudioDestination !== undefined) {\n                this.privSessionAudioDestination.close();\n            }\n            if (this.privConnectionConfigurationPromise) {\n                const connection = yield this.privConnectionConfigurationPromise;\n                yield connection.dispose(reason);\n            }\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.connectImpl();\n        });\n    }\n    sendNetworkMessage(path, payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const type = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n            const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n            const connection = yield this.fetchConnection();\n            return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\n        });\n    }\n    Speak(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let ssml;\n            if (isSSML) {\n                ssml = text;\n            }\n            else {\n                ssml = this.privSpeechSynthesizer.buildSsml(text);\n            }\n            if (this.speakOverride !== undefined) {\n                return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\n            }\n            this.privSuccessCallback = successCallback;\n            this.privErrorCallback = errorCallBack;\n            this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\n            try {\n                yield this.connectImpl();\n                const connection = yield this.fetchConnection();\n                yield this.sendSynthesisContext(connection);\n                yield this.sendSsmlMessage(connection, ssml, requestId);\n                const synthesisStartEventArgs = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(requestId, ResultReason.SynthesizingAudioStarted));\n                if (!!this.privSpeechSynthesizer.synthesisStarted) {\n                    this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\n                }\n                const messageRetrievalPromise = this.receiveMessage();\n            }\n            catch (e) {\n                this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e);\n                return Promise.reject(e);\n            }\n        });\n    }\n    // Cancels synthesis.\n    cancelSynthesis(requestId, cancellationReason, errorCode, error) {\n        const properties = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        const result = new SpeechSynthesisResult(requestId, ResultReason.Canceled, undefined, error, properties);\n        if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\n            const cancelEvent = new SpeechSynthesisEventArgs(result);\n            try {\n                this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\n                /* tslint:disable:no-empty */\n            }\n            catch (_a) { }\n        }\n        if (!!this.privSuccessCallback) {\n            try {\n                this.privSuccessCallback(result);\n                /* tslint:disable:no-empty */\n            }\n            catch (_b) { }\n        }\n    }\n    // Cancels synthesis.\n    cancelSynthesisLocal(cancellationReason, errorCode, error) {\n        if (!!this.privSynthesisTurn.isSynthesizing) {\n            this.privSynthesisTurn.onStopSynthesizing();\n            this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);\n        }\n    }\n    processTypeSpecificMessages(connectionMessage, successCallback, errorCallBack) {\n        return true;\n    }\n    receiveMessage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const connection = yield this.fetchConnection();\n                const message = yield connection.read();\n                if (this.receiveMessageOverride !== undefined) {\n                    return this.receiveMessageOverride();\n                }\n                if (this.privIsDisposed) {\n                    // We're done.\n                    return;\n                }\n                // indicates we are draining the queue and it came with no message;\n                if (!message) {\n                    if (!this.privSynthesisTurn.isSynthesizing) {\n                        return;\n                    }\n                    else {\n                        return this.receiveMessage();\n                    }\n                }\n                this.privServiceHasSentMessage = true;\n                const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n                if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\n                    switch (connectionMessage.path.toLowerCase()) {\n                        case \"turn.start\":\n                            this.privSynthesisTurn.onServiceTurnStartResponse();\n                            break;\n                        case \"response\":\n                            this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\n                            break;\n                        case \"audio\":\n                            if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase()\n                                && !!connectionMessage.binaryBody) {\n                                this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\n                                if (!!this.privSpeechSynthesizer.synthesizing) {\n                                    try {\n                                        const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\n                                        const ev = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudio, audioWithHeader));\n                                        this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\n                                    }\n                                    catch (error) {\n                                        // Not going to let errors in the event handler\n                                        // trip things up.\n                                    }\n                                }\n                                if (this.privSessionAudioDestination !== undefined) {\n                                    this.privSessionAudioDestination.write(connectionMessage.binaryBody);\n                                }\n                            }\n                            break;\n                        case \"audio.metadata\":\n                            const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\n                            for (const metadata of metadataList) {\n                                switch (metadata.Type) {\n                                    case MetadataType.WordBoundary:\n                                        this.privSynthesisTurn.onWordBoundaryEvent(metadata.Data.text.Text);\n                                        const wordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.text.Text, metadata.Data.text.Length, this.privSynthesisTurn.currentTextOffset);\n                                        if (!!this.privSpeechSynthesizer.wordBoundary) {\n                                            try {\n                                                this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\n                                            }\n                                            catch (error) {\n                                                // Not going to let errors in the event handler\n                                                // trip things up.\n                                            }\n                                        }\n                                        break;\n                                    case MetadataType.Bookmark:\n                                        const bookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);\n                                        if (!!this.privSpeechSynthesizer.bookmarkReached) {\n                                            try {\n                                                this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\n                                            }\n                                            catch (error) {\n                                                // Not going to let errors in the event handler\n                                                // trip things up.\n                                            }\n                                        }\n                                        break;\n                                    case MetadataType.Viseme:\n                                        this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\n                                        if (metadata.Data.IsLastAnimation) {\n                                            const visemeEventArgs = new SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());\n                                            if (!!this.privSpeechSynthesizer.visemeReceived) {\n                                                try {\n                                                    this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\n                                                }\n                                                catch (error) {\n                                                    // Not going to let errors in the event handler\n                                                    // trip things up.\n                                                }\n                                            }\n                                        }\n                                        break;\n                                }\n                            }\n                            break;\n                        case \"turn.end\":\n                            this.privSynthesisTurn.onServiceTurnEndResponse();\n                            let result;\n                            try {\n                                const audioBuffer = yield this.privSynthesisTurn.getAllReceivedAudioWithHeader();\n                                result = new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudioCompleted, audioBuffer);\n                                if (!!this.privSuccessCallback) {\n                                    this.privSuccessCallback(result);\n                                }\n                            }\n                            catch (error) {\n                                if (!!this.privErrorCallback) {\n                                    this.privErrorCallback(error);\n                                }\n                            }\n                            if (this.privSpeechSynthesizer.synthesisCompleted) {\n                                try {\n                                    this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new SpeechSynthesisEventArgs(result));\n                                }\n                                catch (e) {\n                                    // Not going to let errors in the event handler\n                                    // trip things up.\n                                }\n                            }\n                            break;\n                        default:\n                            if (!this.processTypeSpecificMessages(connectionMessage)) {\n                                // here are some messages that the derived class has not processed, dispatch them to connect class\n                                if (!!this.privServiceEvents) {\n                                    this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                                }\n                            }\n                    }\n                }\n                return this.receiveMessage();\n            }\n            catch (e) {\n                // TODO: What goes here?\n            }\n        });\n    }\n    connectImpl(isUnAuthorized = false) {\n        if (this.privConnectionPromise) {\n            return this.privConnectionPromise.then((connection) => {\n                if (connection.state() === ConnectionState.Disconnected) {\n                    this.privConnectionId = null;\n                    this.privConnectionPromise = null;\n                    this.privServiceHasSentMessage = false;\n                    return this.connectImpl();\n                }\n                return this.privConnectionPromise;\n            }, (error) => {\n                this.privConnectionId = null;\n                this.privConnectionPromise = null;\n                this.privServiceHasSentMessage = false;\n                return this.connectImpl();\n            });\n        }\n        this.privAuthFetchEventId = createNoDashGuid();\n        this.privConnectionId = createNoDashGuid();\n        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n        this.privConnectionPromise = authPromise.then((result) => __awaiter(this, void 0, void 0, function* () {\n            yield this.privSynthesisTurn.onAuthCompleted(false);\n            const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n            // it'll stop sending events.\n            connection.events.attach((event) => {\n                this.connectionEvents.onEvent(event);\n            });\n            const response = yield connection.open();\n            if (response.statusCode === 200) {\n                yield this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n                return Promise.resolve(connection);\n            }\n            else if (response.statusCode === 403 && !isUnAuthorized) {\n                return this.connectImpl(true);\n            }\n            else {\n                yield this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode, response.reason);\n                return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n            }\n        }), (error) => __awaiter(this, void 0, void 0, function* () {\n            yield this.privSynthesisTurn.onAuthCompleted(true, error);\n            throw new Error(error);\n        }));\n        // Attach an empty handler to allow the promise to run in the background while\n        // other startup events happen. It'll eventually be awaited on.\n        this.privConnectionPromise.catch(() => { });\n        return this.privConnectionPromise;\n    }\n    fetchConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privConnectionConfigurationPromise) {\n                return this.privConnectionConfigurationPromise.then((connection) => {\n                    if (connection.state() === ConnectionState.Disconnected) {\n                        this.privConnectionId = null;\n                        this.privConnectionConfigurationPromise = null;\n                        this.privServiceHasSentMessage = false;\n                        return this.fetchConnection();\n                    }\n                    return this.privConnectionConfigurationPromise;\n                }, (error) => {\n                    this.privConnectionId = null;\n                    this.privConnectionConfigurationPromise = null;\n                    this.privServiceHasSentMessage = false;\n                    return this.fetchConnection();\n                });\n            }\n            this.privConnectionConfigurationPromise = this.configureConnection();\n            return yield this.privConnectionConfigurationPromise;\n        });\n    }\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\n    configureConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.connectImpl();\n            if (this.configConnectionOverride !== undefined) {\n                return this.configConnectionOverride(connection);\n            }\n            yield this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\n            return connection;\n        });\n    }\n}\nSynthesisAdapterBase.telemetryDataEnabled = true;\n\n//# sourceMappingURL=SynthesisAdapterBase.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Represents the JSON used in the synthesis.context message sent to the speech service.\n * The dynamic grammar is always refreshed from the encapsulated dynamic grammar object.\n */\nexport class SynthesisContext {\n    constructor(speechSynthesizer) {\n        this.privContext = {};\n        this.privSpeechSynthesizer = speechSynthesizer;\n    }\n    /**\n     * Adds a section to the synthesis.context object.\n     * @param sectionName Name of the section to add.\n     * @param value JSON serializable object that represents the value.\n     */\n    setSection(sectionName, value) {\n        this.privContext[sectionName] = value;\n    }\n    /**\n     * Sets the audio output format for synthesis context generation.\n     * @param format {AudioOutputFormatImpl} the output format\n     */\n    set audioOutputFormat(format) {\n        this.privAudioOutputFormat = format;\n    }\n    toJSON() {\n        const synthesisSection = this.buildSynthesisContext();\n        this.setSection(\"synthesis\", synthesisSection);\n        return JSON.stringify(this.privContext);\n    }\n    buildSynthesisContext() {\n        return {\n            audio: {\n                metadataOptions: {\n                    bookmarkEnabled: (!!this.privSpeechSynthesizer.bookmarkReached),\n                    sentenceBoundaryEnabled: false,\n                    visemeEnabled: (!!this.privSpeechSynthesizer.visemeReceived),\n                    wordBoundaryEnabled: (!!this.privSpeechSynthesizer.wordBoundary),\n                },\n                outputFormat: this.privAudioOutputFormat.requestAudioFormatString,\n            },\n            language: {\n                autoDetection: this.privSpeechSynthesizer.autoDetectSourceLanguage\n            }\n        };\n    }\n}\n\n//# sourceMappingURL=SynthesisContext.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// tslint:disable:max-classes-per-file\nimport { EventType, PlatformEvent } from \"../common/Exports\";\nexport class SpeechSynthesisEvent extends PlatformEvent {\n    constructor(eventName, requestId, eventType = EventType.Info) {\n        super(eventName, eventType);\n        this.privRequestId = requestId;\n    }\n    get requestId() {\n        return this.privRequestId;\n    }\n}\nexport class SynthesisTriggeredEvent extends SpeechSynthesisEvent {\n    constructor(requestId, sessionAudioDestinationId, turnAudioDestinationId) {\n        super(\"SynthesisTriggeredEvent\", requestId);\n        this.privSessionAudioDestinationId = sessionAudioDestinationId;\n        this.privTurnAudioDestinationId = turnAudioDestinationId;\n    }\n    get audioSessionDestinationId() {\n        return this.privSessionAudioDestinationId;\n    }\n    get audioTurnDestinationId() {\n        return this.privTurnAudioDestinationId;\n    }\n}\nexport class ConnectingToSynthesisServiceEvent extends SpeechSynthesisEvent {\n    constructor(requestId, authFetchEventId) {\n        super(\"ConnectingToSynthesisServiceEvent\", requestId);\n        this.privAuthFetchEventId = authFetchEventId;\n    }\n    get authFetchEventId() {\n        return this.privAuthFetchEventId;\n    }\n}\nexport class SynthesisStartedEvent extends SpeechSynthesisEvent {\n    constructor(requestId, authFetchEventId) {\n        super(\"SynthesisStartedEvent\", requestId);\n        this.privAuthFetchEventId = authFetchEventId;\n    }\n    get authFetchEventId() {\n        return this.privAuthFetchEventId;\n    }\n}\n\n//# sourceMappingURL=SynthesisEvents.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { createNoDashGuid, Deferred, Events } from \"../common/Exports\";\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\nimport { SynthesisAdapterBase } from \"./SynthesisAdapterBase\";\nimport { ConnectingToSynthesisServiceEvent, SynthesisStartedEvent, SynthesisTriggeredEvent, } from \"./SynthesisEvents\";\nexport class SynthesisTurn {\n    constructor() {\n        this.privIsDisposed = false;\n        this.privIsSynthesizing = false;\n        this.privIsSynthesisEnded = false;\n        this.privBytesReceived = 0;\n        this.privInTurn = false;\n        this.privTextOffset = 0;\n        this.privNextSearchTextIndex = 0;\n        this.onPreConnectionStart = (authFetchEventId, connectionId) => {\n            this.privAuthFetchEventId = authFetchEventId;\n            this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\n        };\n        this.onAuthCompleted = (isError, error) => {\n            if (isError) {\n                this.onComplete();\n            }\n        };\n        this.onConnectionEstablishCompleted = (statusCode, reason) => {\n            if (statusCode === 200) {\n                this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\n                this.privBytesReceived = 0;\n                return;\n            }\n            else if (statusCode === 403) {\n                this.onComplete();\n            }\n        };\n        this.onServiceResponseMessage = (responseJson) => {\n            const response = JSON.parse(responseJson);\n            this.streamId = response.audio.streamId;\n        };\n        this.onServiceTurnEndResponse = () => {\n            this.privInTurn = false;\n            this.privTurnDeferral.resolve();\n            this.onComplete();\n        };\n        this.onServiceTurnStartResponse = () => {\n            if (!!this.privTurnDeferral && !!this.privInTurn) {\n                // What? How are we starting a turn with another not done?\n                this.privTurnDeferral.reject(\"Another turn started before current completed.\");\n                // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n                /* tslint:disable:no-empty */\n                this.privTurnDeferral.promise.then().catch(() => { });\n            }\n            this.privInTurn = true;\n            this.privTurnDeferral = new Deferred();\n        };\n        this.dispose = (error) => {\n            if (!this.privIsDisposed) {\n                // we should have completed by now. If we did not its an unknown error.\n                this.privIsDisposed = true;\n            }\n        };\n        this.onEvent = (event) => {\n            Events.instance.onEvent(event);\n        };\n        this.onComplete = () => {\n            if (this.privIsSynthesizing) {\n                this.privIsSynthesizing = false;\n                this.privIsSynthesisEnded = true;\n                this.privAudioOutputStream.close();\n                this.privInTurn = false;\n                if (this.privTurnAudioDestination !== undefined) {\n                    this.privTurnAudioDestination.close();\n                    this.privTurnAudioDestination = undefined;\n                }\n            }\n        };\n        this.privRequestId = createNoDashGuid();\n        this.privTurnDeferral = new Deferred();\n        // We're not in a turn, so resolve.\n        this.privTurnDeferral.resolve();\n    }\n    get requestId() {\n        return this.privRequestId;\n    }\n    get streamId() {\n        return this.privStreamId;\n    }\n    set streamId(value) {\n        this.privStreamId = value;\n    }\n    get audioOutputFormat() {\n        return this.privAudioOutputFormat;\n    }\n    set audioOutputFormat(format) {\n        this.privAudioOutputFormat = format;\n    }\n    get turnCompletionPromise() {\n        return this.privTurnDeferral.promise;\n    }\n    get isSynthesisEnded() {\n        return this.privIsSynthesisEnded;\n    }\n    get isSynthesizing() {\n        return this.privIsSynthesizing;\n    }\n    get currentTextOffset() {\n        return this.privTextOffset;\n    }\n    // The number of bytes received for current turn\n    get bytesReceived() {\n        return this.privBytesReceived;\n    }\n    getAllReceivedAudio() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!!this.privReceivedAudio) {\n                return Promise.resolve(this.privReceivedAudio);\n            }\n            if (!this.privIsSynthesisEnded) {\n                return null;\n            }\n            yield this.readAllAudioFromStream();\n            return Promise.resolve(this.privReceivedAudio);\n        });\n    }\n    getAllReceivedAudioWithHeader() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!!this.privReceivedAudioWithHeader) {\n                return this.privReceivedAudioWithHeader;\n            }\n            if (!this.privIsSynthesisEnded) {\n                return null;\n            }\n            if (this.audioOutputFormat.hasHeader) {\n                const audio = yield this.getAllReceivedAudio();\n                this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);\n                return this.privReceivedAudioWithHeader;\n            }\n            else {\n                return this.getAllReceivedAudio();\n            }\n        });\n    }\n    startNewSynthesis(requestId, rawText, isSSML, audioDestination) {\n        this.privIsSynthesisEnded = false;\n        this.privIsSynthesizing = true;\n        this.privRequestId = requestId;\n        this.privRawText = rawText;\n        this.privIsSSML = isSSML;\n        this.privAudioOutputStream = new PullAudioOutputStreamImpl();\n        this.privAudioOutputStream.format = this.privAudioOutputFormat;\n        this.privReceivedAudio = null;\n        this.privReceivedAudioWithHeader = null;\n        this.privBytesReceived = 0;\n        this.privTextOffset = 0;\n        this.privNextSearchTextIndex = 0;\n        this.privPartialVisemeAnimation = \"\";\n        if (audioDestination !== undefined) {\n            this.privTurnAudioDestination = audioDestination;\n            this.privTurnAudioDestination.format = this.privAudioOutputFormat;\n        }\n        this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\n    }\n    onAudioChunkReceived(data) {\n        if (this.isSynthesizing) {\n            this.privAudioOutputStream.write(data);\n            this.privBytesReceived += data.byteLength;\n            if (this.privTurnAudioDestination !== undefined) {\n                this.privTurnAudioDestination.write(data);\n            }\n        }\n    }\n    onWordBoundaryEvent(text) {\n        this.updateTextOffset(text);\n    }\n    onVisemeMetadataReceived(metadata) {\n        if (metadata.Data.AnimationChunk !== undefined) {\n            this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\n        }\n    }\n    onStopSynthesizing() {\n        this.onComplete();\n    }\n    /**\n     * Gets the viseme animation string (merged from animation chunk), and clears the internal\n     * partial animation.\n     */\n    getAndClearVisemeAnimation() {\n        const animation = this.privPartialVisemeAnimation;\n        this.privPartialVisemeAnimation = \"\";\n        return animation;\n    }\n    updateTextOffset(text) {\n        if (this.privTextOffset >= 0) {\n            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\n            if (this.privTextOffset >= 0) {\n                this.privNextSearchTextIndex = this.privTextOffset + text.length;\n            }\n            if (this.privIsSSML) {\n                if (this.privRawText.indexOf(\"<\", this.privTextOffset + 1) > this.privRawText.indexOf(\">\", this.privTextOffset + 1)) {\n                    this.updateTextOffset(text);\n                }\n            }\n        }\n    }\n    readAllAudioFromStream() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privIsSynthesisEnded) {\n                this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\n                try {\n                    yield this.privAudioOutputStream.read(this.privReceivedAudio);\n                }\n                catch (e) {\n                    this.privReceivedAudio = new ArrayBuffer(0);\n                }\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=SynthesisTurn.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Context, SpeechServiceConfig } from \"./Exports\";\nexport var SynthesisServiceType;\n(function (SynthesisServiceType) {\n    SynthesisServiceType[SynthesisServiceType[\"Standard\"] = 0] = \"Standard\";\n    SynthesisServiceType[SynthesisServiceType[\"Custom\"] = 1] = \"Custom\";\n})(SynthesisServiceType || (SynthesisServiceType = {}));\nexport class SynthesizerConfig {\n    constructor(speechServiceConfig, parameters) {\n        this.privSynthesisServiceType = SynthesisServiceType.Standard;\n        this.privSpeechServiceConfig = speechServiceConfig ? speechServiceConfig : new SpeechServiceConfig(new Context(null));\n        this.privParameters = parameters;\n    }\n    get parameters() {\n        return this.privParameters;\n    }\n    get synthesisServiceType() {\n        return this.privSynthesisServiceType;\n    }\n    set synthesisServiceType(value) {\n        this.privSynthesisServiceType = value;\n    }\n    get SpeechServiceConfig() {\n        return this.privSpeechServiceConfig;\n    }\n}\n\n//# sourceMappingURL=SynthesizerConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ProxyInfo, WebsocketConnection, } from \"../common.browser/Exports\";\nimport { PropertyId } from \"../sdk/Exports\";\nimport { ConnectionFactoryBase } from \"./ConnectionFactoryBase\";\nimport { WebsocketMessageFormatter } from \"./Exports\";\nimport { HeaderNames } from \"./HeaderNames\";\nimport { QueryParameterNames } from \"./QueryParameterNames\";\nexport class TranscriberConnectionFactory extends ConnectionFactoryBase {\n    constructor() {\n        super(...arguments);\n        this.multiaudioRelativeUri = \"/speech/recognition/multiaudio\";\n        this.create = (config, authInfo, connectionId) => {\n            let endpoint = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint, undefined);\n            const region = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Region, \"centralus\");\n            const hostSuffix = (region && region.toLowerCase().startsWith(\"china\")) ? \".azure.cn\" : \".microsoft.com\";\n            const hostDefault = \"wss://transcribe.\" + region + \".cts.speech\" + hostSuffix + this.multiaudioRelativeUri;\n            const host = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Host, hostDefault);\n            const queryParams = {};\n            const endpointId = config.parameters.getProperty(PropertyId.SpeechServiceConnection_EndpointId, undefined);\n            const language = config.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, undefined);\n            if (endpointId) {\n                if (!endpoint || endpoint.search(QueryParameterNames.CustomSpeechDeploymentId) === -1) {\n                    queryParams[QueryParameterNames.CustomSpeechDeploymentId] = endpointId;\n                }\n            }\n            else if (language) {\n                if (!endpoint || endpoint.search(QueryParameterNames.Language) === -1) {\n                    queryParams[QueryParameterNames.Language] = language;\n                }\n            }\n            this.setCommonUrlParams(config, queryParams, endpoint);\n            if (!endpoint) {\n                endpoint = host;\n            }\n            const headers = {};\n            if (authInfo.token !== undefined && authInfo.token !== \"\") {\n                headers[authInfo.headerName] = authInfo.token;\n            }\n            headers[HeaderNames.ConnectionId] = connectionId;\n            config.parameters.setProperty(PropertyId.SpeechServiceConnection_Url, endpoint);\n            const enableCompression = config.parameters.getProperty(\"SPEECH-EnableWebsocketCompression\", \"false\") === \"true\";\n            return new WebsocketConnection(endpoint, queryParams, headers, new WebsocketMessageFormatter(), ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);\n        };\n    }\n}\n\n//# sourceMappingURL=TranscriberConnectionFactory.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RestConfigBase } from \"../../common.browser/RestConfigBase\";\nexport class ConversationConnectionConfig extends RestConfigBase {\n    static get host() {\n        return ConversationConnectionConfig.privHost;\n    }\n    static get apiVersion() {\n        return ConversationConnectionConfig.privApiVersion;\n    }\n    static get clientAppId() {\n        return ConversationConnectionConfig.privClientAppId;\n    }\n    static get defaultLanguageCode() {\n        return ConversationConnectionConfig.privDefaultLanguageCode;\n    }\n    static get restPath() {\n        return ConversationConnectionConfig.privRestPath;\n    }\n    static get webSocketPath() {\n        return ConversationConnectionConfig.privWebSocketPath;\n    }\n    static get speechHost() {\n        return ConversationConnectionConfig.privSpeechHost;\n    }\n    static get speechPath() {\n        return ConversationConnectionConfig.privSpeechPath;\n    }\n    static get transcriptionEventKeys() {\n        return ConversationConnectionConfig.privTranscriptionEventKeys;\n    }\n}\nConversationConnectionConfig.privHost = \"dev.microsofttranslator.com\";\nConversationConnectionConfig.privRestPath = \"/capito/room\";\nConversationConnectionConfig.privApiVersion = \"2.0\";\nConversationConnectionConfig.privDefaultLanguageCode = \"en-US\";\nConversationConnectionConfig.privClientAppId = \"FC539C22-1767-4F1F-84BC-B4D811114F15\";\nConversationConnectionConfig.privWebSocketPath = \"/capito/translate\";\nConversationConnectionConfig.privSpeechHost = \"{region}.s2s.speech.microsoft.com\";\nConversationConnectionConfig.privSpeechPath = \"/speech/translation/cognitiveservices/v1\";\nConversationConnectionConfig.privTranscriptionEventKeys = [\"iCalUid\", \"callId\", \"organizer\", \"FLAC\", \"MTUri\", \"DifferenciateGuestSpeakers\", \"audiorecording\", \"Threadid\", \"OrganizerMri\", \"OrganizerTenantId\", \"UserToken\"];\n\n//# sourceMappingURL=ConversationConnectionConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ProxyInfo, WebsocketConnection } from \"../../common.browser/Exports\";\nimport { createGuid } from \"../../common/Exports\";\nimport { Contracts } from \"../../sdk/Contracts\";\nimport { PropertyId } from \"../../sdk/Exports\";\nimport { ConnectionFactoryBase } from \"../ConnectionFactoryBase\";\nimport { ConversationConnectionConfig } from \"./ConversationConnectionConfig\";\nimport { ConversationWebsocketMessageFormatter } from \"./ConversationWebsocketMessageFormatter\";\n/**\n * Create a connection to the Conversation Translator websocket for sending instant messages and commands, and for receiving translated messages.\n * The conversation must already have been started or joined.\n */\nexport class ConversationConnectionFactory extends ConnectionFactoryBase {\n    create(config, authInfo, connectionId) {\n        const endpointHost = config.parameters.getProperty(PropertyId.ConversationTranslator_Host, ConversationConnectionConfig.host);\n        const correlationId = config.parameters.getProperty(PropertyId.ConversationTranslator_CorrelationId, createGuid());\n        const endpoint = `wss://${endpointHost}${ConversationConnectionConfig.webSocketPath}`;\n        const token = config.parameters.getProperty(PropertyId.ConversationTranslator_Token, undefined);\n        Contracts.throwIfNullOrUndefined(token, \"token\");\n        const queryParams = {};\n        queryParams[ConversationConnectionConfig.configParams.apiVersion] = ConversationConnectionConfig.apiVersion;\n        queryParams[ConversationConnectionConfig.configParams.token] = token;\n        queryParams[ConversationConnectionConfig.configParams.correlationId] = correlationId;\n        const enableCompression = config.parameters.getProperty(\"SPEECH-EnableWebsocketCompression\", \"false\") === \"true\";\n        return new WebsocketConnection(endpoint, queryParams, {}, new ConversationWebsocketMessageFormatter(), ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);\n    }\n}\n\n//# sourceMappingURL=ConversationConnectionFactory.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ConnectionMessage } from \"../../common/Exports\";\nexport class ConversationConnectionMessage extends ConnectionMessage {\n    constructor(messageType, body, headers, id) {\n        super(messageType, body, headers, id);\n        const json = JSON.parse(this.textBody);\n        if (json.type !== undefined) {\n            this.privConversationMessageType = json.type;\n        }\n    }\n    get conversationMessageType() {\n        return this.privConversationMessageType;\n    }\n}\n\n//# sourceMappingURL=ConversationConnectionMessage.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RestMessageAdapter, RestRequestType } from \"../../common.browser/Exports\";\nimport { Contracts } from \"../../sdk/Contracts\";\nimport { PropertyId } from \"../../sdk/Exports\";\nimport { ConversationConnectionConfig } from \"./ConversationConnectionConfig\";\nexport class ConversationManager {\n    constructor() {\n        //\n        this.privRequestParams = ConversationConnectionConfig.configParams;\n        this.privErrors = ConversationConnectionConfig.restErrors;\n        this.privHost = ConversationConnectionConfig.host;\n        this.privApiVersion = ConversationConnectionConfig.apiVersion;\n        this.privRestPath = ConversationConnectionConfig.restPath;\n        this.privRestAdapter = new RestMessageAdapter({});\n    }\n    /**\n     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.\n     * @param args\n     * @param conversationCode\n     * @param callback\n     * @param errorCallback\n     */\n    createOrJoin(args, conversationCode, cb, err) {\n        try {\n            Contracts.throwIfNullOrUndefined(args, \"args\");\n            const languageCode = args.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, ConversationConnectionConfig.defaultLanguageCode);\n            const nickname = args.getProperty(PropertyId.ConversationTranslator_Name);\n            const endpointHost = args.getProperty(PropertyId.ConversationTranslator_Host, this.privHost);\n            const correlationId = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\n            const subscriptionKey = args.getProperty(PropertyId.SpeechServiceConnection_Key);\n            const subscriptionRegion = args.getProperty(PropertyId.SpeechServiceConnection_Region);\n            const authToken = args.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n            Contracts.throwIfNullOrWhitespace(languageCode, \"languageCode\");\n            Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\n            Contracts.throwIfNullOrWhitespace(endpointHost, \"endpointHost\");\n            const queryParams = {};\n            queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;\n            queryParams[this.privRequestParams.languageCode] = languageCode;\n            queryParams[this.privRequestParams.nickname] = nickname;\n            const headers = {};\n            if (correlationId) {\n                headers[this.privRequestParams.correlationId] = correlationId;\n            }\n            headers[this.privRequestParams.clientAppId] = ConversationConnectionConfig.clientAppId;\n            if (conversationCode !== undefined) {\n                queryParams[this.privRequestParams.roomId] = conversationCode;\n            }\n            else {\n                Contracts.throwIfNullOrUndefined(subscriptionRegion, this.privErrors.authInvalidSubscriptionRegion);\n                headers[this.privRequestParams.subscriptionRegion] = subscriptionRegion;\n                if (subscriptionKey) {\n                    headers[this.privRequestParams.subscriptionKey] = subscriptionKey;\n                }\n                else if (authToken) {\n                    headers[this.privRequestParams.authorization] = `Bearer ${authToken}`;\n                }\n                else {\n                    Contracts.throwIfNullOrUndefined(subscriptionKey, this.privErrors.authInvalidSubscriptionKey);\n                }\n            }\n            const config = {};\n            config.headers = headers;\n            this.privRestAdapter.options = config;\n            const endpoint = `https://${endpointHost}${this.privRestPath}`;\n            // TODO: support a proxy and certificate validation\n            this.privRestAdapter.request(RestRequestType.Post, endpoint, queryParams, null).then((response) => {\n                const requestId = RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, response.headers);\n                if (!response.ok) {\n                    if (!!err) {\n                        // get the error\n                        let errorMessage = this.privErrors.invalidCreateJoinConversationResponse.replace(\"{status}\", response.status.toString());\n                        let errMessageRaw;\n                        try {\n                            errMessageRaw = JSON.parse(response.data);\n                            errorMessage += ` [${errMessageRaw.error.code}: ${errMessageRaw.error.message}]`;\n                        }\n                        catch (e) {\n                            errorMessage += ` [${response.data}]`;\n                        }\n                        if (requestId) {\n                            errorMessage += ` ${requestId}`;\n                        }\n                        err(errorMessage);\n                    }\n                    return;\n                }\n                const conversation = JSON.parse(response.data);\n                if (conversation) {\n                    conversation.requestId = requestId;\n                }\n                if (!!cb) {\n                    try {\n                        cb(conversation);\n                    }\n                    catch (e) {\n                        if (!!err) {\n                            err(e);\n                        }\n                    }\n                    cb = undefined;\n                }\n                /* tslint:disable:no-empty */\n            }).catch((e) => { });\n        }\n        catch (error) {\n            if (!!err) {\n                if (error instanceof Error) {\n                    const typedError = error;\n                    err(typedError.name + \": \" + typedError.message);\n                }\n                else {\n                    err(error);\n                }\n            }\n        }\n    }\n    /**\n     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.\n     * @param args\n     * @param sessionToken\n     * @param callback\n     */\n    leave(args, sessionToken) {\n        return new Promise((resolve, reject) => {\n            try {\n                Contracts.throwIfNullOrUndefined(args, this.privErrors.invalidArgs.replace(\"{arg}\", \"config\"));\n                Contracts.throwIfNullOrWhitespace(sessionToken, this.privErrors.invalidArgs.replace(\"{arg}\", \"token\"));\n                const endpointHost = args.getProperty(PropertyId.ConversationTranslator_Host, this.privHost);\n                const correlationId = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\n                const queryParams = {};\n                queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;\n                queryParams[this.privRequestParams.sessionToken] = sessionToken;\n                const headers = {};\n                if (correlationId) {\n                    headers[this.privRequestParams.correlationId] = correlationId;\n                }\n                const config = {};\n                config.headers = headers;\n                this.privRestAdapter.options = config;\n                const endpoint = `https://${endpointHost}${this.privRestPath}`;\n                // TODO: support a proxy and certificate validation\n                this.privRestAdapter.request(RestRequestType.Delete, endpoint, queryParams, null).then((response) => {\n                    if (!response.ok) {\n                        // ignore errors on delete\n                    }\n                    resolve();\n                    /* tslint:disable:no-empty */\n                }).catch((e) => { });\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    const typedError = error;\n                    reject(typedError.name + \": \" + typedError.message);\n                }\n                else {\n                    reject(error);\n                }\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=ConversationManager.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { createNoDashGuid, Deferred, } from \"../../common/Exports\";\n/**\n * Placeholder class for the Conversation Request Session. Based off RequestSession.\n * TODO: define what telemetry is required.\n */\nexport class ConversationRequestSession {\n    constructor(sessionId) {\n        this.privIsDisposed = false;\n        this.privDetachables = new Array();\n        this.onPreConnectionStart = (authFetchEventId, connectionId) => {\n            this.privSessionId = connectionId;\n        };\n        this.onAuthCompleted = (isError, error) => {\n            if (isError) {\n                this.onComplete();\n            }\n        };\n        this.onConnectionEstablishCompleted = (statusCode, reason) => {\n            if (statusCode === 200) {\n                return;\n            }\n            else if (statusCode === 403) {\n                this.onComplete();\n            }\n        };\n        this.onServiceTurnEndResponse = (continuousRecognition) => {\n            if (!continuousRecognition) {\n                this.onComplete();\n            }\n            else {\n                this.privRequestId = createNoDashGuid();\n            }\n        };\n        this.onComplete = () => {\n            //\n        };\n        this.privSessionId = sessionId;\n        this.privRequestId = createNoDashGuid();\n        this.privRequestCompletionDeferral = new Deferred();\n    }\n    get sessionId() {\n        return this.privSessionId;\n    }\n    get requestId() {\n        return this.privRequestId;\n    }\n    get completionPromise() {\n        return this.privRequestCompletionDeferral.promise;\n    }\n    dispose(error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.privIsDisposed) {\n                // we should have completed by now. If we did not its an unknown error.\n                this.privIsDisposed = true;\n                for (const detachable of this.privDetachables) {\n                    yield detachable.detach();\n                }\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=ConversationRequestSession.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionState, createNoDashGuid, Deferred, MessageType, } from \"../../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, ConversationExpirationEventArgs, ConversationTranslationCanceledEventArgs, ConversationTranslationResult, Translations } from \"../../sdk/Exports\";\nimport { CognitiveTokenAuthentication, ServiceRecognizerBase } from \"../Exports\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\nimport { ConversationReceivedTranslationEventArgs, LockRoomEventArgs, MuteAllEventArgs, ParticipantAttributeEventArgs, ParticipantEventArgs, ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs\";\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes } from \"./ConversationTranslatorInterfaces\";\nimport { CommandResponsePayload, ParticipantPayloadResponse, ParticipantsListPayloadResponse, SpeechResponsePayload, TextResponsePayload } from \"./ServiceMessages/Exports\";\n/***\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\n    constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\n        this.privLastPartialUtteranceId = \"\";\n        this.noOp = () => {\n            // operation not supported\n        };\n        this.privConversationServiceConnector = conversationServiceConnector;\n        this.privConversationAuthentication = authentication;\n        this.receiveMessageOverride = this.receiveConversationMessageOverride;\n        this.recognizeOverride = this.noOp;\n        this.postConnectImplOverride = this.conversationConnectImpl;\n        this.configConnectionOverride = this.configConnection;\n        this.disconnectOverride = this.privDisconnect;\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\n        this.privConversationConnectionFactory = connectionFactory;\n        this.privConversationIsDisposed = false;\n    }\n    isDisposed() {\n        return super.isDisposed() || this.privConversationIsDisposed;\n    }\n    dispose(reason) {\n        const _super = Object.create(null, {\n            dispose: { get: () => super.dispose }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            this.privConversationIsDisposed = true;\n            if (this.privConnectionConfigPromise) {\n                const connection = yield this.privConnectionConfigPromise;\n                yield connection.dispose(reason);\n            }\n            yield _super.dispose.call(this, reason);\n        });\n    }\n    sendMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.fetchConnection();\n            return connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n        });\n    }\n    sendMessageAsync(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const sink = new Deferred();\n            const connection = yield this.fetchConnection();\n            yield connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n        });\n    }\n    privDisconnect() {\n        if (this.terminateMessageLoop) {\n            return;\n        }\n        this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n        this.terminateMessageLoop = true;\n        return Promise.resolve();\n    }\n    processTypeSpecificMessages(connectionMessage, successCallback, errorCallBack) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return true;\n        });\n    }\n    // Cancels recognition.\n    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n        this.terminateMessageLoop = true;\n        const cancelEvent = new ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n        try {\n            if (!!this.privConversationServiceConnector.canceled) {\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n            }\n        }\n        catch (_a) {\n            // continue on error\n        }\n    }\n    /**\n     * Establishes a websocket connection to the end point.\n     */\n    conversationConnectImpl(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.privConnectionLoop = this.startMessageLoop();\n            return connection;\n        });\n    }\n    /**\n     * Process incoming websocket messages\n     */\n    receiveConversationMessageOverride() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isDisposed() || this.terminateMessageLoop) {\n                return Promise.resolve();\n            }\n            // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n            const communicationCustodian = new Deferred();\n            try {\n                const connection = yield this.fetchConnection();\n                const message = yield connection.read();\n                if (this.isDisposed() || this.terminateMessageLoop) {\n                    // We're done.\n                    communicationCustodian.resolve();\n                    return Promise.resolve();\n                }\n                if (!message) {\n                    return this.receiveConversationMessageOverride();\n                }\n                const sessionId = this.privConversationRequestSession.sessionId;\n                let sendFinal = false;\n                try {\n                    switch (message.conversationMessageType.toLowerCase()) {\n                        case \"info\":\n                        case \"participant_command\":\n                        case \"command\":\n                            const commandPayload = CommandResponsePayload.fromJSON(message.textBody);\n                            switch (commandPayload.command.toLowerCase()) {\n                                /**\n                                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                                 * The consuming client must wait for this message to arrive\n                                 * before starting to send their own data.\n                                 */\n                                case \"participantlist\":\n                                    const participantsPayload = ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                                    const participantsResult = participantsPayload.participants.map((p) => {\n                                        const participant = {\n                                            avatar: p.avatar,\n                                            displayName: p.nickname,\n                                            id: p.participantId,\n                                            isHost: p.ishost,\n                                            isMuted: p.ismuted,\n                                            isUsingTts: p.usetts,\n                                            preferredLanguage: p.locale\n                                        };\n                                        return participant;\n                                    });\n                                    if (!!this.privConversationServiceConnector.participantsListReceived) {\n                                        this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                                 * This is sent at the start of the Conversation\n                                 */\n                                case \"settranslatetolanguages\":\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                                 * If sent by the participant the setting will effect only their own profanity level.\n                                 * If sent by the host, the setting will effect all participants including the host.\n                                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                                 */\n                                case \"setprofanityfiltering\":\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'SetMute' is sent if the participant has been muted by the host.\n                                 * Check the 'participantId' to determine if the current user has been muted.\n                                 */\n                                case \"setmute\":\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                                 */\n                                case \"setmuteall\":\n                                    if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\n                                        this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new MuteAllEventArgs(commandPayload.value, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                                 */\n                                case \"roomexpirationwarning\":\n                                    if (!!this.privConversationServiceConnector.conversationExpiration) {\n                                        this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                                 */\n                                case \"setusetts\":\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                                 */\n                                case \"setlockstate\":\n                                    if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\n                                        this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new LockRoomEventArgs(commandPayload.value, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'ChangeNickname' is received if a user changes their display name.\n                                 * Any cached particpiants list should be updated to reflect the display name.\n                                 */\n                                case \"changenickname\":\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.changeNickname, commandPayload.nickname, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'JoinSession' is sent when a user joins the Conversation.\n                                 */\n                                case \"joinsession\":\n                                    const joinParticipantPayload = ParticipantPayloadResponse.fromJSON(message.textBody);\n                                    const joiningParticipant = {\n                                        avatar: joinParticipantPayload.avatar,\n                                        displayName: joinParticipantPayload.nickname,\n                                        id: joinParticipantPayload.participantId,\n                                        isHost: joinParticipantPayload.ishost,\n                                        isMuted: joinParticipantPayload.ismuted,\n                                        isUsingTts: joinParticipantPayload.usetts,\n                                        preferredLanguage: joinParticipantPayload.locale,\n                                    };\n                                    if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\n                                        this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(joiningParticipant, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'LeaveSession' is sent when a user leaves the Conversation'.\n                                 */\n                                case \"leavesession\":\n                                    const leavingParticipant = {\n                                        id: commandPayload.participantId\n                                    };\n                                    if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                                        this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(leavingParticipant, sessionId));\n                                    }\n                                    break;\n                                /**\n                                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                                 * Check the 'ParticipantId' to check whether the message is for the current user.\n                                 */\n                                case \"disconnectsession\":\n                                    const disconnectParticipant = {\n                                        id: commandPayload.participantId\n                                    };\n                                    break;\n                                case \"token\":\n                                    const token = new CognitiveTokenAuthentication((authFetchEventId) => {\n                                        const authorizationToken = commandPayload.token;\n                                        return Promise.resolve(authorizationToken);\n                                    }, (authFetchEventId) => {\n                                        const authorizationToken = commandPayload.token;\n                                        return Promise.resolve(authorizationToken);\n                                    });\n                                    this.authentication = token;\n                                    break;\n                                /**\n                                 * Message not recognized.\n                                 */\n                                default:\n                                    break;\n                            }\n                            break;\n                        /**\n                         * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n                         */\n                        case \"partial\":\n                        /**\n                         * 'final' (or 'phrase') represents a finalized speech message.\n                         */\n                        case \"final\":\n                            const speechPayload = SpeechResponsePayload.fromJSON(message.textBody);\n                            const speechResult = new ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, undefined, undefined, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n                            if (speechPayload.isFinal) {\n                                // check the length, sometimes empty finals are returned\n                                if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                                    sendFinal = true;\n                                }\n                                else if (speechPayload.id === this.privLastPartialUtteranceId) {\n                                    // send final as normal. We had a non-empty partial for this same utterance\n                                    // so sending the empty final is important\n                                    sendFinal = true;\n                                }\n                                else {\n                                    // suppress unneeded final\n                                }\n                                if (sendFinal) {\n                                    if (!!this.privConversationServiceConnector.translationReceived) {\n                                        this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                                    }\n                                }\n                            }\n                            else if (speechResult.text !== undefined) {\n                                this.privLastPartialUtteranceId = speechPayload.id;\n                                if (!!this.privConversationServiceConnector.translationReceived) {\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                                }\n                            }\n                            break;\n                        /**\n                         * \"translated_message\" is a text message or instant message (IM).\n                         */\n                        case \"translated_message\":\n                            const textPayload = TextResponsePayload.fromJSON(message.textBody);\n                            const textResult = new ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n                            if (!!this.privConversationServiceConnector.translationReceived) {\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n                            }\n                            break;\n                        default:\n                            // ignore any unsupported message types\n                            break;\n                    }\n                }\n                catch (e) {\n                    // continue\n                }\n                return this.receiveConversationMessageOverride();\n            }\n            catch (e) {\n                this.terminateMessageLoop = true;\n            }\n            return communicationCustodian.promise;\n        });\n    }\n    startMessageLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isDisposed()) {\n                return Promise.resolve();\n            }\n            this.terminateMessageLoop = false;\n            const messageRetrievalPromise = this.receiveConversationMessageOverride();\n            try {\n                const r = yield messageRetrievalPromise;\n                return r;\n            }\n            catch (error) {\n                this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n                return null;\n            }\n        });\n    }\n    // Takes an established websocket connection to the endpoint\n    configConnection() {\n        if (this.isDisposed()) {\n            return Promise.resolve(undefined);\n        }\n        if (this.privConnectionConfigPromise) {\n            return this.privConnectionConfigPromise.then((connection) => {\n                if (connection.state() === ConnectionState.Disconnected) {\n                    this.privConnectionId = null;\n                    this.privConnectionConfigPromise = null;\n                    return this.configConnection();\n                }\n                return this.privConnectionConfigPromise;\n            }, (error) => {\n                this.privConnectionId = null;\n                this.privConnectionConfigPromise = null;\n                return this.configConnection();\n            });\n        }\n        if (this.terminateMessageLoop) {\n            return Promise.resolve(undefined);\n        }\n        this.privConnectionConfigPromise = this.connectImpl().then((connection) => {\n            return connection;\n        });\n        return this.privConnectionConfigPromise;\n    }\n    getTranslations(serviceResultTranslations) {\n        let translations;\n        if (undefined !== serviceResultTranslations) {\n            translations = new Translations();\n            for (const translation of serviceResultTranslations) {\n                translations.set(translation.lang, translation.translation);\n            }\n        }\n        return translations;\n    }\n}\n\n//# sourceMappingURL=ConversationServiceAdapter.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { SessionEventArgs } from \"../../sdk/Exports\";\nexport class MuteAllEventArgs extends SessionEventArgs {\n    constructor(isMuted, sessionId) {\n        super(sessionId);\n        this.privIsMuted = isMuted;\n    }\n    get isMuted() {\n        return this.privIsMuted;\n    }\n}\n// tslint:disable-next-line: max-classes-per-file\nexport class LockRoomEventArgs extends SessionEventArgs {\n    constructor(isLocked, sessionId) {\n        super(sessionId);\n        this.privIsLocked = isLocked;\n    }\n    get isMuted() {\n        return this.privIsLocked;\n    }\n}\n// tslint:disable-next-line: max-classes-per-file\nexport class ParticipantEventArgs extends SessionEventArgs {\n    constructor(participant, sessionId) {\n        super(sessionId);\n        this.privParticipant = participant;\n    }\n    get participant() {\n        return this.privParticipant;\n    }\n}\n// tslint:disable-next-line: max-classes-per-file\nexport class ParticipantAttributeEventArgs extends SessionEventArgs {\n    constructor(participantId, key, value, sessionId) {\n        super(sessionId);\n        this.privKey = key;\n        this.privValue = value;\n        this.privParticipantId = participantId;\n    }\n    get value() {\n        return this.privValue;\n    }\n    get key() {\n        return this.privKey;\n    }\n    get id() {\n        return this.privParticipantId;\n    }\n}\n// tslint:disable-next-line: max-classes-per-file\nexport class ParticipantsListEventArgs extends SessionEventArgs {\n    constructor(conversationId, token, translateTo, profanityFilter, roomProfanityFilter, isRoomLocked, isMuteAll, participants, sessionId) {\n        super(sessionId);\n        this.privRoomId = conversationId;\n        this.privSessionToken = token;\n        this.privTranslateTo = translateTo;\n        this.privProfanityFilter = profanityFilter;\n        this.privRoomProfanityFilter = roomProfanityFilter;\n        this.privIsRoomLocked = isRoomLocked;\n        this.privIsRoomLocked = isMuteAll;\n        this.privParticipants = participants;\n    }\n    get sessionToken() {\n        return this.privSessionToken;\n    }\n    get conversationId() {\n        return this.privRoomId;\n    }\n    get translateTo() {\n        return this.privTranslateTo;\n    }\n    get profanityFilter() {\n        return this.privProfanityFilter;\n    }\n    get roomProfanityFilter() {\n        return this.privRoomProfanityFilter;\n    }\n    get isRoomLocked() {\n        return this.privIsRoomLocked;\n    }\n    get isMuteAll() {\n        return this.privIsMuteAll;\n    }\n    get participants() {\n        return this.privParticipants;\n    }\n}\n// tslint:disable-next-line: max-classes-per-file\nexport class ConversationReceivedTranslationEventArgs {\n    constructor(command, payload, sessionId) {\n        this.privPayload = payload;\n        this.privCommand = command;\n        this.privSessionId = sessionId;\n    }\n    get payload() {\n        return this.privPayload;\n    }\n    get command() {\n        return this.privCommand;\n    }\n    get sessionId() {\n        return this.privSessionId;\n    }\n}\n\n//# sourceMappingURL=ConversationTranslatorEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/** Users participating in the conversation */\nexport class InternalParticipants {\n    constructor(participants = [], meId) {\n        this.participants = participants;\n        this.meId = meId;\n    }\n    /**\n     * Add or update a participant\n     * @param value\n     */\n    addOrUpdateParticipant(value) {\n        if (value === undefined) {\n            return;\n        }\n        const exists = this.getParticipantIndex(value.id);\n        if (exists > -1) {\n            this.participants.splice(exists, 1, value);\n        }\n        else {\n            this.participants.push(value);\n        }\n        // ensure it was added ok\n        return this.getParticipant(value.id);\n    }\n    /**\n     * Find the participant's position in the participants list.\n     * @param id\n     */\n    getParticipantIndex(id) {\n        return this.participants.findIndex((p) => p.id === id);\n    }\n    /**\n     * Find the participant by id.\n     * @param id\n     */\n    getParticipant(id) {\n        return this.participants.find((p) => p.id === id);\n    }\n    /***\n     * Remove a participant from the participants list.\n     */\n    deleteParticipant(id) {\n        this.participants = this.participants.filter((p) => p.id !== id);\n    }\n    /***\n     * Helper to return the conversation host.\n     */\n    get host() {\n        return this.participants.find((p) => p.isHost === true);\n    }\n    /**\n     * Helper to return the current user.\n     */\n    get me() {\n        return this.getParticipant(this.meId);\n    }\n}\n/**\n * List of command message types\n */\nexport const ConversationTranslatorMessageTypes = {\n    command: \"command\",\n    final: \"final\",\n    info: \"info\",\n    instantMessage: \"instant_message\",\n    keepAlive: \"keep_alive\",\n    partial: \"partial\",\n    participantCommand: \"participant_command\",\n    translatedMessage: \"translated_message\"\n};\n/**\n * List of command types\n */\nexport const ConversationTranslatorCommandTypes = {\n    changeNickname: \"ChangeNickname\",\n    disconnectSession: \"DisconnectSession\",\n    ejectParticipant: \"EjectParticipant\",\n    instant_message: \"instant_message\",\n    joinSession: \"JoinSession\",\n    leaveSession: \"LeaveSession\",\n    participantList: \"ParticipantList\",\n    roomExpirationWarning: \"RoomExpirationWarning\",\n    setLockState: \"SetLockState\",\n    setMute: \"SetMute\",\n    setMuteAll: \"SetMuteAll\",\n    setProfanityFiltering: \"SetProfanityFiltering\",\n    setTranslateToLanguages: \"SetTranslateToLanguages\",\n    setUseTTS: \"SetUseTTS\"\n};\n\n//# sourceMappingURL=ConversationTranslatorInterfaces.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { RecognizerConfig } from \"../../common.speech/Exports\";\nimport { BackgroundEvent, Events, Timeout } from \"../../common/Exports\";\nimport { Contracts } from \"../../sdk/Contracts\";\nimport { Connection, Recognizer } from \"../../sdk/Exports\";\nimport { ConversationConnectionFactory } from \"./ConversationConnectionFactory\";\nimport { ConversationServiceAdapter } from \"./ConversationServiceAdapter\";\nexport class ConversationRecognizerFactory {\n    static fromConfig(conversation, speechConfig, audioConfig) {\n        return new ConversationTranslatorRecognizer(conversation, speechConfig, audioConfig);\n    }\n}\n/**\n * Sends messages to the Conversation Translator websocket and listens for incoming events containing websocket messages.\n * Based off the recognizers in the SDK folder.\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class ConversationTranslatorRecognizer extends Recognizer {\n    constructor(conversation, speechConfig, audioConfig) {\n        const serviceConfigImpl = speechConfig;\n        Contracts.throwIfNull(serviceConfigImpl, \"speechConfig\");\n        const conversationImpl = conversation;\n        Contracts.throwIfNull(conversationImpl, \"conversationImpl\");\n        super(audioConfig, serviceConfigImpl.properties, new ConversationConnectionFactory());\n        this.privConversation = conversationImpl;\n        this.privIsDisposed = false;\n        this.privProperties = serviceConfigImpl.properties.clone();\n        this.privConnection = Connection.fromRecognizer(this);\n        this.privSetTimeout = (typeof (Blob) !== \"undefined\" && typeof (Worker) !== \"undefined\") ? Timeout.setTimeout : setTimeout;\n        this.privClearTimeout = (typeof (Blob) !== \"undefined\" && typeof (Worker) !== \"undefined\") ? Timeout.clearTimeout : clearTimeout;\n    }\n    set connected(cb) {\n        this.privConnection.connected = cb;\n    }\n    set disconnected(cb) {\n        this.privConnection.disconnected = cb;\n    }\n    /**\n     * Return the speech language used by the recognizer\n     */\n    get speechRecognitionLanguage() {\n        return this.privSpeechRecognitionLanguage;\n    }\n    /**\n     * Return the properties for the recognizer\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    isDisposed() {\n        return this.privIsDisposed;\n    }\n    /**\n     * Connect to the recognizer\n     * @param token\n     */\n    connect(token, cb, err) {\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            Contracts.throwIfNullOrWhitespace(token, \"token\");\n            this.privReco.conversationTranslatorToken = token;\n            this.resetConversationTimeout();\n            this.privReco.connectAsync(cb, err);\n        }\n        catch (error) {\n            if (!!err) {\n                if (error instanceof Error) {\n                    const typedError = error;\n                    err(typedError.name + \": \" + typedError.message);\n                }\n                else {\n                    err(error);\n                }\n            }\n        }\n    }\n    /**\n     * Disconnect from the recognizer\n     */\n    disconnect(cb, err) {\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            if (this.privTimeoutToken !== undefined) {\n                this.privClearTimeout(this.privTimeoutToken);\n            }\n            this.privReco.disconnect().then(() => {\n                if (!!cb) {\n                    cb();\n                }\n            }, (error) => {\n                if (!!err) {\n                    err(error);\n                }\n            });\n        }\n        catch (error) {\n            if (!!err) {\n                if (error instanceof Error) {\n                    const typedError = error;\n                    err(typedError.name + \": \" + typedError.message);\n                }\n                else {\n                    err(error);\n                }\n            }\n            // Destroy the recognizer.\n            this.dispose(true).catch((reason) => {\n                Events.instance.onEvent(new BackgroundEvent(reason));\n            });\n        }\n    }\n    /**\n     * Send the mute all participants command to the websocket\n     * @param conversationId\n     * @param participantId\n     * @param isMuted\n     */\n    sendRequest(command, cb, err) {\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            this.sendMessage(command, cb, err);\n        }\n        catch (error) {\n            if (!!err) {\n                if (error instanceof Error) {\n                    const typedError = error;\n                    err(typedError.name + \": \" + typedError.message);\n                }\n                else {\n                    err(error);\n                }\n            }\n            // Destroy the recognizer.\n            this.dispose(true).catch((reason) => {\n                Events.instance.onEvent(new BackgroundEvent(reason));\n            });\n        }\n    }\n    /**\n     * Close and dispose the recognizer\n     */\n    close() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            (_a = this.privConnection) === null || _a === void 0 ? void 0 : _a.closeConnection();\n            (_b = this.privConnection) === null || _b === void 0 ? void 0 : _b.close();\n            this.privConnection = undefined;\n            yield this.dispose(true);\n        });\n    }\n    /**\n     * Dispose the recognizer\n     * @param disposing\n     */\n    dispose(disposing) {\n        const _super = Object.create(null, {\n            dispose: { get: () => super.dispose }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privIsDisposed) {\n                return;\n            }\n            if (disposing) {\n                if (this.privTimeoutToken !== undefined) {\n                    this.privClearTimeout(this.privTimeoutToken);\n                }\n                this.privIsDisposed = true;\n                if (!!this.privConnection) {\n                    this.privConnection.closeConnection();\n                    this.privConnection.close();\n                    this.privConnection = undefined;\n                }\n                yield _super.dispose.call(this, disposing);\n            }\n        });\n    }\n    /**\n     * Create the config for the recognizer\n     * @param speechConfig\n     */\n    createRecognizerConfig(speechConfig) {\n        return new RecognizerConfig(speechConfig, this.privProperties);\n    }\n    /**\n     * Create the service recognizer.\n     * The audio source is redundnant here but is required by the implementation.\n     * @param authentication\n     * @param connectionFactory\n     * @param audioConfig\n     * @param recognizerConfig\n     */\n    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n        const audioSource = audioConfig;\n        return new ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);\n    }\n    sendMessage(msg, cb, err) {\n        const withAsync = this.privReco;\n        function PromiseToEmptyCallback(promise, cb, err) {\n            if (!!promise) {\n                promise.then((result) => {\n                    try {\n                        if (!!cb) {\n                            cb();\n                        }\n                    }\n                    catch (e) {\n                        if (!!err) {\n                            err(`'Unhandled error on promise callback: ${e}'`);\n                        }\n                    }\n                }, (reason) => {\n                    try {\n                        if (!!err) {\n                            err(reason);\n                        }\n                        /* tslint:disable:no-empty */\n                    }\n                    catch (error) {\n                    }\n                });\n            }\n            else {\n                if (!!err) {\n                    err(\"Null promise\");\n                }\n            }\n        }\n        PromiseToEmptyCallback(withAsync.sendMessageAsync(msg), cb, err);\n        this.resetConversationTimeout();\n    }\n    resetConversationTimeout() {\n        if (this.privTimeoutToken !== undefined) {\n            this.privClearTimeout(this.privTimeoutToken);\n        }\n        this.privTimeoutToken = this.privSetTimeout(() => {\n            this.sendRequest(this.privConversation.getKeepAlive());\n        }, 60000);\n    }\n}\n\n//# sourceMappingURL=ConversationTranslatorRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Deferred, MessageType, RawWebsocketMessage, } from \"../../common/Exports\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\n/**\n * Based off WebsocketMessageFormatter. The messages for Conversation Translator have some variations from the Speech messages.\n */\nexport class ConversationWebsocketMessageFormatter {\n    constructor() {\n        /**\n         * Format incoming messages: text (speech partial/final, IM) or binary (tts)\n         */\n        this.toConnectionMessage = (message) => {\n            const deferral = new Deferred();\n            try {\n                if (message.messageType === MessageType.Text) {\n                    const incomingMessage = new ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);\n                    deferral.resolve(incomingMessage);\n                }\n                else if (message.messageType === MessageType.Binary) {\n                    deferral.resolve(new ConversationConnectionMessage(message.messageType, message.binaryContent, undefined, message.id));\n                }\n            }\n            catch (e) {\n                deferral.reject(`Error formatting the message. Error: ${e}`);\n            }\n            return deferral.promise;\n        };\n        /**\n         * Format outgoing messages: text (commands or IM)\n         */\n        this.fromConnectionMessage = (message) => {\n            const deferral = new Deferred();\n            try {\n                if (message.messageType === MessageType.Text) {\n                    const payload = `${message.textBody ? message.textBody : \"\"}`;\n                    deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\n                }\n            }\n            catch (e) {\n                deferral.reject(`Error formatting the message. ${e}`);\n            }\n            return deferral.promise;\n        };\n    }\n}\n\n//# sourceMappingURL=ConversationWebsocketMessageFormatter.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport { ConversationManager } from \"./ConversationManager\";\nexport { ConversationConnectionConfig } from \"./ConversationConnectionConfig\";\nexport { ConversationRecognizerFactory } from \"./ConversationTranslatorRecognizer\";\nexport { TranscriberRecognizer } from \"./TranscriberRecognizer\";\nexport { ConversationReceivedTranslationEventArgs, LockRoomEventArgs, MuteAllEventArgs, ParticipantAttributeEventArgs, ParticipantEventArgs, ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs\";\nexport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, InternalParticipants } from \"./ConversationTranslatorInterfaces\";\n\n//# sourceMappingURL=Exports.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class CommandResponsePayload {\n    constructor(json) {\n        this.privCommandResponse = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new CommandResponsePayload(json);\n    }\n    get type() {\n        return this.privCommandResponse.type;\n    }\n    get command() {\n        return this.privCommandResponse.command;\n    }\n    get id() {\n        return this.privCommandResponse.id;\n    }\n    get nickname() {\n        return this.privCommandResponse.nickname;\n    }\n    get participantId() {\n        return this.privCommandResponse.participantId;\n    }\n    get roomid() {\n        return this.privCommandResponse.roomid;\n    }\n    get value() {\n        return this.privCommandResponse.value;\n    }\n    get token() {\n        return this.privCommandResponse.token;\n    }\n}\n\n//# sourceMappingURL=CommandResponsePayload.js.map\n","export { CommandResponsePayload } from \"./CommandResponsePayload\";\nexport { ParticipantsListPayloadResponse, ParticipantPayloadResponse } from \"./ParticipantResponsePayload\";\nexport { SpeechResponsePayload, TextResponsePayload } from \"./TranslationResponsePayload\";\n\n//# sourceMappingURL=Exports.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class ParticipantsListPayloadResponse {\n    constructor(json) {\n        this.privParticipantsPayloadResponse = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new ParticipantsListPayloadResponse(json);\n    }\n    get roomid() {\n        return this.privParticipantsPayloadResponse.roomid;\n    }\n    get id() {\n        return this.privParticipantsPayloadResponse.id;\n    }\n    get command() {\n        return this.privParticipantsPayloadResponse.command;\n    }\n    get participants() {\n        return this.privParticipantsPayloadResponse.participants;\n    }\n    get token() {\n        return this.privParticipantsPayloadResponse.token;\n    }\n    get translateTo() {\n        return this.privParticipantsPayloadResponse.translateTo;\n    }\n    get profanityFilter() {\n        return this.privParticipantsPayloadResponse.profanityFilter;\n    }\n    get roomProfanityFilter() {\n        return this.privParticipantsPayloadResponse.roomProfanityFilter;\n    }\n    get roomLocked() {\n        return this.privParticipantsPayloadResponse.roomLocked;\n    }\n    get muteAll() {\n        return this.privParticipantsPayloadResponse.muteAll;\n    }\n    get type() {\n        return this.privParticipantsPayloadResponse.type;\n    }\n}\n// tslint:disable-next-line: max-classes-per-file\nexport class ParticipantPayloadResponse {\n    constructor(json) {\n        this.privParticipantPayloadResponse = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new ParticipantPayloadResponse(json);\n    }\n    get nickname() {\n        return this.privParticipantPayloadResponse.nickname;\n    }\n    get locale() {\n        return this.privParticipantPayloadResponse.locale;\n    }\n    get usetts() {\n        return this.privParticipantPayloadResponse.usetts;\n    }\n    get ismuted() {\n        return this.privParticipantPayloadResponse.ismuted;\n    }\n    get ishost() {\n        return this.privParticipantPayloadResponse.ishost;\n    }\n    get participantId() {\n        return this.privParticipantPayloadResponse.participantId;\n    }\n    get avatar() {\n        return this.privParticipantPayloadResponse.avatar;\n    }\n}\n\n//# sourceMappingURL=ParticipantResponsePayload.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class SpeechResponsePayload {\n    constructor(json) {\n        this.privSpeechResponse = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new SpeechResponsePayload(json);\n    }\n    get recognition() {\n        return this.privSpeechResponse.recognition;\n    }\n    get translations() {\n        return this.privSpeechResponse.translations;\n    }\n    get id() {\n        return this.privSpeechResponse.id;\n    }\n    get language() {\n        return this.privSpeechResponse.language;\n    }\n    get nickname() {\n        return this.privSpeechResponse.nickname;\n    }\n    get participantId() {\n        return this.privSpeechResponse.participantId;\n    }\n    get roomid() {\n        return this.privSpeechResponse.roomid;\n    }\n    get timestamp() {\n        return this.privSpeechResponse.timestamp;\n    }\n    get type() {\n        return this.privSpeechResponse.type;\n    }\n    get isFinal() {\n        return this.privSpeechResponse.type === \"final\";\n    }\n}\n// tslint:disable-next-line: max-classes-per-file\nexport class TextResponsePayload {\n    constructor(json) {\n        this.privTextResponse = JSON.parse(json);\n    }\n    static fromJSON(json) {\n        return new TextResponsePayload(json);\n    }\n    get originalText() {\n        return this.privTextResponse.originalText;\n    }\n    get translations() {\n        return this.privTextResponse.translations;\n    }\n    get id() {\n        return this.privTextResponse.id;\n    }\n    get language() {\n        return this.privTextResponse.language;\n    }\n    get nickname() {\n        return this.privTextResponse.nickname;\n    }\n    get participantId() {\n        return this.privTextResponse.participantId;\n    }\n    get roomid() {\n        return this.privTextResponse.roomid;\n    }\n    get timestamp() {\n        return this.privTextResponse.timestamp;\n    }\n    get type() {\n        return this.privTextResponse.type;\n    }\n}\n\n//# sourceMappingURL=TranslationResponsePayload.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { marshalPromiseToCallbacks } from \"../../common/Exports\";\nimport { Contracts } from \"../../sdk/Contracts\";\nimport { PropertyId, Recognizer, } from \"../../sdk/Exports\";\nimport { RecognitionMode, RecognizerConfig, TranscriberConnectionFactory, TranscriptionServiceRecognizer, } from \"../Exports\";\nexport class TranscriberRecognizer extends Recognizer {\n    /**\n     * TranscriberRecognizer constructor.\n     * @constructor\n     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer\n     */\n    constructor(speechTranslationConfig, audioConfig) {\n        const speechTranslationConfigImpl = speechTranslationConfig;\n        Contracts.throwIfNull(speechTranslationConfigImpl, \"speechTranslationConfig\");\n        Contracts.throwIfNullOrWhitespace(speechTranslationConfigImpl.speechRecognitionLanguage, PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n        super(audioConfig, speechTranslationConfigImpl.properties, new TranscriberConnectionFactory());\n        this.privDisposedRecognizer = false;\n    }\n    getConversationInfo() {\n        Contracts.throwIfNullOrUndefined(this.privConversation, \"Conversation\");\n        return this.privConversation.conversationInfo;\n    }\n    get authorizationToken() {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    set authorizationToken(token) {\n        Contracts.throwIfNullOrWhitespace(token, \"token\");\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, token);\n    }\n    set conversation(c) {\n        Contracts.throwIfNullOrUndefined(c, \"Conversation\");\n        this.privConversation = c;\n    }\n    get speechRecognitionLanguage() {\n        Contracts.throwIfDisposed(this.privDisposedRecognizer);\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n    }\n    get properties() {\n        return this.privProperties;\n    }\n    startContinuousRecognitionAsync(cb, err) {\n        marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(RecognitionMode.Conversation), cb, err);\n    }\n    stopContinuousRecognitionAsync(cb, err) {\n        marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            Contracts.throwIfDisposed(this.privDisposedRecognizer);\n            yield this.dispose(true);\n        });\n    }\n    // Push async join/leave conversation message via serviceRecognizer\n    pushConversationEvent(conversationInfo, command) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const reco = (this.privReco);\n            Contracts.throwIfNullOrUndefined(reco, \"serviceRecognizer\");\n            yield reco.sendSpeechEventAsync(conversationInfo, command);\n        });\n    }\n    connectCallbacks(transcriber) {\n        this.canceled = (s, e) => {\n            if (!!transcriber.canceled) {\n                transcriber.canceled(transcriber, e);\n            }\n        };\n        this.recognizing = (s, e) => {\n            if (!!transcriber.transcribing) {\n                transcriber.transcribing(transcriber, e);\n            }\n        };\n        this.recognized = (s, e) => {\n            if (!!transcriber.transcribed) {\n                transcriber.transcribed(transcriber, e);\n            }\n        };\n        this.sessionStarted = (s, e) => {\n            if (!!transcriber.sessionStarted) {\n                transcriber.sessionStarted(transcriber, e);\n            }\n        };\n        this.sessionStopped = (s, e) => {\n            if (!!transcriber.sessionStopped) {\n                transcriber.sessionStopped(transcriber, e);\n            }\n        };\n    }\n    disconnectCallbacks() {\n        this.canceled = undefined;\n        this.recognizing = undefined;\n        this.recognized = undefined;\n        this.sessionStarted = undefined;\n        this.sessionStopped = undefined;\n    }\n    /**\n     * Disposes any resources held by the object.\n     * @member ConversationTranscriber.prototype.dispose\n     * @function\n     * @public\n     * @param {boolean} disposing - true if disposing the object.\n     */\n    dispose(disposing) {\n        const _super = Object.create(null, {\n            dispose: { get: () => super.dispose }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privDisposedRecognizer) {\n                return;\n            }\n            if (disposing) {\n                this.privDisposedRecognizer = true;\n                yield this.implRecognizerStop();\n            }\n            yield _super.dispose.call(this, disposing);\n        });\n    }\n    createRecognizerConfig(speechConfig) {\n        return new RecognizerConfig(speechConfig, this.properties);\n    }\n    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n        const configImpl = audioConfig;\n        return new TranscriptionServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);\n    }\n}\n\n//# sourceMappingURL=TranscriberRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { MessageType } from \"../common/Exports\";\nimport { CancellationErrorCode, ConversationTranscriptionCanceledEventArgs, OutputFormat, PropertyCollection, PropertyId, ResultReason, SpeechRecognitionEventArgs, SpeechRecognitionResult, } from \"../sdk/Exports\";\nimport { CancellationErrorCodePropertyName, DetailedSpeechPhrase, EnumTranslation, OutputFormatPropertyName, RecognitionStatus, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechHypothesis } from \"./Exports\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\n// tslint:disable-next-line:max-classes-per-file\nexport class TranscriptionServiceRecognizer extends ServiceRecognizerBase {\n    constructor(authentication, connectionFactory, audioSource, recognizerConfig, transcriber) {\n        super(authentication, connectionFactory, audioSource, recognizerConfig, transcriber);\n        this.sendSpeechEvent = (connection, payload) => {\n            const speechEventJson = JSON.stringify(payload);\n            if (speechEventJson) {\n                return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.event\", this.privRequestSession.requestId, \"application/json\", speechEventJson));\n            }\n            return;\n        };\n        this.privTranscriberRecognizer = transcriber;\n        this.sendPrePayloadJSONOverride = this.sendTranscriptionStartJSON;\n    }\n    sendSpeechEventAsync(info, command) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!!this.privRequestSession.isRecognizing) {\n                const connection = yield this.fetchConnection();\n                yield this.sendSpeechEvent(connection, this.createSpeechEventPayload(info, command));\n            }\n        });\n    }\n    processTypeSpecificMessages(connectionMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result;\n            const resultProps = new PropertyCollection();\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n            let processed = false;\n            switch (connectionMessage.path.toLowerCase()) {\n                case \"speech.hypothesis\":\n                case \"speech.fragment\":\n                    const hypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n                    const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n                    result = new SpeechRecognitionResult(this.privRequestSession.requestId, ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, hypothesis.SpeakerId, undefined, connectionMessage.textBody, resultProps);\n                    this.privRequestSession.onHypothesis(offset);\n                    const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n                    if (!!this.privTranscriberRecognizer.recognizing) {\n                        try {\n                            this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, ev);\n                            /* tslint:disable:no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    processed = true;\n                    break;\n                case \"speech.phrase\":\n                    const simple = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n                    const resultReason = EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);\n                    this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);\n                    if (ResultReason.Canceled === resultReason) {\n                        const cancelReason = EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);\n                        yield this.cancelRecognitionLocal(cancelReason, EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus), undefined);\n                    }\n                    else {\n                        if (!(this.privRequestSession.isSpeechEnded && resultReason === ResultReason.NoMatch && simple.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\n                            if (this.privRecognizerConfig.parameters.getProperty(OutputFormatPropertyName) === OutputFormat[OutputFormat.Simple]) {\n                                result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, simple.SpeakerId, undefined, connectionMessage.textBody, resultProps);\n                            }\n                            else {\n                                const detailed = DetailedSpeechPhrase.fromJSON(connectionMessage.textBody);\n                                const totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;\n                                const offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);\n                                result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.RecognitionStatus === RecognitionStatus.Success ? detailed.NBest[0].Display : undefined, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, undefined, undefined, offsetCorrectedJson, resultProps);\n                            }\n                            const event = new SpeechRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n                            if (!!this.privTranscriberRecognizer.recognized) {\n                                try {\n                                    this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, event);\n                                    /* tslint:disable:no-empty */\n                                }\n                                catch (error) {\n                                    // Not going to let errors in the event handler\n                                    // trip things up.\n                                }\n                            }\n                        }\n                        if (!!this.privSuccessCallback) {\n                            try {\n                                this.privSuccessCallback(result);\n                            }\n                            catch (e) {\n                                if (!!this.privErrorCallback) {\n                                    this.privErrorCallback(e);\n                                }\n                            }\n                            // Only invoke the call back once.\n                            // and if it's successful don't invoke the\n                            // error after that.\n                            this.privSuccessCallback = undefined;\n                            this.privErrorCallback = undefined;\n                        }\n                    }\n                    processed = true;\n                    break;\n                default:\n                    break;\n            }\n            return processed;\n        });\n    }\n    // Cancels recognition.\n    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n        const properties = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        if (!!this.privTranscriberRecognizer.canceled) {\n            const cancelEvent = new ConversationTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n            try {\n                this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, cancelEvent);\n                /* tslint:disable:no-empty */\n            }\n            catch (_a) { }\n        }\n        if (!!this.privSuccessCallback) {\n            const result = new SpeechRecognitionResult(requestId, ResultReason.Canceled, undefined, // Text\n            undefined, // Duration\n            undefined, // Offset\n            undefined, // Language\n            undefined, // Language Detection Confidence\n            undefined, // Speaker Id\n            error, undefined, // Json\n            properties);\n            try {\n                this.privSuccessCallback(result);\n                this.privSuccessCallback = undefined;\n                /* tslint:disable:no-empty */\n            }\n            catch (_b) { }\n        }\n    }\n    // Encapsulated for derived service recognizers that need to send additional JSON\n    sendTranscriptionStartJSON(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.sendSpeechContext(connection);\n            const info = this.privTranscriberRecognizer.getConversationInfo();\n            const payload = this.createSpeechEventPayload(info, \"start\");\n            yield this.sendSpeechEvent(connection, payload);\n            yield this.sendWaveHeader(connection);\n            return;\n        });\n    }\n    createSpeechEventPayload(info, command) {\n        const meeting = \"meeting\";\n        const eventDict = { id: meeting, name: command, meeting: info.conversationProperties };\n        const idString = \"id\";\n        const attendees = \"attendees\";\n        const record = \"record\";\n        eventDict[meeting][idString] = info.id;\n        eventDict[meeting][attendees] = info.participants;\n        eventDict[meeting][record] = info.conversationProperties.audiorecording === \"on\" ? \"true\" : \"false\";\n        return eventDict;\n    }\n}\n\n//# sourceMappingURL=TranscriptionServiceRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ProxyInfo, WebsocketConnection, } from \"../common.browser/Exports\";\nimport { PropertyId } from \"../sdk/Exports\";\nimport { ConnectionFactoryBase } from \"./ConnectionFactoryBase\";\nimport { WebsocketMessageFormatter, } from \"./Exports\";\nimport { HeaderNames } from \"./HeaderNames\";\nimport { QueryParameterNames } from \"./QueryParameterNames\";\nexport class TranslationConnectionFactory extends ConnectionFactoryBase {\n    constructor() {\n        super(...arguments);\n        this.create = (config, authInfo, connectionId) => {\n            let endpoint = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint, undefined);\n            if (!endpoint) {\n                const region = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Region, undefined);\n                const hostSuffix = (region && region.toLowerCase().startsWith(\"china\")) ? \".azure.cn\" : \".microsoft.com\";\n                const host = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Host, \"wss://\" + region + \".s2s.speech\" + hostSuffix);\n                endpoint = host + \"/speech/translation/cognitiveservices/v1\";\n            }\n            const queryParams = {\n                from: config.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage),\n                to: config.parameters.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages),\n            };\n            this.setCommonUrlParams(config, queryParams, endpoint);\n            this.setUrlParameter(PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, QueryParameterNames.StableTranslation, config, queryParams, endpoint);\n            const voiceName = \"voice\";\n            const featureName = \"features\";\n            if (config.parameters.getProperty(PropertyId.SpeechServiceConnection_TranslationVoice, undefined) !== undefined) {\n                queryParams[voiceName] = config.parameters.getProperty(PropertyId.SpeechServiceConnection_TranslationVoice);\n                queryParams[featureName] = \"texttospeech\";\n            }\n            const headers = {};\n            if (authInfo.token !== undefined && authInfo.token !== \"\") {\n                headers[authInfo.headerName] = authInfo.token;\n            }\n            headers[HeaderNames.ConnectionId] = connectionId;\n            config.parameters.setProperty(PropertyId.SpeechServiceConnection_Url, endpoint);\n            const enableCompression = config.parameters.getProperty(\"SPEECH-EnableWebsocketCompression\", \"false\") === \"true\";\n            return new WebsocketConnection(endpoint, queryParams, headers, new WebsocketMessageFormatter(), ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);\n        };\n    }\n}\n\n//# sourceMappingURL=TranslationConnectionFactory.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { MessageType, TranslationStatus, } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, TranslationRecognitionCanceledEventArgs, TranslationRecognitionEventArgs, TranslationRecognitionResult, Translations, TranslationSynthesisEventArgs, TranslationSynthesisResult, } from \"../sdk/Exports\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, RecognitionStatus, ServiceRecognizerBase, SynthesisStatus, TranslationHypothesis, TranslationPhrase, TranslationSynthesisEnd, } from \"./Exports\";\n// tslint:disable-next-line:max-classes-per-file\nexport class TranslationServiceRecognizer extends ServiceRecognizerBase {\n    constructor(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer) {\n        super(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer);\n        this.privTranslationRecognizer = translationRecognizer;\n        this.connectionEvents.attach((connectionEvent) => __awaiter(this, void 0, void 0, function* () {\n            if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n                this.privTranslationRecognizer.onConnection();\n            }\n            else if (connectionEvent.name === \"ConnectionClosedEvent\") {\n                yield this.privTranslationRecognizer.onDisconnection();\n            }\n        }));\n    }\n    processTypeSpecificMessages(connectionMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const resultProps = new PropertyCollection();\n            let processed = false;\n            if (connectionMessage.messageType === MessageType.Text) {\n                resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n            }\n            switch (connectionMessage.path.toLowerCase()) {\n                case \"translation.hypothesis\":\n                    const result = this.fireEventForResult(TranslationHypothesis.fromJSON(connectionMessage.textBody), resultProps);\n                    this.privRequestSession.onHypothesis(this.privRequestSession.currentTurnAudioOffset + result.offset);\n                    if (!!this.privTranslationRecognizer.recognizing) {\n                        try {\n                            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, result);\n                            /* tslint:disable:no-empty */\n                        }\n                        catch (error) {\n                            // Not going to let errors in the event handler\n                            // trip things up.\n                        }\n                    }\n                    processed = true;\n                    break;\n                case \"translation.phrase\":\n                    const translatedPhrase = TranslationPhrase.fromJSON(connectionMessage.textBody);\n                    this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset + translatedPhrase.Duration);\n                    if (translatedPhrase.RecognitionStatus === RecognitionStatus.Success) {\n                        // OK, the recognition was successful. How'd the translation do?\n                        const result = this.fireEventForResult(translatedPhrase, resultProps);\n                        if (!!this.privTranslationRecognizer.recognized) {\n                            try {\n                                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, result);\n                                /* tslint:disable:no-empty */\n                            }\n                            catch (error) {\n                                // Not going to let errors in the event handler\n                                // trip things up.\n                            }\n                        }\n                        // report result to promise.\n                        if (!!this.privSuccessCallback) {\n                            try {\n                                this.privSuccessCallback(result.result);\n                            }\n                            catch (e) {\n                                if (!!this.privErrorCallback) {\n                                    this.privErrorCallback(e);\n                                }\n                            }\n                            // Only invoke the call back once.\n                            // and if it's successful don't invoke the\n                            // error after that.\n                            this.privSuccessCallback = undefined;\n                            this.privErrorCallback = undefined;\n                        }\n                        break;\n                    }\n                    else {\n                        const reason = EnumTranslation.implTranslateRecognitionResult(translatedPhrase.RecognitionStatus);\n                        const result = new TranslationRecognitionResult(undefined, this.privRequestSession.requestId, reason, translatedPhrase.Text, translatedPhrase.Duration, this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset, undefined, connectionMessage.textBody, resultProps);\n                        if (reason === ResultReason.Canceled) {\n                            const cancelReason = EnumTranslation.implTranslateCancelResult(translatedPhrase.RecognitionStatus);\n                            yield this.cancelRecognitionLocal(cancelReason, EnumTranslation.implTranslateCancelErrorCode(translatedPhrase.RecognitionStatus), undefined);\n                        }\n                        else {\n                            if (!(this.privRequestSession.isSpeechEnded && reason === ResultReason.NoMatch && translatedPhrase.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\n                                const ev = new TranslationRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n                                if (!!this.privTranslationRecognizer.recognized) {\n                                    try {\n                                        this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);\n                                        /* tslint:disable:no-empty */\n                                    }\n                                    catch (error) {\n                                        // Not going to let errors in the event handler\n                                        // trip things up.\n                                    }\n                                }\n                            }\n                            // report result to promise.\n                            if (!!this.privSuccessCallback) {\n                                try {\n                                    this.privSuccessCallback(result);\n                                }\n                                catch (e) {\n                                    if (!!this.privErrorCallback) {\n                                        this.privErrorCallback(e);\n                                    }\n                                }\n                                // Only invoke the call back once.\n                                // and if it's successful don't invoke the\n                                // error after that.\n                                this.privSuccessCallback = undefined;\n                                this.privErrorCallback = undefined;\n                            }\n                        }\n                    }\n                    processed = true;\n                    break;\n                case \"translation.synthesis\":\n                    this.sendSynthesisAudio(connectionMessage.binaryBody, this.privRequestSession.sessionId);\n                    processed = true;\n                    break;\n                case \"translation.synthesis.end\":\n                    const synthEnd = TranslationSynthesisEnd.fromJSON(connectionMessage.textBody);\n                    switch (synthEnd.SynthesisStatus) {\n                        case SynthesisStatus.Error:\n                            if (!!this.privTranslationRecognizer.synthesizing) {\n                                const result = new TranslationSynthesisResult(ResultReason.Canceled, undefined);\n                                const retEvent = new TranslationSynthesisEventArgs(result, this.privRequestSession.sessionId);\n                                try {\n                                    this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\n                                    /* tslint:disable:no-empty */\n                                }\n                                catch (error) {\n                                    // Not going to let errors in the event handler\n                                    // trip things up.\n                                }\n                            }\n                            if (!!this.privTranslationRecognizer.canceled) {\n                                // And raise a canceled event to send the rich(er) error message back.\n                                const canceledResult = new TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, CancellationReason.Error, synthEnd.FailureReason, CancellationErrorCode.ServiceError, null);\n                                try {\n                                    this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, canceledResult);\n                                    /* tslint:disable:no-empty */\n                                }\n                                catch (error) {\n                                    // Not going to let errors in the event handler\n                                    // trip things up.\n                                }\n                            }\n                            break;\n                        case SynthesisStatus.Success:\n                            this.sendSynthesisAudio(undefined, this.privRequestSession.sessionId);\n                            break;\n                        default:\n                            break;\n                    }\n                    processed = true;\n                    break;\n                default:\n                    break;\n            }\n            return processed;\n        });\n    }\n    // Cancels recognition.\n    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n        const properties = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        if (!!this.privTranslationRecognizer.canceled) {\n            const cancelEvent = new TranslationRecognitionCanceledEventArgs(sessionId, cancellationReason, error, errorCode, undefined);\n            try {\n                this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, cancelEvent);\n                /* tslint:disable:no-empty */\n            }\n            catch (_a) { }\n        }\n        if (!!this.privSuccessCallback) {\n            const result = new TranslationRecognitionResult(undefined, // Translations\n            requestId, ResultReason.Canceled, undefined, // Text\n            undefined, // Druation\n            undefined, // Offset\n            error, undefined, // Json\n            properties);\n            try {\n                this.privSuccessCallback(result);\n                /* tslint:disable:no-empty */\n                this.privSuccessCallback = undefined;\n            }\n            catch (_b) { }\n        }\n    }\n    fireEventForResult(serviceResult, properties) {\n        let translations;\n        if (undefined !== serviceResult.Translation.Translations) {\n            translations = new Translations();\n            for (const translation of serviceResult.Translation.Translations) {\n                translations.set(translation.Language, translation.Text);\n            }\n        }\n        let resultReason;\n        if (serviceResult instanceof TranslationPhrase) {\n            if (serviceResult.Translation.TranslationStatus === TranslationStatus.Success) {\n                resultReason = ResultReason.TranslatedSpeech;\n            }\n            else {\n                resultReason = ResultReason.RecognizedSpeech;\n            }\n        }\n        else {\n            resultReason = ResultReason.TranslatingSpeech;\n        }\n        const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n        const result = new TranslationRecognitionResult(translations, this.privRequestSession.requestId, resultReason, serviceResult.Text, serviceResult.Duration, offset, serviceResult.Translation.FailureReason, JSON.stringify(serviceResult), properties);\n        const ev = new TranslationRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n        return ev;\n    }\n    sendSynthesisAudio(audio, sessionId) {\n        const reason = (undefined === audio) ? ResultReason.SynthesizingAudioCompleted : ResultReason.SynthesizingAudio;\n        const result = new TranslationSynthesisResult(reason, audio);\n        const retEvent = new TranslationSynthesisEventArgs(result, sessionId);\n        if (!!this.privTranslationRecognizer.synthesizing) {\n            try {\n                this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\n                /* tslint:disable:no-empty */\n            }\n            catch (error) {\n                // Not going to let errors in the event handler\n                // trip things up.\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=TranslationServiceRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines translation status.\n * @class TranslationStatus\n */\nexport var TranslationStatus;\n(function (TranslationStatus) {\n    /**\n     * @member TranslationStatus.Success\n     */\n    TranslationStatus[TranslationStatus[\"Success\"] = 0] = \"Success\";\n    /**\n     * @member TranslationStatus.Error\n     */\n    TranslationStatus[TranslationStatus[\"Error\"] = 1] = \"Error\";\n})(TranslationStatus || (TranslationStatus = {}));\n\n//# sourceMappingURL=TranslationStatus.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ConnectionMessage, Deferred, MessageType, RawWebsocketMessage, } from \"../common/Exports\";\nconst CRLF = \"\\r\\n\";\nexport class WebsocketMessageFormatter {\n    constructor() {\n        this.toConnectionMessage = (message) => {\n            const deferral = new Deferred();\n            try {\n                if (message.messageType === MessageType.Text) {\n                    const textMessage = message.textContent;\n                    let headers = {};\n                    let body = null;\n                    if (textMessage) {\n                        const headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\n                        if (headerBodySplit && headerBodySplit.length > 0) {\n                            headers = this.parseHeaders(headerBodySplit[0]);\n                            if (headerBodySplit.length > 1) {\n                                body = headerBodySplit[1];\n                            }\n                        }\n                    }\n                    deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\n                }\n                else if (message.messageType === MessageType.Binary) {\n                    const binaryMessage = message.binaryContent;\n                    let headers = {};\n                    let body = null;\n                    if (!binaryMessage || binaryMessage.byteLength < 2) {\n                        throw new Error(\"Invalid binary message format. Header length missing.\");\n                    }\n                    const dataView = new DataView(binaryMessage);\n                    const headerLength = dataView.getInt16(0);\n                    if (binaryMessage.byteLength < headerLength + 2) {\n                        throw new Error(\"Invalid binary message format. Header content missing.\");\n                    }\n                    let headersString = \"\";\n                    for (let i = 0; i < headerLength; i++) {\n                        headersString += String.fromCharCode((dataView).getInt8(i + 2));\n                    }\n                    headers = this.parseHeaders(headersString);\n                    if (binaryMessage.byteLength > headerLength + 2) {\n                        body = binaryMessage.slice(2 + headerLength);\n                    }\n                    deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\n                }\n            }\n            catch (e) {\n                deferral.reject(`Error formatting the message. Error: ${e}`);\n            }\n            return deferral.promise;\n        };\n        this.fromConnectionMessage = (message) => {\n            const deferral = new Deferred();\n            try {\n                if (message.messageType === MessageType.Text) {\n                    const payload = `${this.makeHeaders(message)}${CRLF}${message.textBody ? message.textBody : \"\"}`;\n                    deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\n                }\n                else if (message.messageType === MessageType.Binary) {\n                    const headersString = this.makeHeaders(message);\n                    const content = message.binaryBody;\n                    const headerBuffer = this.stringToArrayBuffer(headersString);\n                    const headerInt8Array = new Int8Array(headerBuffer);\n                    const headerLength = headerInt8Array.byteLength;\n                    const payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));\n                    payloadInt8Array[0] = ((headerLength >> 8) & 0xff);\n                    payloadInt8Array[1] = headerLength & 0xff;\n                    payloadInt8Array.set(headerInt8Array, 2);\n                    if (content) {\n                        const bodyInt8Array = new Int8Array(content);\n                        payloadInt8Array.set(bodyInt8Array, 2 + headerLength);\n                    }\n                    const payload = payloadInt8Array.buffer;\n                    deferral.resolve(new RawWebsocketMessage(MessageType.Binary, payload, message.id));\n                }\n            }\n            catch (e) {\n                deferral.reject(`Error formatting the message. ${e}`);\n            }\n            return deferral.promise;\n        };\n        this.makeHeaders = (message) => {\n            let headersString = \"\";\n            if (message.headers) {\n                for (const header in message.headers) {\n                    if (header) {\n                        headersString += `${header}: ${message.headers[header]}${CRLF}`;\n                    }\n                }\n            }\n            return headersString;\n        };\n        this.parseHeaders = (headersString) => {\n            const headers = {};\n            if (headersString) {\n                const headerMatches = headersString.match(/[^\\r\\n]+/g);\n                if (headers) {\n                    for (const header of headerMatches) {\n                        if (header) {\n                            const separatorIndex = header.indexOf(\":\");\n                            const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\n                            const headerValue = separatorIndex > 0 && header.length > (separatorIndex + 1) ?\n                                header.substr(separatorIndex + 1).trim() :\n                                \"\";\n                            headers[headerName] = headerValue;\n                        }\n                    }\n                }\n            }\n            return headers;\n        };\n        this.stringToArrayBuffer = (str) => {\n            const buffer = new ArrayBuffer(str.length);\n            const view = new DataView(buffer);\n            for (let i = 0; i < str.length; i++) {\n                view.setUint8(i, str.charCodeAt(i));\n            }\n            return buffer;\n        };\n    }\n}\n\n//# sourceMappingURL=WebsocketMessageFormatter.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// tslint:disable:max-classes-per-file\nimport { EventType, PlatformEvent } from \"./PlatformEvent\";\nexport class AudioSourceEvent extends PlatformEvent {\n    constructor(eventName, audioSourceId, eventType = EventType.Info) {\n        super(eventName, eventType);\n        this.privAudioSourceId = audioSourceId;\n    }\n    get audioSourceId() {\n        return this.privAudioSourceId;\n    }\n}\nexport class AudioSourceInitializingEvent extends AudioSourceEvent {\n    constructor(audioSourceId) {\n        super(\"AudioSourceInitializingEvent\", audioSourceId);\n    }\n}\nexport class AudioSourceReadyEvent extends AudioSourceEvent {\n    constructor(audioSourceId) {\n        super(\"AudioSourceReadyEvent\", audioSourceId);\n    }\n}\nexport class AudioSourceOffEvent extends AudioSourceEvent {\n    constructor(audioSourceId) {\n        super(\"AudioSourceOffEvent\", audioSourceId);\n    }\n}\nexport class AudioSourceErrorEvent extends AudioSourceEvent {\n    constructor(audioSourceId, error) {\n        super(\"AudioSourceErrorEvent\", audioSourceId, EventType.Error);\n        this.privError = error;\n    }\n    get error() {\n        return this.privError;\n    }\n}\nexport class AudioStreamNodeEvent extends AudioSourceEvent {\n    constructor(eventName, audioSourceId, audioNodeId) {\n        super(eventName, audioSourceId);\n        this.privAudioNodeId = audioNodeId;\n    }\n    get audioNodeId() {\n        return this.privAudioNodeId;\n    }\n}\nexport class AudioStreamNodeAttachingEvent extends AudioStreamNodeEvent {\n    constructor(audioSourceId, audioNodeId) {\n        super(\"AudioStreamNodeAttachingEvent\", audioSourceId, audioNodeId);\n    }\n}\nexport class AudioStreamNodeAttachedEvent extends AudioStreamNodeEvent {\n    constructor(audioSourceId, audioNodeId) {\n        super(\"AudioStreamNodeAttachedEvent\", audioSourceId, audioNodeId);\n    }\n}\nexport class AudioStreamNodeDetachedEvent extends AudioStreamNodeEvent {\n    constructor(audioSourceId, audioNodeId) {\n        super(\"AudioStreamNodeDetachedEvent\", audioSourceId, audioNodeId);\n    }\n}\nexport class AudioStreamNodeErrorEvent extends AudioStreamNodeEvent {\n    constructor(audioSourceId, audioNodeId, error) {\n        super(\"AudioStreamNodeErrorEvent\", audioSourceId, audioNodeId);\n        this.privError = error;\n    }\n    get error() {\n        return this.privError;\n    }\n}\n\n//# sourceMappingURL=AudioSourceEvents.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { EventType, PlatformEvent } from \"./Exports\";\nexport class BackgroundEvent extends PlatformEvent {\n    constructor(error) {\n        super(\"BackgroundEvent\", EventType.Error);\n        this.privError = error;\n    }\n    get error() {\n        return this.privError;\n    }\n}\n\n//# sourceMappingURL=BackgroundError.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Stream } from \"./Exports\";\nexport class ChunkedArrayBufferStream extends Stream {\n    constructor(targetChunkSize, streamId) {\n        super(streamId);\n        this.privTargetChunkSize = targetChunkSize;\n        this.privNextBufferReadyBytes = 0;\n    }\n    writeStreamChunk(chunk) {\n        // No pending write, and the buffer is the right size so write it.\n        if (chunk.isEnd ||\n            (0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize)) {\n            super.writeStreamChunk(chunk);\n            return;\n        }\n        let bytesCopiedFromBuffer = 0;\n        while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\n            // Fill the next buffer.\n            if (undefined === this.privNextBufferToWrite) {\n                this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\n                this.privNextBufferStartTime = chunk.timeReceived;\n            }\n            // Find out how many bytes we can copy into the read buffer.\n            const bytesToCopy = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\n            const targetView = new Uint8Array(this.privNextBufferToWrite);\n            const sourceView = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\n            targetView.set(sourceView, this.privNextBufferReadyBytes);\n            this.privNextBufferReadyBytes += bytesToCopy;\n            bytesCopiedFromBuffer += bytesToCopy;\n            // Are we ready to write?\n            if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\n                super.writeStreamChunk({\n                    buffer: this.privNextBufferToWrite,\n                    isEnd: false,\n                    timeReceived: this.privNextBufferStartTime,\n                });\n                this.privNextBufferReadyBytes = 0;\n                this.privNextBufferToWrite = undefined;\n            }\n        }\n    }\n    close() {\n        // Send whatever is pending, then close the base class.\n        if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\n            super.writeStreamChunk({\n                buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\n                isEnd: false,\n                timeReceived: this.privNextBufferStartTime,\n            });\n        }\n        super.close();\n    }\n}\n\n//# sourceMappingURL=ChunkedArrayBufferStream.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { EventType, PlatformEvent } from \"./PlatformEvent\";\nexport class ServiceEvent extends PlatformEvent {\n    constructor(eventName, jsonstring, eventType = EventType.Info) {\n        super(eventName, eventType);\n        this.privJsonResult = jsonstring;\n    }\n    get jsonString() {\n        return this.privJsonResult;\n    }\n}\nexport class ConnectionEvent extends PlatformEvent {\n    constructor(eventName, connectionId, eventType = EventType.Info) {\n        super(eventName, eventType);\n        this.privConnectionId = connectionId;\n    }\n    get connectionId() {\n        return this.privConnectionId;\n    }\n}\nexport class ConnectionStartEvent extends ConnectionEvent {\n    constructor(connectionId, uri, headers) {\n        super(\"ConnectionStartEvent\", connectionId);\n        this.privUri = uri;\n        this.privHeaders = headers;\n    }\n    get uri() {\n        return this.privUri;\n    }\n    get headers() {\n        return this.privHeaders;\n    }\n}\nexport class ConnectionEstablishedEvent extends ConnectionEvent {\n    constructor(connectionId, metadata) {\n        super(\"ConnectionEstablishedEvent\", connectionId);\n    }\n}\nexport class ConnectionClosedEvent extends ConnectionEvent {\n    constructor(connectionId, statusCode, reason) {\n        super(\"ConnectionClosedEvent\", connectionId, EventType.Debug);\n        this.privReason = reason;\n        this.privStatusCode = statusCode;\n    }\n    get reason() {\n        return this.privReason;\n    }\n    get statusCode() {\n        return this.privStatusCode;\n    }\n}\nexport class ConnectionErrorEvent extends ConnectionEvent {\n    constructor(connectionId, message, type) {\n        super(\"ConnectionErrorEvent\", connectionId, EventType.Debug);\n        this.privMessage = message;\n        this.privType = type;\n    }\n    get message() {\n        return this.privMessage;\n    }\n    get type() {\n        return this.privType;\n    }\n}\nexport class ConnectionEstablishErrorEvent extends ConnectionEvent {\n    constructor(connectionId, statuscode, reason) {\n        super(\"ConnectionEstablishErrorEvent\", connectionId, EventType.Error);\n        this.privStatusCode = statuscode;\n        this.privReason = reason;\n    }\n    get reason() {\n        return this.privReason;\n    }\n    get statusCode() {\n        return this.privStatusCode;\n    }\n}\nexport class ConnectionMessageReceivedEvent extends ConnectionEvent {\n    constructor(connectionId, networkReceivedTimeISO, message) {\n        super(\"ConnectionMessageReceivedEvent\", connectionId);\n        this.privNetworkReceivedTime = networkReceivedTimeISO;\n        this.privMessage = message;\n    }\n    get networkReceivedTime() {\n        return this.privNetworkReceivedTime;\n    }\n    get message() {\n        return this.privMessage;\n    }\n}\nexport class ConnectionMessageSentEvent extends ConnectionEvent {\n    constructor(connectionId, networkSentTimeISO, message) {\n        super(\"ConnectionMessageSentEvent\", connectionId);\n        this.privNetworkSentTime = networkSentTimeISO;\n        this.privMessage = message;\n    }\n    get networkSentTime() {\n        return this.privNetworkSentTime;\n    }\n    get message() {\n        return this.privMessage;\n    }\n}\n\n//# sourceMappingURL=ConnectionEvents.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { InvalidOperationError } from \"./Error\";\nimport { createNoDashGuid } from \"./Guid\";\nexport var MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"Text\"] = 0] = \"Text\";\n    MessageType[MessageType[\"Binary\"] = 1] = \"Binary\";\n})(MessageType || (MessageType = {}));\nexport class ConnectionMessage {\n    constructor(messageType, body, headers, id) {\n        this.privBody = null;\n        if (messageType === MessageType.Text && body && !(typeof (body) === \"string\")) {\n            throw new InvalidOperationError(\"Payload must be a string\");\n        }\n        if (messageType === MessageType.Binary && body && !(body instanceof ArrayBuffer)) {\n            throw new InvalidOperationError(\"Payload must be ArrayBuffer\");\n        }\n        this.privMessageType = messageType;\n        this.privBody = body;\n        this.privHeaders = headers ? headers : {};\n        this.privId = id ? id : createNoDashGuid();\n        switch (this.messageType) {\n            case MessageType.Binary:\n                this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;\n                break;\n            case MessageType.Text:\n                this.privSize = this.textBody.length;\n        }\n    }\n    get messageType() {\n        return this.privMessageType;\n    }\n    get headers() {\n        return this.privHeaders;\n    }\n    get body() {\n        return this.privBody;\n    }\n    get textBody() {\n        if (this.privMessageType === MessageType.Binary) {\n            throw new InvalidOperationError(\"Not supported for binary message\");\n        }\n        return this.privBody;\n    }\n    get binaryBody() {\n        if (this.privMessageType === MessageType.Text) {\n            throw new InvalidOperationError(\"Not supported for text message\");\n        }\n        return this.privBody;\n    }\n    get id() {\n        return this.privId;\n    }\n}\n\n//# sourceMappingURL=ConnectionMessage.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class ConnectionOpenResponse {\n    constructor(statusCode, reason) {\n        this.privStatusCode = statusCode;\n        this.privReason = reason;\n    }\n    get statusCode() {\n        return this.privStatusCode;\n    }\n    get reason() {\n        return this.privReason;\n    }\n}\n\n//# sourceMappingURL=ConnectionOpenResponse.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { EventType, PlatformEvent } from \"./PlatformEvent\";\nexport class DialogEvent extends PlatformEvent {\n    constructor(eventName, eventType = EventType.Info) {\n        super(eventName, eventType);\n    }\n}\nexport class SendingAgentContextMessageEvent extends DialogEvent {\n    constructor(agentConfig) {\n        super(\"SendingAgentContextMessageEvent\");\n        this.privAgentConfig = agentConfig;\n    }\n    get agentConfig() {\n        return this.privAgentConfig;\n    }\n}\n\n//# sourceMappingURL=DialogEvents.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// tslint:disable:max-classes-per-file\n/**\n * The error that is thrown when an argument passed in is null.\n *\n * @export\n * @class ArgumentNullError\n * @extends {Error}\n */\nexport class ArgumentNullError extends Error {\n    /**\n     * Creates an instance of ArgumentNullError.\n     *\n     * @param {string} argumentName - Name of the argument that is null\n     *\n     * @memberOf ArgumentNullError\n     */\n    constructor(argumentName) {\n        super(argumentName);\n        this.name = \"ArgumentNull\";\n        this.message = argumentName;\n    }\n}\n/**\n * The error that is thrown when an invalid operation is performed in the code.\n *\n * @export\n * @class InvalidOperationError\n * @extends {Error}\n */\nexport class InvalidOperationError extends Error {\n    /**\n     * Creates an instance of InvalidOperationError.\n     *\n     * @param {string} error - The error\n     *\n     * @memberOf InvalidOperationError\n     */\n    constructor(error) {\n        super(error);\n        this.name = \"InvalidOperation\";\n        this.message = error;\n    }\n}\n/**\n * The error that is thrown when an object is disposed.\n *\n * @export\n * @class ObjectDisposedError\n * @extends {Error}\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class ObjectDisposedError extends Error {\n    /**\n     * Creates an instance of ObjectDisposedError.\n     *\n     * @param {string} objectName - The object that is disposed\n     * @param {string} error - The error\n     *\n     * @memberOf ObjectDisposedError\n     */\n    constructor(objectName, error) {\n        super(error);\n        this.name = objectName + \"ObjectDisposed\";\n        this.message = error;\n    }\n}\n\n//# sourceMappingURL=Error.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ObjectDisposedError } from \"./Error\";\nimport { createNoDashGuid } from \"./Guid\";\nexport class EventSource {\n    constructor(metadata) {\n        this.privEventListeners = {};\n        this.privIsDisposed = false;\n        this.onEvent = (event) => {\n            if (this.isDisposed()) {\n                throw (new ObjectDisposedError(\"EventSource\"));\n            }\n            if (this.metadata) {\n                for (const paramName in this.metadata) {\n                    if (paramName) {\n                        if (event.metadata) {\n                            if (!event.metadata[paramName]) {\n                                event.metadata[paramName] = this.metadata[paramName];\n                            }\n                        }\n                    }\n                }\n            }\n            for (const eventId in this.privEventListeners) {\n                if (eventId && this.privEventListeners[eventId]) {\n                    this.privEventListeners[eventId](event);\n                }\n            }\n        };\n        this.attach = (onEventCallback) => {\n            const id = createNoDashGuid();\n            this.privEventListeners[id] = onEventCallback;\n            return {\n                detach: () => {\n                    delete this.privEventListeners[id];\n                    return Promise.resolve();\n                },\n            };\n        };\n        this.attachListener = (listener) => {\n            return this.attach(listener.onEvent);\n        };\n        this.isDisposed = () => {\n            return this.privIsDisposed;\n        };\n        this.dispose = () => {\n            this.privEventListeners = null;\n            this.privIsDisposed = true;\n        };\n        this.privMetadata = metadata;\n    }\n    get metadata() {\n        return this.privMetadata;\n    }\n}\n\n//# sourceMappingURL=EventSource.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ArgumentNullError } from \"./Error\";\nimport { EventSource } from \"./EventSource\";\nexport class Events {\n    static get instance() {\n        return Events.privInstance;\n    }\n}\nEvents.privInstance = new EventSource();\nEvents.setEventSource = (eventSource) => {\n    if (!eventSource) {\n        throw new ArgumentNullError(\"eventSource\");\n    }\n    Events.privInstance = eventSource;\n};\n\n//# sourceMappingURL=Events.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport * from \"./AudioSourceEvents\";\nexport * from \"./ConnectionEvents\";\nexport * from \"./ConnectionMessage\";\nexport * from \"./ConnectionOpenResponse\";\nexport * from \"./DialogEvents\";\nexport * from \"./Error\";\nexport * from \"./Events\";\nexport * from \"./EventSource\";\nexport * from \"./Guid\";\nexport * from \"./IAudioSource\";\nexport * from \"./IConnection\";\nexport * from \"./IDetachable\";\nexport * from \"./IDictionary\";\nexport * from \"./IDisposable\";\nexport * from \"./IEventSource\";\nexport * from \"./IErrorMessages\";\nexport * from \"./ITimer\";\nexport * from \"./IWebsocketMessageFormatter\";\nexport * from \"./List\";\nexport * from \"./PlatformEvent\";\nexport * from \"./Promise\";\nexport * from \"./Queue\";\nexport * from \"./RawWebsocketMessage\";\nexport * from \"./RiffPcmEncoder\";\nexport * from \"./Stream\";\nexport { TranslationStatus } from \"../common.speech/TranslationStatus\";\nexport * from \"./ChunkedArrayBufferStream\";\nexport * from \"./IAudioDestination\";\nexport * from \"./Timeout\";\nexport * from \"./OCSPEvents\";\nexport * from \"./BackgroundError\";\n\n//# sourceMappingURL=Exports.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { v4 as uuid } from \"uuid\";\nconst createGuid = () => {\n    return uuid();\n};\nconst createNoDashGuid = () => {\n    return createGuid().replace(new RegExp(\"-\", \"g\"), \"\").toUpperCase();\n};\nexport { createGuid, createNoDashGuid };\n\n//# sourceMappingURL=Guid.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=IAudioDestination.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=IAudioSource.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport var ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[ConnectionState[\"None\"] = 0] = \"None\";\n    ConnectionState[ConnectionState[\"Connected\"] = 1] = \"Connected\";\n    ConnectionState[ConnectionState[\"Connecting\"] = 2] = \"Connecting\";\n    ConnectionState[ConnectionState[\"Disconnected\"] = 3] = \"Disconnected\";\n})(ConnectionState || (ConnectionState = {}));\n\n//# sourceMappingURL=IConnection.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=IDetachable.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=IDictionary.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=IDisposable.js.map\n","\n\n//# sourceMappingURL=IErrorMessages.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=IEventSource.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=ITimer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n//# sourceMappingURL=IWebsocketMessageFormatter.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ObjectDisposedError } from \"./Error\";\nexport class List {\n    constructor(list) {\n        this.privSubscriptionIdCounter = 0;\n        this.privAddSubscriptions = {};\n        this.privRemoveSubscriptions = {};\n        this.privDisposedSubscriptions = {};\n        this.privDisposeReason = null;\n        this.get = (itemIndex) => {\n            this.throwIfDisposed();\n            return this.privList[itemIndex];\n        };\n        this.first = () => {\n            return this.get(0);\n        };\n        this.last = () => {\n            return this.get(this.length() - 1);\n        };\n        this.add = (item) => {\n            this.throwIfDisposed();\n            this.insertAt(this.privList.length, item);\n        };\n        this.insertAt = (index, item) => {\n            this.throwIfDisposed();\n            if (index === 0) {\n                this.privList.unshift(item);\n            }\n            else if (index === this.privList.length) {\n                this.privList.push(item);\n            }\n            else {\n                this.privList.splice(index, 0, item);\n            }\n            this.triggerSubscriptions(this.privAddSubscriptions);\n        };\n        this.removeFirst = () => {\n            this.throwIfDisposed();\n            return this.removeAt(0);\n        };\n        this.removeLast = () => {\n            this.throwIfDisposed();\n            return this.removeAt(this.length() - 1);\n        };\n        this.removeAt = (index) => {\n            this.throwIfDisposed();\n            return this.remove(index, 1)[0];\n        };\n        this.remove = (index, count) => {\n            this.throwIfDisposed();\n            const removedElements = this.privList.splice(index, count);\n            this.triggerSubscriptions(this.privRemoveSubscriptions);\n            return removedElements;\n        };\n        this.clear = () => {\n            this.throwIfDisposed();\n            this.remove(0, this.length());\n        };\n        this.length = () => {\n            this.throwIfDisposed();\n            return this.privList.length;\n        };\n        this.onAdded = (addedCallback) => {\n            this.throwIfDisposed();\n            const subscriptionId = this.privSubscriptionIdCounter++;\n            this.privAddSubscriptions[subscriptionId] = addedCallback;\n            return {\n                detach: () => {\n                    delete this.privAddSubscriptions[subscriptionId];\n                    return Promise.resolve();\n                },\n            };\n        };\n        this.onRemoved = (removedCallback) => {\n            this.throwIfDisposed();\n            const subscriptionId = this.privSubscriptionIdCounter++;\n            this.privRemoveSubscriptions[subscriptionId] = removedCallback;\n            return {\n                detach: () => {\n                    delete this.privRemoveSubscriptions[subscriptionId];\n                    return Promise.resolve();\n                },\n            };\n        };\n        this.onDisposed = (disposedCallback) => {\n            this.throwIfDisposed();\n            const subscriptionId = this.privSubscriptionIdCounter++;\n            this.privDisposedSubscriptions[subscriptionId] = disposedCallback;\n            return {\n                detach: () => {\n                    delete this.privDisposedSubscriptions[subscriptionId];\n                    return Promise.resolve();\n                },\n            };\n        };\n        this.join = (seperator) => {\n            this.throwIfDisposed();\n            return this.privList.join(seperator);\n        };\n        this.toArray = () => {\n            const cloneCopy = Array();\n            this.privList.forEach((val) => {\n                cloneCopy.push(val);\n            });\n            return cloneCopy;\n        };\n        this.any = (callback) => {\n            this.throwIfDisposed();\n            if (callback) {\n                return this.where(callback).length() > 0;\n            }\n            else {\n                return this.length() > 0;\n            }\n        };\n        this.all = (callback) => {\n            this.throwIfDisposed();\n            return this.where(callback).length() === this.length();\n        };\n        this.forEach = (callback) => {\n            this.throwIfDisposed();\n            for (let i = 0; i < this.length(); i++) {\n                callback(this.privList[i], i);\n            }\n        };\n        this.select = (callback) => {\n            this.throwIfDisposed();\n            const selectList = [];\n            for (let i = 0; i < this.privList.length; i++) {\n                selectList.push(callback(this.privList[i], i));\n            }\n            return new List(selectList);\n        };\n        this.where = (callback) => {\n            this.throwIfDisposed();\n            const filteredList = new List();\n            for (let i = 0; i < this.privList.length; i++) {\n                if (callback(this.privList[i], i)) {\n                    filteredList.add(this.privList[i]);\n                }\n            }\n            return filteredList;\n        };\n        this.orderBy = (compareFn) => {\n            this.throwIfDisposed();\n            const clonedArray = this.toArray();\n            const orderedArray = clonedArray.sort(compareFn);\n            return new List(orderedArray);\n        };\n        this.orderByDesc = (compareFn) => {\n            this.throwIfDisposed();\n            return this.orderBy((a, b) => compareFn(b, a));\n        };\n        this.clone = () => {\n            this.throwIfDisposed();\n            return new List(this.toArray());\n        };\n        this.concat = (list) => {\n            this.throwIfDisposed();\n            return new List(this.privList.concat(list.toArray()));\n        };\n        this.concatArray = (array) => {\n            this.throwIfDisposed();\n            return new List(this.privList.concat(array));\n        };\n        this.isDisposed = () => {\n            return this.privList == null;\n        };\n        this.dispose = (reason) => {\n            if (!this.isDisposed()) {\n                this.privDisposeReason = reason;\n                this.privList = null;\n                this.privAddSubscriptions = null;\n                this.privRemoveSubscriptions = null;\n                this.triggerSubscriptions(this.privDisposedSubscriptions);\n            }\n        };\n        this.throwIfDisposed = () => {\n            if (this.isDisposed()) {\n                throw new ObjectDisposedError(\"List\", this.privDisposeReason);\n            }\n        };\n        this.triggerSubscriptions = (subscriptions) => {\n            if (subscriptions) {\n                for (const subscriptionId in subscriptions) {\n                    if (subscriptionId) {\n                        subscriptions[subscriptionId]();\n                    }\n                }\n            }\n        };\n        this.privList = [];\n        // copy the list rather than taking as is.\n        if (list) {\n            for (const item of list) {\n                this.privList.push(item);\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=List.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// tslint:disable:max-classes-per-file\nimport { EventType, PlatformEvent } from \"./PlatformEvent\";\nexport class OCSPEvent extends PlatformEvent {\n    constructor(eventName, eventType, signature) {\n        super(eventName, eventType);\n        this.privSignature = signature;\n    }\n}\nexport class OCSPMemoryCacheHitEvent extends OCSPEvent {\n    constructor(signature) {\n        super(\"OCSPMemoryCacheHitEvent\", EventType.Debug, signature);\n    }\n}\nexport class OCSPCacheMissEvent extends OCSPEvent {\n    constructor(signature) {\n        super(\"OCSPCacheMissEvent\", EventType.Debug, signature);\n    }\n}\nexport class OCSPDiskCacheHitEvent extends OCSPEvent {\n    constructor(signature) {\n        super(\"OCSPDiskCacheHitEvent\", EventType.Debug, signature);\n    }\n}\nexport class OCSPCacheUpdateNeededEvent extends OCSPEvent {\n    constructor(signature) {\n        super(\"OCSPCacheUpdateNeededEvent\", EventType.Debug, signature);\n    }\n}\nexport class OCSPMemoryCacheStoreEvent extends OCSPEvent {\n    constructor(signature) {\n        super(\"OCSPMemoryCacheStoreEvent\", EventType.Debug, signature);\n    }\n}\nexport class OCSPDiskCacheStoreEvent extends OCSPEvent {\n    constructor(signature) {\n        super(\"OCSPDiskCacheStoreEvent\", EventType.Debug, signature);\n    }\n}\nexport class OCSPCacheUpdatehCompleteEvent extends OCSPEvent {\n    constructor(signature) {\n        super(\"OCSPCacheUpdatehCompleteEvent\", EventType.Debug, signature);\n    }\n}\nexport class OCSPStapleReceivedEvent extends OCSPEvent {\n    constructor() {\n        super(\"OCSPStapleReceivedEvent\", EventType.Debug, \"\");\n    }\n}\nexport class OCSPWSUpgradeStartedEvent extends OCSPEvent {\n    constructor(serialNumber) {\n        super(\"OCSPWSUpgradeStartedEvent\", EventType.Debug, serialNumber);\n    }\n}\nexport class OCSPCacheEntryExpiredEvent extends OCSPEvent {\n    constructor(serialNumber, expireTime) {\n        super(\"OCSPCacheEntryExpiredEvent\", EventType.Debug, serialNumber);\n        this.privExpireTime = expireTime;\n    }\n}\nexport class OCSPCacheEntryNeedsRefreshEvent extends OCSPEvent {\n    constructor(serialNumber, startTime, expireTime) {\n        super(\"OCSPCacheEntryNeedsRefreshEvent\", EventType.Debug, serialNumber);\n        this.privExpireTime = expireTime;\n        this.privStartTime = startTime;\n    }\n}\nexport class OCSPCacheHitEvent extends OCSPEvent {\n    constructor(serialNumber, startTime, expireTime) {\n        super(\"OCSPCacheHitEvent\", EventType.Debug, serialNumber);\n        this.privExpireTime = expireTime;\n        this.privExpireTimeString = new Date(expireTime).toLocaleDateString();\n        this.privStartTime = startTime;\n        this.privStartTimeString = new Date(startTime).toLocaleTimeString();\n    }\n}\nexport class OCSPVerificationFailedEvent extends OCSPEvent {\n    constructor(serialNumber, error) {\n        super(\"OCSPVerificationFailedEvent\", EventType.Debug, serialNumber);\n        this.privError = error;\n    }\n}\nexport class OCSPCacheFetchErrorEvent extends OCSPEvent {\n    constructor(serialNumber, error) {\n        super(\"OCSPCacheFetchErrorEvent\", EventType.Debug, serialNumber);\n        this.privError = error;\n    }\n}\nexport class OCSPResponseRetrievedEvent extends OCSPEvent {\n    constructor(serialNumber) {\n        super(\"OCSPResponseRetrievedEvent\", EventType.Debug, serialNumber);\n    }\n}\nexport class OCSPCacheUpdateErrorEvent extends OCSPEvent {\n    constructor(serialNumber, error) {\n        super(\"OCSPCacheUpdateErrorEvent\", EventType.Debug, serialNumber);\n        this.privError = error;\n    }\n}\n\n//# sourceMappingURL=OCSPEvents.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { createNoDashGuid } from \"./Guid\";\nexport var EventType;\n(function (EventType) {\n    EventType[EventType[\"Debug\"] = 0] = \"Debug\";\n    EventType[EventType[\"Info\"] = 1] = \"Info\";\n    EventType[EventType[\"Warning\"] = 2] = \"Warning\";\n    EventType[EventType[\"Error\"] = 3] = \"Error\";\n})(EventType || (EventType = {}));\nexport class PlatformEvent {\n    constructor(eventName, eventType) {\n        this.privName = eventName;\n        this.privEventId = createNoDashGuid();\n        this.privEventTime = new Date().toISOString();\n        this.privEventType = eventType;\n        this.privMetadata = {};\n    }\n    get name() {\n        return this.privName;\n    }\n    get eventId() {\n        return this.privEventId;\n    }\n    get eventTime() {\n        return this.privEventTime;\n    }\n    get eventType() {\n        return this.privEventType;\n    }\n    get metadata() {\n        return this.privMetadata;\n    }\n}\n\n//# sourceMappingURL=PlatformEvent.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport var PromiseState;\n(function (PromiseState) {\n    PromiseState[PromiseState[\"None\"] = 0] = \"None\";\n    PromiseState[PromiseState[\"Resolved\"] = 1] = \"Resolved\";\n    PromiseState[PromiseState[\"Rejected\"] = 2] = \"Rejected\";\n})(PromiseState || (PromiseState = {}));\nexport class PromiseResult {\n    constructor(promiseResultEventSource) {\n        this.throwIfError = () => {\n            if (this.isError) {\n                throw this.error;\n            }\n        };\n        promiseResultEventSource.on((result) => {\n            if (!this.privIsCompleted) {\n                this.privIsCompleted = true;\n                this.privIsError = false;\n                this.privResult = result;\n            }\n        }, (error) => {\n            if (!this.privIsCompleted) {\n                this.privIsCompleted = true;\n                this.privIsError = true;\n                this.privError = error;\n            }\n        });\n    }\n    get isCompleted() {\n        return this.privIsCompleted;\n    }\n    get isError() {\n        return this.privIsError;\n    }\n    get error() {\n        return this.privError;\n    }\n    get result() {\n        return this.privResult;\n    }\n}\nexport class PromiseResultEventSource {\n    constructor() {\n        this.setResult = (result) => {\n            this.privOnSetResult(result);\n        };\n        this.setError = (error) => {\n            this.privOnSetError(error);\n        };\n        this.on = (onSetResult, onSetError) => {\n            this.privOnSetResult = onSetResult;\n            this.privOnSetError = onSetError;\n        };\n    }\n}\nexport class Deferred {\n    constructor() {\n        this.resolve = (result) => {\n            this.privResolve(result);\n            return this;\n        };\n        this.reject = (error) => {\n            this.privReject(error);\n            return this;\n        };\n        this.privPromise = new Promise((resolve, reject) => {\n            this.privResolve = resolve;\n            this.privReject = reject;\n        });\n    }\n    get promise() {\n        return this.privPromise;\n    }\n}\nexport class Sink {\n    constructor() {\n        this.privState = PromiseState.None;\n        this.privPromiseResult = null;\n        this.privPromiseResultEvents = null;\n        this.privSuccessHandlers = [];\n        this.privErrorHandlers = [];\n        this.resolve = (result) => {\n            if (this.privState !== PromiseState.None) {\n                throw new Error(\"'Cannot resolve a completed promise'\");\n            }\n            this.privState = PromiseState.Resolved;\n            this.privPromiseResultEvents.setResult(result);\n            for (let i = 0; i < this.privSuccessHandlers.length; i++) {\n                this.executeSuccessCallback(result, this.privSuccessHandlers[i], this.privErrorHandlers[i]);\n            }\n            this.detachHandlers();\n        };\n        this.reject = (error) => {\n            if (this.privState !== PromiseState.None) {\n                throw new Error(\"'Cannot reject a completed promise'\");\n            }\n            this.privState = PromiseState.Rejected;\n            this.privPromiseResultEvents.setError(error);\n            for (const errorHandler of this.privErrorHandlers) {\n                this.executeErrorCallback(error, errorHandler);\n            }\n            this.detachHandlers();\n        };\n        this.on = (successCallback, errorCallback) => {\n            if (successCallback == null) {\n                successCallback = (r) => { return; };\n            }\n            if (this.privState === PromiseState.None) {\n                this.privSuccessHandlers.push(successCallback);\n                this.privErrorHandlers.push(errorCallback);\n            }\n            else {\n                if (this.privState === PromiseState.Resolved) {\n                    this.executeSuccessCallback(this.privPromiseResult.result, successCallback, errorCallback);\n                }\n                else if (this.privState === PromiseState.Rejected) {\n                    this.executeErrorCallback(this.privPromiseResult.error, errorCallback);\n                }\n                this.detachHandlers();\n            }\n        };\n        this.executeSuccessCallback = (result, successCallback, errorCallback) => {\n            try {\n                successCallback(result);\n            }\n            catch (e) {\n                this.executeErrorCallback(`'Unhandled callback error: ${e}'`, errorCallback);\n            }\n        };\n        this.executeErrorCallback = (error, errorCallback) => {\n            if (errorCallback) {\n                try {\n                    errorCallback(error);\n                }\n                catch (e) {\n                    throw new Error(`'Unhandled callback error: ${e}. InnerError: ${error}'`);\n                }\n            }\n            else {\n                throw new Error(`'Unhandled error: ${error}'`);\n            }\n        };\n        this.detachHandlers = () => {\n            this.privErrorHandlers = [];\n            this.privSuccessHandlers = [];\n        };\n        this.privPromiseResultEvents = new PromiseResultEventSource();\n        this.privPromiseResult = new PromiseResult(this.privPromiseResultEvents);\n    }\n    get state() {\n        return this.privState;\n    }\n    get result() {\n        return this.privPromiseResult;\n    }\n}\nexport function marshalPromiseToCallbacks(promise, cb, err) {\n    promise.then((val) => {\n        try {\n            if (!!cb) {\n                cb(val);\n            }\n        }\n        catch (error) {\n            if (!!err) {\n                try {\n                    if (error instanceof Error) {\n                        const typedError = error;\n                        err(typedError.name + \": \" + typedError.message);\n                    }\n                    else {\n                        err(error);\n                    }\n                    /* tslint:disable:no-empty */\n                }\n                catch (error) { }\n            }\n        }\n    }, (error) => {\n        if (!!err) {\n            try {\n                if (error instanceof Error) {\n                    const typedError = error;\n                    err(typedError.name + \": \" + typedError.message);\n                }\n                else {\n                    err(error);\n                }\n                /* tslint:disable:no-empty */\n            }\n            catch (error) { }\n        }\n    });\n}\n\n//# sourceMappingURL=Promise.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { InvalidOperationError, ObjectDisposedError } from \"./Error\";\nimport { List } from \"./List\";\nimport { Deferred, } from \"./Promise\";\nvar SubscriberType;\n(function (SubscriberType) {\n    SubscriberType[SubscriberType[\"Dequeue\"] = 0] = \"Dequeue\";\n    SubscriberType[SubscriberType[\"Peek\"] = 1] = \"Peek\";\n})(SubscriberType || (SubscriberType = {}));\nexport class Queue {\n    constructor(list) {\n        this.privPromiseStore = new List();\n        this.privIsDrainInProgress = false;\n        this.privIsDisposing = false;\n        this.privDisposeReason = null;\n        this.enqueue = (item) => {\n            this.throwIfDispose();\n            this.enqueueFromPromise(new Promise((resolve, reject) => { resolve(item); }));\n        };\n        this.enqueueFromPromise = (promise) => {\n            this.throwIfDispose();\n            promise.then((val) => {\n                this.privList.add(val);\n                /* tslint:disable:no-empty */\n            }, (error) => { });\n        };\n        this.dequeue = () => {\n            this.throwIfDispose();\n            const deferredSubscriber = new Deferred();\n            if (this.privSubscribers) {\n                this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Dequeue });\n                this.drain();\n            }\n            return deferredSubscriber.promise;\n        };\n        this.peek = () => {\n            this.throwIfDispose();\n            const deferredSubscriber = new Deferred();\n            const subs = this.privSubscribers;\n            if (subs) {\n                this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Peek });\n                this.drain();\n            }\n            return deferredSubscriber.promise;\n        };\n        this.length = () => {\n            this.throwIfDispose();\n            return this.privList.length();\n        };\n        this.isDisposed = () => {\n            return this.privSubscribers == null;\n        };\n        this.drain = () => {\n            if (!this.privIsDrainInProgress && !this.privIsDisposing) {\n                this.privIsDrainInProgress = true;\n                const subs = this.privSubscribers;\n                const lists = this.privList;\n                if (subs && lists) {\n                    while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\n                        const subscriber = subs.removeFirst();\n                        if (subscriber.type === SubscriberType.Peek) {\n                            subscriber.deferral.resolve(lists.first());\n                        }\n                        else {\n                            const dequeuedItem = lists.removeFirst();\n                            subscriber.deferral.resolve(dequeuedItem);\n                        }\n                    }\n                    // note: this block assumes cooperative multitasking, i.e.,\n                    // between the if-statement and the assignment there are no\n                    // thread switches.\n                    // Reason is that between the initial const = this.; and this\n                    // point there is the derral.resolve() operation that might have\n                    // caused recursive calls to the Queue, especially, calling\n                    // Dispose() on the queue alredy (which would reset the var\n                    // here to null!).\n                    // That should generally hold true for javascript...\n                    if (this.privSubscribers === subs) {\n                        this.privSubscribers = subs;\n                    }\n                    // note: this block assumes cooperative multitasking, i.e.,\n                    // between the if-statement and the assignment there are no\n                    // thread switches.\n                    // Reason is that between the initial const = this.; and this\n                    // point there is the derral.resolve() operation that might have\n                    // caused recursive calls to the Queue, especially, calling\n                    // Dispose() on the queue alredy (which would reset the var\n                    // here to null!).\n                    // That should generally hold true for javascript...\n                    if (this.privList === lists) {\n                        this.privList = lists;\n                    }\n                }\n                this.privIsDrainInProgress = false;\n            }\n        };\n        this.throwIfDispose = () => {\n            if (this.isDisposed()) {\n                if (this.privDisposeReason) {\n                    throw new InvalidOperationError(this.privDisposeReason);\n                }\n                throw new ObjectDisposedError(\"Queue\");\n            }\n            else if (this.privIsDisposing) {\n                throw new InvalidOperationError(\"Queue disposing\");\n            }\n        };\n        this.privList = list ? list : new List();\n        this.privDetachables = [];\n        this.privSubscribers = new List();\n        this.privDetachables.push(this.privList.onAdded(this.drain));\n    }\n    drainAndDispose(pendingItemProcessor, reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isDisposed() && !this.privIsDisposing) {\n                this.privDisposeReason = reason;\n                this.privIsDisposing = true;\n                const subs = this.privSubscribers;\n                if (subs) {\n                    while (subs.length() > 0) {\n                        const subscriber = subs.removeFirst();\n                        // TODO: this needs work (Resolve(null) instead?).\n                        subscriber.deferral.resolve(undefined);\n                        // subscriber.deferral.reject(\"Disposed\");\n                    }\n                    // note: this block assumes cooperative multitasking, i.e.,\n                    // between the if-statement and the assignment there are no\n                    // thread switches.\n                    // Reason is that between the initial const = this.; and this\n                    // point there is the derral.resolve() operation that might have\n                    // caused recursive calls to the Queue, especially, calling\n                    // Dispose() on the queue alredy (which would reset the var\n                    // here to null!).\n                    // That should generally hold true for javascript...\n                    if (this.privSubscribers === subs) {\n                        this.privSubscribers = subs;\n                    }\n                }\n                for (const detachable of this.privDetachables) {\n                    yield detachable.detach();\n                }\n                if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\n                    const promiseArray = [];\n                    this.privPromiseStore.toArray().forEach((wrapper) => {\n                        promiseArray.push(wrapper);\n                    });\n                    return Promise.all(promiseArray).finally(() => {\n                        this.privSubscribers = null;\n                        this.privList.forEach((item, index) => {\n                            pendingItemProcessor(item);\n                        });\n                        this.privList = null;\n                        return;\n                    }).then();\n                }\n                else {\n                    this.privSubscribers = null;\n                    this.privList = null;\n                }\n            }\n        });\n    }\n    dispose(reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.drainAndDispose(null, reason);\n        });\n    }\n}\n\n//# sourceMappingURL=Queue.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { MessageType } from \"./ConnectionMessage\";\nimport { ArgumentNullError, InvalidOperationError } from \"./Error\";\nimport { createNoDashGuid } from \"./Guid\";\nexport class RawWebsocketMessage {\n    constructor(messageType, payload, id) {\n        this.privPayload = null;\n        if (!payload) {\n            throw new ArgumentNullError(\"payload\");\n        }\n        if (messageType === MessageType.Binary && payload.__proto__.constructor.name !== \"ArrayBuffer\") {\n            throw new InvalidOperationError(\"Payload must be ArrayBuffer\");\n        }\n        if (messageType === MessageType.Text && !(typeof (payload) === \"string\")) {\n            throw new InvalidOperationError(\"Payload must be a string\");\n        }\n        this.privMessageType = messageType;\n        this.privPayload = payload;\n        this.privId = id ? id : createNoDashGuid();\n    }\n    get messageType() {\n        return this.privMessageType;\n    }\n    get payload() {\n        return this.privPayload;\n    }\n    get textContent() {\n        if (this.privMessageType === MessageType.Binary) {\n            throw new InvalidOperationError(\"Not supported for binary message\");\n        }\n        return this.privPayload;\n    }\n    get binaryContent() {\n        if (this.privMessageType === MessageType.Text) {\n            throw new InvalidOperationError(\"Not supported for text message\");\n        }\n        return this.privPayload;\n    }\n    get id() {\n        return this.privId;\n    }\n}\n\n//# sourceMappingURL=RawWebsocketMessage.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class RiffPcmEncoder {\n    constructor(actualSampleRate, desiredSampleRate) {\n        this.encode = (actualAudioFrame) => {\n            const audioFrame = this.downSampleAudioFrame(actualAudioFrame, this.privActualSampleRate, this.privDesiredSampleRate);\n            if (!audioFrame) {\n                return null;\n            }\n            const audioLength = audioFrame.length * 2;\n            const buffer = new ArrayBuffer(audioLength);\n            const view = new DataView(buffer);\n            this.floatTo16BitPCM(view, 0, audioFrame);\n            return buffer;\n        };\n        this.setString = (view, offset, str) => {\n            for (let i = 0; i < str.length; i++) {\n                view.setUint8(offset + i, str.charCodeAt(i));\n            }\n        };\n        this.floatTo16BitPCM = (view, offset, input) => {\n            for (let i = 0; i < input.length; i++, offset += 2) {\n                const s = Math.max(-1, Math.min(1, input[i]));\n                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n            }\n        };\n        this.downSampleAudioFrame = (srcFrame, srcRate, dstRate) => {\n            if (!srcFrame) {\n                return null;\n            }\n            if (dstRate === srcRate || dstRate > srcRate) {\n                return srcFrame;\n            }\n            const ratio = srcRate / dstRate;\n            const dstLength = Math.round(srcFrame.length / ratio);\n            const dstFrame = new Float32Array(dstLength);\n            let srcOffset = 0;\n            let dstOffset = 0;\n            while (dstOffset < dstLength) {\n                const nextSrcOffset = Math.round((dstOffset + 1) * ratio);\n                let accum = 0;\n                let count = 0;\n                while (srcOffset < nextSrcOffset && srcOffset < srcFrame.length) {\n                    accum += srcFrame[srcOffset++];\n                    count++;\n                }\n                dstFrame[dstOffset++] = accum / count;\n            }\n            return dstFrame;\n        };\n        this.privActualSampleRate = actualSampleRate;\n        this.privDesiredSampleRate = desiredSampleRate;\n    }\n}\n\n//# sourceMappingURL=RiffPcmEncoder.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { InvalidOperationError } from \"./Error\";\nimport { createNoDashGuid } from \"./Guid\";\nimport { Queue } from \"./Queue\";\nexport class Stream {\n    constructor(streamId) {\n        this.privIsWriteEnded = false;\n        this.privIsReadEnded = false;\n        this.read = () => {\n            if (this.privIsReadEnded) {\n                throw new InvalidOperationError(\"Stream read has already finished\");\n            }\n            return this.privReaderQueue\n                .dequeue()\n                .then((streamChunk) => __awaiter(this, void 0, void 0, function* () {\n                if (streamChunk === undefined || streamChunk.isEnd) {\n                    yield this.privReaderQueue.dispose(\"End of stream reached\");\n                }\n                return streamChunk;\n            }));\n        };\n        this.readEnded = () => {\n            if (!this.privIsReadEnded) {\n                this.privIsReadEnded = true;\n                this.privReaderQueue = new Queue();\n            }\n        };\n        this.throwIfClosed = () => {\n            if (this.privIsWriteEnded) {\n                throw new InvalidOperationError(\"Stream closed\");\n            }\n        };\n        this.privId = streamId ? streamId : createNoDashGuid();\n        this.privReaderQueue = new Queue();\n    }\n    get isClosed() {\n        return this.privIsWriteEnded;\n    }\n    get isReadEnded() {\n        return this.privIsReadEnded;\n    }\n    get id() {\n        return this.privId;\n    }\n    close() {\n        if (!this.privIsWriteEnded) {\n            this.writeStreamChunk({\n                buffer: null,\n                isEnd: true,\n                timeReceived: Date.now(),\n            });\n            this.privIsWriteEnded = true;\n        }\n    }\n    writeStreamChunk(streamChunk) {\n        this.throwIfClosed();\n        if (!this.privReaderQueue.isDisposed()) {\n            try {\n                this.privReaderQueue.enqueue(streamChunk);\n            }\n            catch (e) {\n                // Do nothing\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=Stream.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class Timeout {\n}\nTimeout.workerTimers = null;\nTimeout.clearTimeout = (timerId) => Timeout.timers().clearTimeout(timerId);\nTimeout.setTimeout = (func, delay) => Timeout.timers().setTimeout(func, delay);\nTimeout.load = (url) => {\n    // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.\n    const scheduledTimeoutFunctions = new Map([[0, () => { }]]); // tslint:disable-line no-empty\n    const unhandledRequests = new Map();\n    const worker = new Worker(url);\n    worker.addEventListener(\"message\", ({ data }) => {\n        if (Timeout.isCallNotification(data)) {\n            const { params: { timerId } } = data;\n            const idOrFunc = scheduledTimeoutFunctions.get(timerId);\n            if (typeof idOrFunc === \"number\") {\n                const unhandledTimerId = unhandledRequests.get(idOrFunc);\n                if (unhandledTimerId === undefined ||\n                    unhandledTimerId !== timerId) {\n                    throw new Error(\"The timer is in an undefined state.\");\n                }\n            }\n            else if (typeof idOrFunc !== \"undefined\") {\n                idOrFunc();\n                // A timeout can be safely deleted because it is only called once.\n                scheduledTimeoutFunctions.delete(timerId);\n            }\n            else {\n                throw new Error(\"The timer is in an undefined state.\");\n            }\n        }\n        else if (Timeout.isClearResponse(data)) {\n            const { id } = data;\n            const unhandledTimerId = unhandledRequests.get(id);\n            if (unhandledTimerId === undefined) {\n                throw new Error(\"The timer is in an undefined state.\");\n            }\n            unhandledRequests.delete(id);\n            scheduledTimeoutFunctions.delete(unhandledTimerId);\n        }\n        else {\n            const { error: { message } } = data;\n            throw new Error(message);\n        }\n    });\n    const clearTimeout = (timerId) => {\n        const id = Math.random();\n        unhandledRequests.set(id, timerId);\n        scheduledTimeoutFunctions.set(timerId, id);\n        worker.postMessage({\n            id,\n            method: \"clear\",\n            params: { timerId }\n        });\n    };\n    const setTimeout = (func, delay) => {\n        const timerId = Math.random();\n        scheduledTimeoutFunctions.set(timerId, func);\n        worker.postMessage({\n            id: null,\n            method: \"set\",\n            params: {\n                delay,\n                now: performance.now(),\n                timerId\n            }\n        });\n        return timerId;\n    };\n    return {\n        clearTimeout,\n        setTimeout\n    };\n};\nTimeout.loadWorkerTimers = () => {\n    const worker = `!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=14)}([function(e,t,n){\"use strict\";n.d(t,\"a\",(function(){return i})),n.d(t,\"b\",(function(){return u})),n.d(t,\"c\",(function(){return a})),n.d(t,\"d\",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error('There is no interval scheduled with the given id \"'.concat(e,'\".'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error('There is no timeout scheduled with the given id \"'.concat(e,'\".'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if(\"performance\"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o=\"performance\"in self?performance.now():Date.now();o>n?postMessage({id:null,method:\"call\",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){\"use strict\";n.r(t);var r=n(2);for(var o in r)\"default\"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)\"default\"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)\"default\"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)\"default\"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)\"default\"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)\"default\"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)\"default\"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)\"default\"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){\"use strict\";n.r(t);var r=n(11);for(var o in r)\"default\"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)\"default\"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)\"default\"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){\"use strict\";n.r(t);var r=n(0),o=n(1);for(var i in o)\"default\"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)\"default\"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener(\"message\",({data:e})=>{try{if(\"clear\"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if(\"set\"!==e.method)throw new Error('The given method \"'.concat(e.method,'\" is not supported'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);`; // tslint:disable-line:max-line-length\n    return () => {\n        if (Timeout.workerTimers !== null) {\n            return Timeout.workerTimers;\n        }\n        const blob = new Blob([worker], { type: \"application/javascript; charset=utf-8\" });\n        const url = URL.createObjectURL(blob);\n        Timeout.workerTimers = Timeout.load(url);\n        // Edge doesn't like the URL to be revoked directly.\n        Timeout.workerTimers.setTimeout(() => URL.revokeObjectURL(url), 0);\n        return Timeout.workerTimers;\n    };\n};\nTimeout.timers = Timeout.loadWorkerTimers();\nTimeout.isCallNotification = (message) => {\n    return message.method !== undefined && message.method === \"call\";\n};\nTimeout.isClearResponse = (message) => {\n    return message.error === null && typeof message.id === \"number\";\n};\n\n//# sourceMappingURL=Timeout.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines contents of received message/events.\n * @class ActivityReceivedEventArgs\n */\nexport class ActivityReceivedEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {any} activity - The activity..\n     */\n    constructor(activity, audioStream) {\n        this.privActivity = activity;\n        this.privAudioStream = audioStream;\n    }\n    /**\n     * Gets the received activity\n     * @member ActivityReceivedEventArgs.prototype.activity\n     * @function\n     * @public\n     * @returns {any} the received activity.\n     */\n    get activity() {\n        return this.privActivity;\n    }\n    get audioStream() {\n        return this.privAudioStream;\n    }\n}\n\n//# sourceMappingURL=ActivityReceivedEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { FileAudioSource, MicAudioSource, PcmRecorder, } from \"../../common.browser/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { AudioInputStream, PullAudioInputStreamCallback, PullAudioOutputStream, PushAudioOutputStream, PushAudioOutputStreamCallback, SpeakerAudioDestination } from \"../Exports\";\nimport { AudioFileWriter } from \"./AudioFileWriter\";\nimport { PullAudioInputStreamImpl } from \"./AudioInputStream\";\nimport { PushAudioOutputStreamImpl } from \"./AudioOutputStream\";\n/**\n * Represents audio input configuration used for specifying what type of input to use (microphone, file, stream).\n * @class AudioConfig\n * Updated in version 1.11.0\n */\nexport class AudioConfig {\n    /**\n     * Creates an AudioConfig object representing the default microphone on the system.\n     * @member AudioConfig.fromDefaultMicrophoneInput\n     * @function\n     * @public\n     * @returns {AudioConfig} The audio input configuration being created.\n     */\n    static fromDefaultMicrophoneInput() {\n        const pcmRecorder = new PcmRecorder(true);\n        return new AudioConfigImpl(new MicAudioSource(pcmRecorder));\n    }\n    /**\n     * Creates an AudioConfig object representing a microphone with the specified device ID.\n     * @member AudioConfig.fromMicrophoneInput\n     * @function\n     * @public\n     * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.\n     *        Default microphone is used the value is omitted.\n     * @returns {AudioConfig} The audio input configuration being created.\n     */\n    static fromMicrophoneInput(deviceId) {\n        const pcmRecorder = new PcmRecorder(true);\n        return new AudioConfigImpl(new MicAudioSource(pcmRecorder, deviceId));\n    }\n    /**\n     * Creates an AudioConfig object representing the specified file.\n     * @member AudioConfig.fromWavFileInput\n     * @function\n     * @public\n     * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.\n     * @returns {AudioConfig} The audio input configuration being created.\n     */\n    static fromWavFileInput(file, name = \"unnamedBuffer.wav\") {\n        return new AudioConfigImpl(new FileAudioSource(file, name));\n    }\n    /**\n     * Creates an AudioConfig object representing the specified stream.\n     * @member AudioConfig.fromStreamInput\n     * @function\n     * @public\n     * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input\n     *        stream. Currently, only WAV / PCM is supported.\n     * @returns {AudioConfig} The audio input configuration being created.\n     */\n    static fromStreamInput(audioStream) {\n        if (audioStream instanceof PullAudioInputStreamCallback) {\n            return new AudioConfigImpl(new PullAudioInputStreamImpl(audioStream));\n        }\n        if (audioStream instanceof AudioInputStream) {\n            return new AudioConfigImpl(audioStream);\n        }\n        if (typeof MediaStream !== \"undefined\" && audioStream instanceof MediaStream) {\n            const pcmRecorder = new PcmRecorder(false);\n            return new AudioConfigImpl(new MicAudioSource(pcmRecorder, null, null, audioStream));\n        }\n        throw new Error(\"Not Supported Type\");\n    }\n    /**\n     * Creates an AudioConfig object representing the default speaker.\n     * @member AudioConfig.fromDefaultSpeakerOutput\n     * @function\n     * @public\n     * @returns {AudioConfig} The audio output configuration being created.\n     * Added in version 1.11.0\n     */\n    static fromDefaultSpeakerOutput() {\n        return new AudioOutputConfigImpl(new SpeakerAudioDestination());\n    }\n    /**\n     * Creates an AudioConfig object representing the custom IPlayer object.\n     * You can use the IPlayer object to control pause, resume, etc.\n     * @member AudioConfig.fromSpeakerOutput\n     * @function\n     * @public\n     * @param {IPlayer} player - the IPlayer object for playback.\n     * @returns {AudioConfig} The audio output configuration being created.\n     * Added in version 1.12.0\n     */\n    static fromSpeakerOutput(player) {\n        if (player === undefined) {\n            return AudioConfig.fromDefaultSpeakerOutput();\n        }\n        if (player instanceof SpeakerAudioDestination) {\n            return new AudioOutputConfigImpl(player);\n        }\n        throw new Error(\"Not Supported Type\");\n    }\n    /**\n     * Creates an AudioConfig object representing a specified output audio file\n     * @member AudioConfig.fromAudioFileOutput\n     * @function\n     * @public\n     * @param {PathLike} filename - the filename of the output audio file\n     * @returns {AudioConfig} The audio output configuration being created.\n     * Added in version 1.11.0\n     */\n    static fromAudioFileOutput(filename) {\n        return new AudioOutputConfigImpl(new AudioFileWriter(filename));\n    }\n    /**\n     * Creates an AudioConfig object representing a specified audio output stream\n     * @member AudioConfig.fromStreamOutput\n     * @function\n     * @public\n     * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output\n     *        stream.\n     * @returns {AudioConfig} The audio output configuration being created.\n     * Added in version 1.11.0\n     */\n    static fromStreamOutput(audioStream) {\n        if (audioStream instanceof PushAudioOutputStreamCallback) {\n            return new AudioOutputConfigImpl(new PushAudioOutputStreamImpl(audioStream));\n        }\n        if (audioStream instanceof PushAudioOutputStream) {\n            return new AudioOutputConfigImpl(audioStream);\n        }\n        if (audioStream instanceof PullAudioOutputStream) {\n            return new AudioOutputConfigImpl(audioStream);\n        }\n        throw new Error(\"Not Supported Type\");\n    }\n}\n/**\n * Represents audio input stream used for custom audio input configurations.\n * @private\n * @class AudioConfigImpl\n */\nexport class AudioConfigImpl extends AudioConfig {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {IAudioSource} source - An audio source.\n     */\n    constructor(source) {\n        super();\n        this.privSource = source;\n    }\n    /**\n     * Format information for the audio\n     */\n    get format() {\n        return this.privSource.format;\n    }\n    /**\n     * @member AudioConfigImpl.prototype.close\n     * @function\n     * @public\n     */\n    close(cb, err) {\n        this.privSource.turnOff().then(() => {\n            if (!!cb) {\n                cb();\n            }\n        }, (error) => {\n            if (!!err) {\n                err(error);\n            }\n        });\n    }\n    /**\n     * @member AudioConfigImpl.prototype.id\n     * @function\n     * @public\n     */\n    id() {\n        return this.privSource.id();\n    }\n    /**\n     * @member AudioConfigImpl.prototype.blob\n     * @function\n     * @public\n     */\n    get blob() {\n        return this.privSource.blob;\n    }\n    /**\n     * @member AudioConfigImpl.prototype.turnOn\n     * @function\n     * @public\n     * @returns {Promise<void>} A promise.\n     */\n    turnOn() {\n        return this.privSource.turnOn();\n    }\n    /**\n     * @member AudioConfigImpl.prototype.attach\n     * @function\n     * @public\n     * @param {string} audioNodeId - The audio node id.\n     * @returns {Promise<IAudioStreamNode>} A promise.\n     */\n    attach(audioNodeId) {\n        return this.privSource.attach(audioNodeId);\n    }\n    /**\n     * @member AudioConfigImpl.prototype.detach\n     * @function\n     * @public\n     * @param {string} audioNodeId - The audio node id.\n     */\n    detach(audioNodeId) {\n        return this.privSource.detach(audioNodeId);\n    }\n    /**\n     * @member AudioConfigImpl.prototype.turnOff\n     * @function\n     * @public\n     * @returns {Promise<void>} A promise.\n     */\n    turnOff() {\n        return this.privSource.turnOff();\n    }\n    /**\n     * @member AudioConfigImpl.prototype.events\n     * @function\n     * @public\n     * @returns {EventSource<AudioSourceEvent>} An event source for audio events.\n     */\n    get events() {\n        return this.privSource.events;\n    }\n    setProperty(name, value) {\n        Contracts.throwIfNull(value, \"value\");\n        if (undefined !== this.privSource.setProperty) {\n            this.privSource.setProperty(name, value);\n        }\n        else {\n            throw new Error(\"This AudioConfig instance does not support setting properties.\");\n        }\n    }\n    getProperty(name, def) {\n        if (undefined !== this.privSource.getProperty) {\n            return this.privSource.getProperty(name, def);\n        }\n        else {\n            throw new Error(\"This AudioConfig instance does not support getting properties.\");\n        }\n        return def;\n    }\n    get deviceInfo() {\n        return this.privSource.deviceInfo;\n    }\n}\nexport class AudioOutputConfigImpl extends AudioConfig {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {IAudioDestination} destination - An audio destination.\n     */\n    constructor(destination) {\n        super();\n        this.privDestination = destination;\n    }\n    set format(format) {\n        this.privDestination.format = format;\n    }\n    write(buffer) {\n        this.privDestination.write(buffer);\n    }\n    close() {\n        this.privDestination.close();\n    }\n    id() {\n        return this.privDestination.id();\n    }\n    setProperty(name, value) {\n        throw new Error(\"This AudioConfig instance does not support setting properties.\");\n    }\n    getProperty(name, def) {\n        throw new Error(\"This AudioConfig instance does not support getting properties.\");\n    }\n}\n\n//# sourceMappingURL=AudioConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport * as fs from \"fs\";\nimport { Contracts } from \"../Contracts\";\nexport class AudioFileWriter {\n    constructor(filename) {\n        this.id = () => {\n            return this.privId;\n        };\n        Contracts.throwIfNullOrUndefined(fs.openSync, \"\\nFile System access not available, please use Push or PullAudioOutputStream\");\n        this.privFd = fs.openSync(filename, \"w\");\n    }\n    set format(format) {\n        Contracts.throwIfNotUndefined(this.privAudioFormat, \"format is already set\");\n        this.privAudioFormat = format;\n        let headerOffset = 0;\n        if (this.privAudioFormat.hasHeader) {\n            headerOffset = this.privAudioFormat.header.byteLength;\n        }\n        if (this.privFd !== undefined) {\n            this.privWriteStream = fs.createWriteStream(\"\", { fd: this.privFd, start: headerOffset, autoClose: false });\n        }\n    }\n    write(buffer) {\n        Contracts.throwIfNullOrUndefined(this.privAudioFormat, \"must set format before writing.\");\n        if (this.privWriteStream !== undefined) {\n            this.privWriteStream.write(new Uint8Array(buffer.slice(0)));\n        }\n    }\n    close() {\n        if (this.privFd !== undefined) {\n            this.privWriteStream.on(\"finish\", () => {\n                if (this.privAudioFormat.hasHeader) {\n                    this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten);\n                    fs.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0);\n                }\n                fs.closeSync(this.privFd);\n                this.privFd = undefined;\n            });\n            this.privWriteStream.end();\n        }\n    }\n}\n\n//# sourceMappingURL=AudioFileWriter.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// tslint:disable:max-classes-per-file\nimport { connectivity, type, } from \"../../common.speech/Exports\";\nimport { AudioSourceInitializingEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, ChunkedArrayBufferStream, Events, EventSource, } from \"../../common/Exports\";\nimport { createNoDashGuid } from \"../../common/Guid\";\nimport { AudioStreamFormat } from \"../Exports\";\nimport { AudioStreamFormatImpl } from \"./AudioStreamFormat\";\n/**\n * Represents audio input stream used for custom audio input configurations.\n * @class AudioInputStream\n */\nexport class AudioInputStream {\n    /**\n     * Creates and initializes an instance.\n     * @constructor\n     */\n    constructor() { }\n    /**\n     * Creates a memory backed PushAudioInputStream with the specified audio format.\n     * @member AudioInputStream.createPushStream\n     * @function\n     * @public\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be\n     *        written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).\n     * @returns {PushAudioInputStream} The audio input stream being created.\n     */\n    static createPushStream(format) {\n        return PushAudioInputStream.create(format);\n    }\n    /**\n     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()\n     * and close() methods.\n     * @member AudioInputStream.createPullStream\n     * @function\n     * @public\n     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from\n     *        PullAudioInputStreamCallback\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from\n     *        the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n     * @returns {PullAudioInputStream} The audio input stream being created.\n     */\n    static createPullStream(callback, format) {\n        return PullAudioInputStream.create(callback, format);\n        // throw new Error(\"Oops\");\n    }\n}\n/**\n * Represents memory backed push audio input stream used for custom audio input configurations.\n * @class PushAudioInputStream\n */\nexport class PushAudioInputStream extends AudioInputStream {\n    /**\n     * Creates a memory backed PushAudioInputStream with the specified audio format.\n     * @member PushAudioInputStream.create\n     * @function\n     * @public\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the\n     *        push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).\n     * @returns {PushAudioInputStream} The push audio input stream being created.\n     */\n    static create(format) {\n        return new PushAudioInputStreamImpl(format);\n    }\n}\n/**\n * Represents memory backed push audio input stream used for custom audio input configurations.\n * @private\n * @class PushAudioInputStreamImpl\n */\nexport class PushAudioInputStreamImpl extends PushAudioInputStream {\n    /**\n     * Creates and initalizes an instance with the given values.\n     * @constructor\n     * @param {AudioStreamFormat} format - The audio stream format.\n     */\n    constructor(format) {\n        super();\n        this.onEvent = (event) => {\n            this.privEvents.onEvent(event);\n            Events.instance.onEvent(event);\n        };\n        if (format === undefined) {\n            this.privFormat = AudioStreamFormatImpl.getDefaultInputFormat();\n        }\n        else {\n            this.privFormat = format;\n        }\n        this.privEvents = new EventSource();\n        this.privId = createNoDashGuid();\n        this.privStream = new ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);\n    }\n    /**\n     * Format information for the audio\n     */\n    get format() {\n        return Promise.resolve(this.privFormat);\n    }\n    /**\n     * Writes the audio data specified by making an internal copy of the data.\n     * @member PushAudioInputStreamImpl.prototype.write\n     * @function\n     * @public\n     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.\n     */\n    write(dataBuffer) {\n        this.privStream.writeStreamChunk({\n            buffer: dataBuffer,\n            isEnd: false,\n            timeReceived: Date.now()\n        });\n    }\n    /**\n     * Closes the stream.\n     * @member PushAudioInputStreamImpl.prototype.close\n     * @function\n     * @public\n     */\n    close() {\n        this.privStream.close();\n    }\n    id() {\n        return this.privId;\n    }\n    get blob() {\n        return this.attach(\"id\").then((audioNode) => {\n            const data = [];\n            let bufferData = Buffer.from(\"\");\n            const readCycle = () => {\n                return audioNode.read().then((audioStreamChunk) => {\n                    if (!audioStreamChunk || audioStreamChunk.isEnd) {\n                        if (typeof (XMLHttpRequest) !== \"undefined\" && typeof (Blob) !== \"undefined\") {\n                            return Promise.resolve(new Blob(data));\n                        }\n                        else {\n                            return Promise.resolve(Buffer.from(bufferData));\n                        }\n                    }\n                    else {\n                        if (typeof (Blob) !== \"undefined\") {\n                            data.push(audioStreamChunk.buffer);\n                        }\n                        else {\n                            bufferData = Buffer.concat([bufferData, this.toBuffer(audioStreamChunk.buffer)]);\n                        }\n                        return readCycle();\n                    }\n                });\n            };\n            return readCycle();\n        });\n    }\n    turnOn() {\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\n        return;\n    }\n    attach(audioNodeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n            yield this.turnOn();\n            const stream = this.privStream;\n            this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n            return {\n                detach: () => __awaiter(this, void 0, void 0, function* () {\n                    this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                    return this.turnOff();\n                }),\n                id: () => {\n                    return audioNodeId;\n                },\n                read: () => {\n                    return stream.read();\n                },\n            };\n        });\n    }\n    detach(audioNodeId) {\n        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n    }\n    turnOff() {\n        return;\n    }\n    get events() {\n        return this.privEvents;\n    }\n    get deviceInfo() {\n        return Promise.resolve({\n            bitspersample: this.privFormat.bitsPerSample,\n            channelcount: this.privFormat.channels,\n            connectivity: connectivity.Unknown,\n            manufacturer: \"Speech SDK\",\n            model: \"PushStream\",\n            samplerate: this.privFormat.samplesPerSec,\n            type: type.Stream,\n        });\n    }\n    toBuffer(arrayBuffer) {\n        const buf = Buffer.alloc(arrayBuffer.byteLength);\n        const view = new Uint8Array(arrayBuffer);\n        for (let i = 0; i < buf.length; ++i) {\n            buf[i] = view[i];\n        }\n        return buf;\n    }\n}\n/*\n * Represents audio input stream used for custom audio input configurations.\n * @class PullAudioInputStream\n */\nexport class PullAudioInputStream extends AudioInputStream {\n    /**\n     * Creates and initializes and instance.\n     * @constructor\n     */\n    constructor() { super(); }\n    /**\n     * Creates a PullAudioInputStream that delegates to the specified callback interface for\n     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).\n     * @member PullAudioInputStream.create\n     * @function\n     * @public\n     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,\n     *        derived from PullAudioInputStreamCustomCallback\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be\n     *        returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n     * @returns {PullAudioInputStream} The push audio input stream being created.\n     */\n    static create(callback, format) {\n        return new PullAudioInputStreamImpl(callback, format);\n    }\n}\n/**\n * Represents audio input stream used for custom audio input configurations.\n * @private\n * @class PullAudioInputStreamImpl\n */\nexport class PullAudioInputStreamImpl extends PullAudioInputStream {\n    /**\n     * Creates a PullAudioInputStream that delegates to the specified callback interface for\n     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).\n     * @constructor\n     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,\n     *        derived from PullAudioInputStreamCustomCallback\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be\n     *        returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n     */\n    constructor(callback, format) {\n        super();\n        this.onEvent = (event) => {\n            this.privEvents.onEvent(event);\n            Events.instance.onEvent(event);\n        };\n        if (undefined === format) {\n            this.privFormat = AudioStreamFormat.getDefaultInputFormat();\n        }\n        else {\n            this.privFormat = format;\n        }\n        this.privEvents = new EventSource();\n        this.privId = createNoDashGuid();\n        this.privCallback = callback;\n        this.privIsClosed = false;\n        this.privBufferSize = this.privFormat.avgBytesPerSec / 10;\n    }\n    /**\n     * Format information for the audio\n     */\n    get format() {\n        return Promise.resolve(this.privFormat);\n    }\n    /**\n     * Closes the stream.\n     * @member PullAudioInputStreamImpl.prototype.close\n     * @function\n     * @public\n     */\n    close() {\n        this.privIsClosed = true;\n        this.privCallback.close();\n    }\n    id() {\n        return this.privId;\n    }\n    get blob() {\n        return Promise.reject(\"Not implemented\");\n    }\n    turnOn() {\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\n        return;\n    }\n    attach(audioNodeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n            yield this.turnOn();\n            this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n            return {\n                detach: () => {\n                    this.privCallback.close();\n                    this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                    return this.turnOff();\n                },\n                id: () => {\n                    return audioNodeId;\n                },\n                read: () => {\n                    let totalBytes = 0;\n                    let transmitBuff;\n                    // Until we have the minimum number of bytes to send in a transmission, keep asking for more.\n                    while (totalBytes < this.privBufferSize) {\n                        // Sizing the read buffer to the delta between the perfect size and what's left means we won't ever get too much\n                        // data back.\n                        const readBuff = new ArrayBuffer(this.privBufferSize - totalBytes);\n                        const pulledBytes = this.privCallback.read(readBuff);\n                        // If there is no return buffer yet defined, set the return buffer to the that was just populated.\n                        // This was, if we have enough data there's no copy penalty, but if we don't we have a buffer that's the\n                        // preferred size allocated.\n                        if (undefined === transmitBuff) {\n                            transmitBuff = readBuff;\n                        }\n                        else {\n                            // Not the first bite at the apple, so fill the return buffer with the data we got back.\n                            const intView = new Int8Array(transmitBuff);\n                            intView.set(new Int8Array(readBuff), totalBytes);\n                        }\n                        // If there are no bytes to read, just break out and be done.\n                        if (0 === pulledBytes) {\n                            break;\n                        }\n                        totalBytes += pulledBytes;\n                    }\n                    return Promise.resolve({\n                        buffer: transmitBuff.slice(0, totalBytes),\n                        isEnd: this.privIsClosed || totalBytes === 0,\n                        timeReceived: Date.now(),\n                    });\n                },\n            };\n        });\n    }\n    detach(audioNodeId) {\n        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n    }\n    turnOff() {\n        return;\n    }\n    get events() {\n        return this.privEvents;\n    }\n    get deviceInfo() {\n        return Promise.resolve({\n            bitspersample: this.privFormat.bitsPerSample,\n            channelcount: this.privFormat.channels,\n            connectivity: connectivity.Unknown,\n            manufacturer: \"Speech SDK\",\n            model: \"PullStream\",\n            samplerate: this.privFormat.samplesPerSec,\n            type: type.Stream,\n        });\n    }\n}\n\n//# sourceMappingURL=AudioInputStream.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { SpeechSynthesisOutputFormat } from \"../SpeechSynthesisOutputFormat\";\nimport { AudioFormatTag, AudioStreamFormatImpl } from \"./AudioStreamFormat\";\n/**\n * @private\n * @class AudioOutputFormatImpl\n * Updated in version 1.17.0\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class AudioOutputFormatImpl extends AudioStreamFormatImpl {\n    /**\n     * Creates an instance with the given values.\n     * @constructor\n     * @param formatTag\n     * @param {number} channels - Number of channels.\n     * @param {number} samplesPerSec - Samples per second.\n     * @param {number} avgBytesPerSec - Average bytes per second.\n     * @param {number} blockAlign - Block alignment.\n     * @param {number} bitsPerSample - Bits per sample.\n     * @param {string} audioFormatString - Audio format string\n     * @param {string} requestAudioFormatString - Audio format string sent to service.\n     * @param {boolean} hasHeader - If the format has header or not.\n     */\n    constructor(formatTag, channels, samplesPerSec, avgBytesPerSec, blockAlign, bitsPerSample, audioFormatString, requestAudioFormatString, hasHeader) {\n        super(samplesPerSec, bitsPerSample, channels, formatTag);\n        this.formatTag = formatTag;\n        this.avgBytesPerSec = avgBytesPerSec;\n        this.blockAlign = blockAlign;\n        this.priAudioFormatString = audioFormatString;\n        this.priRequestAudioFormatString = requestAudioFormatString;\n        this.priHasHeader = hasHeader;\n    }\n    static fromSpeechSynthesisOutputFormat(speechSynthesisOutputFormat) {\n        if (speechSynthesisOutputFormat === undefined) {\n            return AudioOutputFormatImpl.getDefaultOutputFormat();\n        }\n        return AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(AudioOutputFormatImpl.SpeechSynthesisOutputFormatToString[speechSynthesisOutputFormat]);\n    }\n    static fromSpeechSynthesisOutputFormatString(speechSynthesisOutputFormatString) {\n        switch (speechSynthesisOutputFormatString) {\n            case \"raw-8khz-8bit-mono-mulaw\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MuLaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"riff-16khz-16kbps-mono-siren\":\n                return new AudioOutputFormatImpl(AudioFormatTag.Siren, 1, 16000, 2000, 40, 0, speechSynthesisOutputFormatString, \"audio-16khz-16kbps-mono-siren\", true);\n            case \"audio-16khz-16kbps-mono-siren\":\n                return new AudioOutputFormatImpl(AudioFormatTag.Siren, 1, 16000, 2000, 40, 0, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"audio-16khz-32kbitrate-mono-mp3\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 16000, 32 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"audio-16khz-128kbitrate-mono-mp3\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 16000, 128 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"audio-16khz-64kbitrate-mono-mp3\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 16000, 64 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"audio-24khz-48kbitrate-mono-mp3\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 24000, 48 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"audio-24khz-96kbitrate-mono-mp3\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 24000, 96 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"audio-24khz-160kbitrate-mono-mp3\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 24000, 160 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"raw-16khz-16bit-mono-truesilk\":\n                return new AudioOutputFormatImpl(AudioFormatTag.SILKSkype, 1, 16000, 32000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"riff-8khz-16bit-mono-pcm\":\n                return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 8000, 16000, 2, 16, speechSynthesisOutputFormatString, \"raw-8khz-16bit-mono-pcm\", true);\n            case \"riff-24khz-16bit-mono-pcm\":\n                return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 24000, 48000, 2, 16, speechSynthesisOutputFormatString, \"raw-24khz-16bit-mono-pcm\", true);\n            case \"riff-8khz-8bit-mono-mulaw\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MuLaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, \"raw-8khz-8bit-mono-mulaw\", true);\n            case \"raw-16khz-16bit-mono-pcm\":\n                return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 16000, 32000, 2, 16, speechSynthesisOutputFormatString, \"raw-16khz-16bit-mono-pcm\", false);\n            case \"raw-24khz-16bit-mono-pcm\":\n                return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 24000, 48000, 2, 16, speechSynthesisOutputFormatString, \"raw-24khz-16bit-mono-pcm\", false);\n            case \"raw-8khz-16bit-mono-pcm\":\n                return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 8000, 16000, 2, 16, speechSynthesisOutputFormatString, \"raw-8khz-16bit-mono-pcm\", false);\n            case \"ogg-16khz-16bit-mono-opus\":\n                return new AudioOutputFormatImpl(AudioFormatTag.OGG_OPUS, 1, 16000, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"ogg-24khz-16bit-mono-opus\":\n                return new AudioOutputFormatImpl(AudioFormatTag.OGG_OPUS, 1, 24000, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"raw-48khz-16bit-mono-pcm\":\n                return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 48000, 96000, 2, 16, speechSynthesisOutputFormatString, \"raw-48khz-16bit-mono-pcm\", false);\n            case \"riff-48khz-16bit-mono-pcm\":\n                return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 48000, 96000, 2, 16, speechSynthesisOutputFormatString, \"raw-48khz-16bit-mono-pcm\", true);\n            case \"audio-48khz-96kbitrate-mono-mp3\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 48000, 96 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"audio-48khz-192kbitrate-mono-mp3\":\n                return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 48000, 192 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"ogg-48khz-16bit-mono-opus\":\n                return new AudioOutputFormatImpl(AudioFormatTag.OGG_OPUS, 1, 48000, 12000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"webm-16khz-16bit-mono-opus\":\n                return new AudioOutputFormatImpl(AudioFormatTag.WEBM_OPUS, 1, 16000, 8000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"webm-24khz-16bit-mono-opus\":\n                return new AudioOutputFormatImpl(AudioFormatTag.WEBM_OPUS, 1, 24000, 8000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"raw-24khz-16bit-mono-truesilk\":\n                return new AudioOutputFormatImpl(AudioFormatTag.SILKSkype, 1, 24000, 48000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"raw-8khz-8bit-mono-alaw\":\n                return new AudioOutputFormatImpl(AudioFormatTag.ALaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);\n            case \"riff-8khz-8bit-mono-alaw\":\n                return new AudioOutputFormatImpl(AudioFormatTag.ALaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, \"raw-8khz-8bit-mono-alaw\", true);\n            case \"riff-16khz-16bit-mono-pcm\":\n            default:\n                return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 16000, 32000, 2, 16, \"riff-16khz-16bit-mono-pcm\", \"raw-16khz-16bit-mono-pcm\", true);\n        }\n    }\n    static getDefaultOutputFormat() {\n        return AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString((typeof window !== \"undefined\") ? \"audio-24khz-48kbitrate-mono-mp3\" : \"riff-16khz-16bit-mono-pcm\");\n    }\n    /**\n     * Specifies if this audio output format has a header\n     * @boolean AudioOutputFormatImpl.prototype.hasHeader\n     * @function\n     * @public\n     */\n    get hasHeader() {\n        return this.priHasHeader;\n    }\n    /**\n     * Specifies the header of this format\n     * @ArrayBuffer AudioOutputFormatImpl.prototype.header\n     * @function\n     * @public\n     */\n    get header() {\n        if (this.hasHeader) {\n            return this.privHeader;\n        }\n        return undefined;\n    }\n    /**\n     * Updates the header based on the audio length\n     * @member AudioOutputFormatImpl.updateHeader\n     * @function\n     * @public\n     * @param {number} audioLength - the audio length\n     */\n    updateHeader(audioLength) {\n        if (this.priHasHeader) {\n            const view = new DataView(this.privHeader);\n            view.setUint32(40, audioLength, true);\n        }\n    }\n    /**\n     * Specifies the audio format string to be sent to the service\n     * @string AudioOutputFormatImpl.prototype.requestAudioFormatString\n     * @function\n     * @public\n     */\n    get requestAudioFormatString() {\n        return this.priRequestAudioFormatString;\n    }\n}\nAudioOutputFormatImpl.SpeechSynthesisOutputFormatToString = {\n    [SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: \"raw-8khz-8bit-mono-mulaw\",\n    [SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: \"riff-16khz-16kbps-mono-siren\",\n    [SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: \"audio-16khz-16kbps-mono-siren\",\n    [SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: \"audio-16khz-32kbitrate-mono-mp3\",\n    [SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: \"audio-16khz-128kbitrate-mono-mp3\",\n    [SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: \"audio-16khz-64kbitrate-mono-mp3\",\n    [SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: \"audio-24khz-48kbitrate-mono-mp3\",\n    [SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: \"audio-24khz-96kbitrate-mono-mp3\",\n    [SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: \"audio-24khz-160kbitrate-mono-mp3\",\n    [SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: \"raw-16khz-16bit-mono-truesilk\",\n    [SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: \"riff-16khz-16bit-mono-pcm\",\n    [SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: \"riff-8khz-16bit-mono-pcm\",\n    [SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: \"riff-24khz-16bit-mono-pcm\",\n    [SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: \"riff-8khz-8bit-mono-mulaw\",\n    [SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: \"raw-16khz-16bit-mono-pcm\",\n    [SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: \"raw-24khz-16bit-mono-pcm\",\n    [SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: \"raw-8khz-16bit-mono-pcm\",\n    [SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: \"ogg-16khz-16bit-mono-opus\",\n    [SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: \"ogg-24khz-16bit-mono-opus\",\n    [SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: \"raw-48khz-16bit-mono-pcm\",\n    [SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: \"riff-48khz-16bit-mono-pcm\",\n    [SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: \"audio-48khz-96kbitrate-mono-mp3\",\n    [SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: \"audio-48khz-192kbitrate-mono-mp3\",\n    [SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: \"ogg-48khz-16bit-mono-opus\",\n    [SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: \"webm-16khz-16bit-mono-opus\",\n    [SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: \"webm-24khz-16bit-mono-opus\",\n    [SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: \"raw-24khz-16bit-mono-truesilk\",\n    [SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: \"raw-8khz-8bit-mono-alaw\",\n    [SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: \"riff-8khz-8bit-mono-alaw\",\n};\n\n//# sourceMappingURL=AudioOutputFormat.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// tslint:disable:max-classes-per-file\nimport { createNoDashGuid, Stream, } from \"../../common/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { AudioOutputFormatImpl } from \"./AudioOutputFormat\";\n/**\n * Represents audio output stream used for custom audio output configurations.\n * @class AudioOutputStream\n */\nexport class AudioOutputStream {\n    /**\n     * Creates and initializes an instance.\n     * @constructor\n     */\n    constructor() { }\n    /**\n     * Creates a memory backed PullAudioOutputStream with the specified audio format.\n     * @member AudioOutputStream.createPullStream\n     * @function\n     * @public\n     * @returns {PullAudioOutputStream} The audio output stream being created.\n     */\n    static createPullStream() {\n        return PullAudioOutputStream.create();\n    }\n}\n/**\n * Represents memory backed push audio output stream used for custom audio output configurations.\n * @class PullAudioOutputStream\n */\nexport class PullAudioOutputStream extends AudioOutputStream {\n    /**\n     * Creates a memory backed PullAudioOutputStream with the specified audio format.\n     * @member PullAudioOutputStream.create\n     * @function\n     * @public\n     * @returns {PullAudioOutputStream} The push audio output stream being created.\n     */\n    static create() {\n        return new PullAudioOutputStreamImpl();\n    }\n}\n/**\n * Represents memory backed push audio output stream used for custom audio output configurations.\n * @private\n * @class PullAudioOutputStreamImpl\n */\nexport class PullAudioOutputStreamImpl extends PullAudioOutputStream {\n    /**\n     * Creates and initializes an instance with the given values.\n     * @constructor\n     */\n    constructor() {\n        super();\n        this.privId = createNoDashGuid();\n        this.privStream = new Stream();\n    }\n    /**\n     * Sets the format information to the stream. For internal use only.\n     * @param {AudioStreamFormat} format - the format to be set.\n     */\n    set format(format) {\n        if (format === undefined || format === null) {\n            this.privFormat = AudioOutputFormatImpl.getDefaultOutputFormat();\n        }\n        this.privFormat = format;\n    }\n    /**\n     * Format information for the audio\n     */\n    get format() {\n        return this.privFormat;\n    }\n    /**\n     * Checks if the stream is closed\n     * @member PullAudioOutputStreamImpl.prototype.isClosed\n     * @property\n     * @public\n     */\n    get isClosed() {\n        return this.privStream.isClosed;\n    }\n    /**\n     * Gets the id of the stream\n     * @member PullAudioOutputStreamImpl.prototype.id\n     * @property\n     * @public\n     */\n    id() {\n        return this.privId;\n    }\n    /**\n     * Reads audio data from the internal buffer.\n     * @member PullAudioOutputStreamImpl.prototype.read\n     * @function\n     * @public\n     * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.\n     * @returns {Promise<number>} - Audio buffer length has been read.\n     */\n    read(dataBuffer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const intView = new Int8Array(dataBuffer);\n            let totalBytes = 0;\n            if (this.privLastChunkView !== undefined) {\n                if (this.privLastChunkView.length > dataBuffer.byteLength) {\n                    intView.set(this.privLastChunkView.slice(0, dataBuffer.byteLength));\n                    this.privLastChunkView = this.privLastChunkView.slice(dataBuffer.byteLength);\n                    return Promise.resolve(dataBuffer.byteLength);\n                }\n                intView.set(this.privLastChunkView);\n                totalBytes = this.privLastChunkView.length;\n                this.privLastChunkView = undefined;\n            }\n            // Until we have the minimum number of bytes to send in a transmission, keep asking for more.\n            while (totalBytes < dataBuffer.byteLength && !this.privStream.isReadEnded) {\n                const chunk = yield this.privStream.read();\n                if (chunk !== undefined && !chunk.isEnd) {\n                    let tmpBuffer;\n                    if (chunk.buffer.byteLength > dataBuffer.byteLength - totalBytes) {\n                        tmpBuffer = chunk.buffer.slice(0, dataBuffer.byteLength - totalBytes);\n                        this.privLastChunkView = new Int8Array(chunk.buffer.slice(dataBuffer.byteLength - totalBytes));\n                    }\n                    else {\n                        tmpBuffer = chunk.buffer;\n                    }\n                    intView.set(new Int8Array(tmpBuffer), totalBytes);\n                    totalBytes += tmpBuffer.byteLength;\n                }\n                else {\n                    yield this.privStream.readEnded();\n                }\n            }\n            return totalBytes;\n        });\n    }\n    /**\n     * Writes the audio data specified by making an internal copy of the data.\n     * @member PullAudioOutputStreamImpl.prototype.write\n     * @function\n     * @public\n     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.\n     */\n    write(dataBuffer) {\n        Contracts.throwIfNullOrUndefined(this.privStream, \"must set format before writing\");\n        this.privStream.writeStreamChunk({\n            buffer: dataBuffer,\n            isEnd: false,\n            timeReceived: Date.now()\n        });\n    }\n    /**\n     * Closes the stream.\n     * @member PullAudioOutputStreamImpl.prototype.close\n     * @function\n     * @public\n     */\n    close() {\n        this.privStream.close();\n    }\n}\n/*\n * Represents audio output stream used for custom audio output configurations.\n * @class PushAudioOutputStream\n */\nexport class PushAudioOutputStream extends AudioOutputStream {\n    /**\n     * Creates and initializes and instance.\n     * @constructor\n     */\n    constructor() { super(); }\n    /**\n     * Creates a PushAudioOutputStream that delegates to the specified callback interface for\n     * write() and close() methods.\n     * @member PushAudioOutputStream.create\n     * @function\n     * @public\n     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,\n     *        derived from PushAudioOutputStreamCallback\n     * @returns {PushAudioOutputStream} The push audio output stream being created.\n     */\n    static create(callback) {\n        return new PushAudioOutputStreamImpl(callback);\n    }\n}\n/**\n * Represents audio output stream used for custom audio output configurations.\n * @private\n * @class PushAudioOutputStreamImpl\n */\nexport class PushAudioOutputStreamImpl extends PushAudioOutputStream {\n    /**\n     * Creates a PushAudioOutputStream that delegates to the specified callback interface for\n     * read() and close() methods.\n     * @constructor\n     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,\n     *        derived from PushAudioOutputStreamCallback\n     */\n    constructor(callback) {\n        super();\n        this.privId = createNoDashGuid();\n        this.privCallback = callback;\n    }\n    // tslint:disable-next-line:no-empty\n    set format(format) { }\n    write(buffer) {\n        if (!!this.privCallback.write) {\n            this.privCallback.write(buffer);\n        }\n    }\n    close() {\n        if (!!this.privCallback.close) {\n            this.privCallback.close();\n        }\n    }\n    id() {\n        return this.privId;\n    }\n}\n\n//# sourceMappingURL=AudioOutputStream.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport var AudioFormatTag;\n(function (AudioFormatTag) {\n    AudioFormatTag[AudioFormatTag[\"PCM\"] = 1] = \"PCM\";\n    AudioFormatTag[AudioFormatTag[\"MuLaw\"] = 2] = \"MuLaw\";\n    AudioFormatTag[AudioFormatTag[\"Siren\"] = 3] = \"Siren\";\n    AudioFormatTag[AudioFormatTag[\"MP3\"] = 4] = \"MP3\";\n    AudioFormatTag[AudioFormatTag[\"SILKSkype\"] = 5] = \"SILKSkype\";\n    AudioFormatTag[AudioFormatTag[\"OGG_OPUS\"] = 6] = \"OGG_OPUS\";\n    AudioFormatTag[AudioFormatTag[\"WEBM_OPUS\"] = 7] = \"WEBM_OPUS\";\n    AudioFormatTag[AudioFormatTag[\"ALaw\"] = 8] = \"ALaw\";\n})(AudioFormatTag || (AudioFormatTag = {}));\n/**\n * Represents audio stream format used for custom audio input configurations.\n * @class AudioStreamFormat\n */\nexport class AudioStreamFormat {\n    /**\n     * Creates an audio stream format object representing the default audio stream\n     * format (16KHz 16bit mono PCM).\n     * @member AudioStreamFormat.getDefaultInputFormat\n     * @function\n     * @public\n     * @returns {AudioStreamFormat} The audio stream format being created.\n     */\n    static getDefaultInputFormat() {\n        return AudioStreamFormatImpl.getDefaultInputFormat();\n    }\n    /**\n     * Creates an audio stream format object with the specified pcm waveformat characteristics.\n     * @member AudioStreamFormat.getWaveFormatPCM\n     * @function\n     * @public\n     * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).\n     * @param {number} bitsPerSample - Bits per sample, typically 16.\n     * @param {number} channels - Number of channels in the waveform-audio data. Monaural data\n     *        uses one channel and stereo data uses two channels.\n     * @returns {AudioStreamFormat} The audio stream format being created.\n     */\n    static getWaveFormatPCM(samplesPerSecond, bitsPerSample, channels) {\n        return new AudioStreamFormatImpl(samplesPerSecond, bitsPerSample, channels);\n    }\n}\n/**\n * @private\n * @class AudioStreamFormatImpl\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class AudioStreamFormatImpl extends AudioStreamFormat {\n    /**\n     * Creates an instance with the given values.\n     * @constructor\n     * @param {number} samplesPerSec - Samples per second.\n     * @param {number} bitsPerSample - Bits per sample.\n     * @param {number} channels - Number of channels.\n     * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).\n     */\n    constructor(samplesPerSec = 16000, bitsPerSample = 16, channels = 1, format = AudioFormatTag.PCM) {\n        super();\n        this.setString = (view, offset, str) => {\n            for (let i = 0; i < str.length; i++) {\n                view.setUint8(offset + i, str.charCodeAt(i));\n            }\n        };\n        /* 1 for PCM; 6 for alaw; 7 for mulaw */\n        switch (format) {\n            case AudioFormatTag.PCM:\n                this.formatTag = 1;\n                break;\n            case AudioFormatTag.ALaw:\n                this.formatTag = 6;\n                break;\n            case AudioFormatTag.MuLaw:\n                this.formatTag = 7;\n                break;\n            default:\n        }\n        this.bitsPerSample = bitsPerSample;\n        this.samplesPerSec = samplesPerSec;\n        this.channels = channels;\n        this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8);\n        this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8);\n        this.privHeader = new ArrayBuffer(44);\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\n        const view = new DataView(this.privHeader);\n        /* RIFF identifier */\n        this.setString(view, 0, \"RIFF\");\n        /* file length */\n        view.setUint32(4, 0, true);\n        /* RIFF type & Format */\n        this.setString(view, 8, \"WAVEfmt \");\n        /* format chunk length */\n        view.setUint32(16, 16, true);\n        /* audio format */\n        view.setUint16(20, this.formatTag, true);\n        /* channel count */\n        view.setUint16(22, this.channels, true);\n        /* sample rate */\n        view.setUint32(24, this.samplesPerSec, true);\n        /* byte rate (sample rate * block align) */\n        view.setUint32(28, this.avgBytesPerSec, true);\n        /* block align (channel count * bytes per sample) */\n        view.setUint16(32, this.channels * (this.bitsPerSample / 8), true);\n        /* bits per sample */\n        view.setUint16(34, this.bitsPerSample, true);\n        /* data chunk identifier */\n        this.setString(view, 36, \"data\");\n        /* data chunk length */\n        view.setUint32(40, 0, true);\n    }\n    /**\n     * Retrieves the default input format.\n     * @member AudioStreamFormatImpl.getDefaultInputFormat\n     * @function\n     * @public\n     * @returns {AudioStreamFormatImpl} The default input format.\n     */\n    static getDefaultInputFormat() {\n        return new AudioStreamFormatImpl();\n    }\n    /**\n     * Creates an audio context appropriate to current browser\n     * @member AudioStreamFormatImpl.getAudioContext\n     * @function\n     * @public\n     * @returns {AudioContext} An audio context instance\n     */\n    static getAudioContext(sampleRate) {\n        // Workaround for Speech SDK bug in Safari.\n        const AudioContext = window.AudioContext // our preferred impl\n            || window.webkitAudioContext // fallback, mostly when on Safari\n            || false; // could not find.\n        // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\n        if (!!AudioContext) {\n            if (sampleRate !== undefined && navigator.mediaDevices.getSupportedConstraints().sampleRate) {\n                return new AudioContext({ sampleRate });\n            }\n            else {\n                return new AudioContext();\n            }\n        }\n        else {\n            throw new Error(\"Browser does not support Web Audio API (AudioContext is not available).\");\n        }\n    }\n    /**\n     * Closes the configuration object.\n     * @member AudioStreamFormatImpl.prototype.close\n     * @function\n     * @public\n     */\n    close() { return; }\n    get header() {\n        return this.privHeader;\n    }\n}\n\n//# sourceMappingURL=AudioStreamFormat.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { InvalidOperationError } from \"../../common/Error\";\nimport { marshalPromiseToCallbacks } from \"../../common/Promise\";\nimport { AudioStreamFormat } from \"../Exports\";\nimport { AudioStreamFormatImpl } from \"./AudioStreamFormat\";\n/**\n * Base audio player class\n * TODO: Plays only PCM for now.\n * @class\n */\nexport class BaseAudioPlayer {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.\n     */\n    constructor(audioFormat) {\n        this.audioContext = null;\n        this.gainNode = null;\n        this.autoUpdateBufferTimer = 0;\n        if (audioFormat === undefined) {\n            audioFormat = AudioStreamFormat.getDefaultInputFormat();\n        }\n        this.init(audioFormat);\n    }\n    /**\n     * play Audio sample\n     * @param newAudioData audio data to be played.\n     */\n    playAudioSample(newAudioData, cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            this.ensureInitializedContext();\n            const audioData = this.formatAudioData(newAudioData);\n            const newSamplesData = new Float32Array(this.samples.length + audioData.length);\n            newSamplesData.set(this.samples, 0);\n            newSamplesData.set(audioData, this.samples.length);\n            this.samples = newSamplesData;\n        }))(), cb, err);\n    }\n    /**\n     * stops audio and clears the buffers\n     */\n    stopAudio(cb, err) {\n        if (this.audioContext !== null) {\n            this.samples = new Float32Array();\n            clearInterval(this.autoUpdateBufferTimer);\n            this.audioContext.close().then(() => {\n                if (!!cb) {\n                    cb();\n                }\n            }, (error) => {\n                if (!!err) {\n                    err(error);\n                }\n            });\n            this.audioContext = null;\n        }\n    }\n    init(audioFormat) {\n        this.audioFormat = audioFormat;\n        this.samples = new Float32Array();\n    }\n    ensureInitializedContext() {\n        if (this.audioContext === null) {\n            this.createAudioContext();\n            const timerPeriod = 200;\n            this.autoUpdateBufferTimer = setInterval(() => {\n                this.updateAudioBuffer();\n            }, timerPeriod);\n        }\n    }\n    createAudioContext() {\n        // new ((window as any).AudioContext || (window as any).webkitAudioContext)();\n        this.audioContext = AudioStreamFormatImpl.getAudioContext();\n        // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan\n        // to control the volume, not likely\n        this.gainNode = this.audioContext.createGain();\n        this.gainNode.gain.value = 1;\n        this.gainNode.connect(this.audioContext.destination);\n        this.startTime = this.audioContext.currentTime;\n    }\n    formatAudioData(audioData) {\n        switch (this.audioFormat.bitsPerSample) {\n            case 8:\n                return this.formatArrayBuffer(new Int8Array(audioData), 128);\n            case 16:\n                return this.formatArrayBuffer(new Int16Array(audioData), 32768);\n            case 32:\n                return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);\n            default:\n                throw new InvalidOperationError(\"Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time\");\n        }\n    }\n    formatArrayBuffer(audioData, maxValue) {\n        const float32Data = new Float32Array(audioData.length);\n        for (let i = 0; i < audioData.length; i++) {\n            float32Data[i] = audioData[i] / maxValue;\n        }\n        return float32Data;\n    }\n    updateAudioBuffer() {\n        if (this.samples.length === 0) {\n            return;\n        }\n        const channelCount = this.audioFormat.channels;\n        const bufferSource = this.audioContext.createBufferSource();\n        const frameCount = this.samples.length / channelCount;\n        const audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec);\n        // TODO: Should we do the conversion in the pushAudioSample instead?\n        for (let channel = 0; channel < channelCount; channel++) {\n            // Fill in individual channel data\n            let channelOffset = channel;\n            const audioData = audioBuffer.getChannelData(channel);\n            for (let i = 0; i < this.samples.length; i++, channelOffset += channelCount) {\n                audioData[i] = this.samples[channelOffset];\n            }\n        }\n        if (this.startTime < this.audioContext.currentTime) {\n            this.startTime = this.audioContext.currentTime;\n        }\n        bufferSource.buffer = audioBuffer;\n        bufferSource.connect(this.gainNode);\n        bufferSource.start(this.startTime);\n        // Make sure we play the next sample after the current one.\n        this.startTime += audioBuffer.duration;\n        // Clear the samples for the next pushed data.\n        this.samples = new Float32Array();\n    }\n    playAudio(audioData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.audioContext === null) {\n                this.createAudioContext();\n            }\n            const source = this.audioContext.createBufferSource();\n            const destination = this.audioContext.destination;\n            yield this.audioContext.decodeAudioData(audioData, (newBuffer) => {\n                source.buffer = newBuffer;\n                source.connect(destination);\n                source.start(0);\n            });\n        });\n    }\n}\n\n//# sourceMappingURL=BaseAudioPlayer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * An abstract base class that defines callback methods (read() and close()) for\n * custom audio input streams).\n * @class PullAudioInputStreamCallback\n */\nexport class PullAudioInputStreamCallback {\n}\n\n//# sourceMappingURL=PullAudioInputStreamCallback.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * An abstract base class that defines callback methods (write() and close()) for\n * custom audio output streams).\n * @class PushAudioOutputStreamCallback\n */\nexport class PushAudioOutputStreamCallback {\n}\n\n//# sourceMappingURL=PushAudioOutputStreamCallback.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SynthesisAdapterBase } from \"../../common.speech/Exports\";\nimport { BackgroundEvent, createNoDashGuid, Events } from \"../../common/Exports\";\nimport { PullAudioOutputStreamImpl } from \"./AudioOutputStream\";\nimport { AudioFormatTag } from \"./AudioStreamFormat\";\nconst MediaDurationPlaceholderSeconds = 60 * 30;\nconst AudioFormatToMimeType = {\n    [AudioFormatTag.PCM]: \"audio/wav\",\n    [AudioFormatTag.MuLaw]: \"audio/x-wav\",\n    [AudioFormatTag.MP3]: \"audio/mpeg\",\n    [AudioFormatTag.OGG_OPUS]: \"audio/ogg\",\n    [AudioFormatTag.WEBM_OPUS]: \"audio/webm; codecs=opus\",\n    [AudioFormatTag.ALaw]: \"audio/x-wav\",\n};\n/**\n * Represents the speaker playback audio destination, which only works in browser.\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\n * @class SpeakerAudioDestination\n * Updated in version 1.17.0\n */\nexport class SpeakerAudioDestination {\n    constructor(audioDestinationId) {\n        this.privPlaybackStarted = false;\n        this.privAppendingToBuffer = false;\n        this.privMediaSourceOpened = false;\n        this.privBytesReceived = 0;\n        this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\n        this.privIsPaused = false;\n        this.privIsClosed = false;\n    }\n    id() {\n        return this.privId;\n    }\n    write(buffer, cb, err) {\n        if (this.privAudioBuffer !== undefined) {\n            this.privAudioBuffer.push(buffer);\n            this.updateSourceBuffer().then(() => {\n                if (!!cb) {\n                    cb();\n                }\n            }, (error) => {\n                if (!!err) {\n                    err(error);\n                }\n            });\n        }\n        else if (this.privAudioOutputStream !== undefined) {\n            this.privAudioOutputStream.write(buffer);\n            this.privBytesReceived += buffer.byteLength;\n        }\n    }\n    close(cb, err) {\n        this.privIsClosed = true;\n        if (this.privSourceBuffer !== undefined) {\n            this.handleSourceBufferUpdateEnd().then(() => {\n                if (!!cb) {\n                    cb();\n                }\n            }, (error) => {\n                if (!!err) {\n                    err(error);\n                }\n            });\n        }\n        else if (this.privAudioOutputStream !== undefined) {\n            if ((this.privFormat.formatTag === AudioFormatTag.PCM || this.privFormat.formatTag === AudioFormatTag.MuLaw\n                || this.privFormat.formatTag === AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {\n                // tslint:disable-next-line:no-console\n                console.warn(`Play back is not supported for raw PCM, mulaw or alaw format without header.`);\n                if (!!this.onAudioEnd) {\n                    this.onAudioEnd(this);\n                }\n            }\n            else {\n                let receivedAudio = new ArrayBuffer(this.privBytesReceived);\n                this.privAudioOutputStream.read(receivedAudio).then((_) => {\n                    receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\n                    const audioBlob = new Blob([receivedAudio], { type: AudioFormatToMimeType[this.privFormat.formatTag] });\n                    this.privAudio.src = window.URL.createObjectURL(audioBlob);\n                    this.notifyPlayback().then(() => {\n                        if (!!cb) {\n                            cb();\n                        }\n                    }, (error) => {\n                        if (!!err) {\n                            err(error);\n                        }\n                    });\n                }, (error) => {\n                    if (!!err) {\n                        err(error);\n                    }\n                });\n            }\n        }\n        else {\n            // unsupported format, call onAudioEnd directly.\n            if (!!this.onAudioEnd) {\n                this.onAudioEnd(this);\n            }\n        }\n    }\n    set format(format) {\n        if (typeof (AudioContext) !== \"undefined\" || typeof (window.webkitAudioContext) !== \"undefined\") {\n            this.privFormat = format;\n            const mimeType = AudioFormatToMimeType[this.privFormat.formatTag];\n            if (mimeType === undefined) {\n                // tslint:disable-next-line:no-console\n                console.warn(`Unknown mimeType for format ${AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`);\n            }\n            else if (typeof (MediaSource) !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\n                this.privAudio = new Audio();\n                this.privAudioBuffer = [];\n                this.privMediaSource = new MediaSource();\n                this.privAudio.src = URL.createObjectURL(this.privMediaSource);\n                this.privAudio.load();\n                this.privMediaSource.onsourceopen = (event) => {\n                    this.privMediaSourceOpened = true;\n                    this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\n                    this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);\n                    this.privSourceBuffer.onupdate = (_) => {\n                        this.updateSourceBuffer().catch((reason) => {\n                            Events.instance.onEvent(new BackgroundEvent(reason));\n                        });\n                    };\n                    this.privSourceBuffer.onupdateend = (_) => {\n                        this.handleSourceBufferUpdateEnd().catch((reason) => {\n                            Events.instance.onEvent(new BackgroundEvent(reason));\n                        });\n                    };\n                    this.privSourceBuffer.onupdatestart = (_) => {\n                        this.privAppendingToBuffer = false;\n                    };\n                };\n                this.updateSourceBuffer().catch((reason) => {\n                    Events.instance.onEvent(new BackgroundEvent(reason));\n                });\n            }\n            else {\n                // tslint:disable-next-line:no-console\n                console.warn(`Format ${AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);\n                this.privAudioOutputStream = new PullAudioOutputStreamImpl();\n                this.privAudioOutputStream.format = this.privFormat;\n                this.privAudio = new Audio();\n            }\n        }\n    }\n    get isClosed() {\n        return this.privIsClosed;\n    }\n    get currentTime() {\n        if (this.privAudio !== undefined) {\n            return this.privAudio.currentTime;\n        }\n        return -1;\n    }\n    pause() {\n        if (!this.privIsPaused && this.privAudio !== undefined) {\n            this.privAudio.pause();\n            this.privIsPaused = true;\n        }\n    }\n    resume(cb, err) {\n        if (this.privIsPaused && this.privAudio !== undefined) {\n            this.privAudio.play().then(() => {\n                if (!!cb) {\n                    cb();\n                }\n            }, (error) => {\n                if (!!err) {\n                    err(error);\n                }\n            });\n            this.privIsPaused = false;\n        }\n    }\n    get internalAudio() {\n        return this.privAudio;\n    }\n    updateSourceBuffer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privAudioBuffer !== undefined && (this.privAudioBuffer.length > 0) && this.sourceBufferAvailable()) {\n                this.privAppendingToBuffer = true;\n                const binary = this.privAudioBuffer.shift();\n                try {\n                    this.privSourceBuffer.appendBuffer(binary);\n                }\n                catch (error) {\n                    this.privAudioBuffer.unshift(binary);\n                    // tslint:disable-next-line:no-console\n                    console.log(\"buffer filled, pausing addition of binaries until space is made\");\n                    return;\n                }\n                yield this.notifyPlayback();\n            }\n            else if (this.canEndStream()) {\n                yield this.handleSourceBufferUpdateEnd();\n            }\n        });\n    }\n    handleSourceBufferUpdateEnd() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.canEndStream() && this.sourceBufferAvailable()) {\n                this.privMediaSource.endOfStream();\n                yield this.notifyPlayback();\n            }\n        });\n    }\n    notifyPlayback() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.privPlaybackStarted && this.privAudio !== undefined) {\n                this.privPlaybackStarted = true;\n                if (!!this.onAudioStart) {\n                    this.onAudioStart(this);\n                }\n                this.privAudio.onended = () => {\n                    if (!!this.onAudioEnd) {\n                        this.onAudioEnd(this);\n                    }\n                };\n                if (!this.privIsPaused) {\n                    yield this.privAudio.play();\n                }\n            }\n        });\n    }\n    canEndStream() {\n        return (this.isClosed && this.privSourceBuffer !== undefined && (this.privAudioBuffer.length === 0)\n            && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\");\n    }\n    sourceBufferAvailable() {\n        return (this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating);\n    }\n}\n\n//# sourceMappingURL=SpeakerAudioDestination.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { AutoDetectSourceLanguagesOpenRangeOptionName } from \"../common.speech/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { PropertyCollection, PropertyId, } from \"./Exports\";\n/**\n * Language auto detect configuration.\n * @class AutoDetectSourceLanguageConfig\n * Added in version 1.13.0.\n */\nexport class AutoDetectSourceLanguageConfig {\n    constructor() {\n        this.privProperties = new PropertyCollection();\n    }\n    /**\n     * @member AutoDetectSourceLanguageConfig.fromOpenRange\n     * @function\n     * @public\n     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,\n     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.\n     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\n     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.\n     */\n    static fromOpenRange() {\n        const config = new AutoDetectSourceLanguageConfig();\n        config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, AutoDetectSourceLanguagesOpenRangeOptionName);\n        return config;\n    }\n    /**\n     * @member AutoDetectSourceLanguageConfig.fromLanguages\n     * @function\n     * @public\n     * @param {string[]} languages Comma-separated string of languages (eg. \"en-US,fr-FR\") to populate properties of config.\n     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\n     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.\n     */\n    static fromLanguages(languages) {\n        Contracts.throwIfArrayEmptyOrWhitespace(languages, \"languages\");\n        const config = new AutoDetectSourceLanguageConfig();\n        config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, languages.join());\n        return config;\n    }\n    /**\n     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs\n     * @function\n     * @public\n     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.\n     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\n     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.\n     */\n    static fromSourceLanguageConfigs(configs) {\n        if (configs.length < 1) {\n            throw new Error(\"Expected non-empty SourceLanguageConfig array.\");\n        }\n        const autoConfig = new AutoDetectSourceLanguageConfig();\n        const langs = [];\n        configs.forEach((config) => {\n            langs.push(config.language);\n            if (config.endpointId !== undefined && config.endpointId !== \"\") {\n                const customProperty = config.language + PropertyId.SpeechServiceConnection_EndpointId.toString();\n                autoConfig.properties.setProperty(customProperty, config.endpointId);\n            }\n        });\n        autoConfig.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, langs.join());\n        return autoConfig;\n    }\n    /**\n     * @member AutoDetectSourceLanguageConfig.prototype.properties\n     * @function\n     * @public\n     * @return {PropertyCollection} Properties of the config.\n     * @summary Gets an auto detected language config properties\n     */\n    get properties() {\n        return this.privProperties;\n    }\n}\n\n//# sourceMappingURL=AutoDetectSourceLanguageConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\n/**\n * Output format\n * @class AutoDetectSourceLanguageResult\n */\nexport class AutoDetectSourceLanguageResult {\n    constructor(language, languageDetectionConfidence) {\n        Contracts.throwIfNullOrUndefined(language, \"language\");\n        Contracts.throwIfNullOrUndefined(languageDetectionConfidence, \"languageDetectionConfidence\");\n        this.privLanguage = language;\n        this.privLanguageDetectionConfidence = languageDetectionConfidence;\n    }\n    /**\n     * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.\n     * @member AutoDetectSourceLanguageResult.fromResult\n     * @function\n     * @public\n     * @param {SpeechRecognitionResult} result - The recognition result.\n     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.\n     */\n    static fromResult(result) {\n        return new AutoDetectSourceLanguageResult(result.language, result.languageDetectionConfidence);\n    }\n    get language() {\n        return this.privLanguage;\n    }\n    get languageDetectionConfidence() {\n        return this.privLanguageDetectionConfidence;\n    }\n}\n\n//# sourceMappingURL=AutoDetectSourceLanguageResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\nimport { DialogServiceConfig, DialogServiceConfigImpl } from \"./DialogServiceConfig\";\nimport { PropertyId } from \"./Exports\";\n/**\n * Class that defines configurations for the dialog service connector object for using a Bot Framework backend.\n * @class BotFrameworkConfig\n */\nexport class BotFrameworkConfig extends DialogServiceConfigImpl {\n    /**\n     * Creates an instance of BotFrameworkConfig.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Creates a bot framework configuration instance with the provided subscription information.\n     * @member BotFrameworkConfig.fromSubscription\n     * @function\n     * @public\n     * @param subscription Subscription key associated with the bot\n     * @param region The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the\n     *        resource name.\n     * @returns {BotFrameworkConfig} A new bot framework configuration instance.\n     */\n    static fromSubscription(subscription, region, botId) {\n        Contracts.throwIfNullOrWhitespace(subscription, \"subscription\");\n        Contracts.throwIfNullOrWhitespace(region, \"region\");\n        const botFrameworkConfig = new DialogServiceConfigImpl();\n        botFrameworkConfig.setProperty(PropertyId.Conversation_DialogType, DialogServiceConfig.DialogTypes.BotFramework);\n        botFrameworkConfig.setProperty(PropertyId.SpeechServiceConnection_Key, subscription);\n        botFrameworkConfig.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n        if (botId) {\n            botFrameworkConfig.setProperty(PropertyId.Conversation_ApplicationId, botId);\n        }\n        return botFrameworkConfig;\n    }\n    /**\n     * Creates a bot framework configuration instance for the specified authorization token and region.\n     * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the\n     *       caller must refresh it by setting the authorizationToken property on the corresponding\n     *       DialogServiceConnector instance created with this config. The contents of configuration objects are copied\n     *       when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the\n     *       original configuration's authorization token. Create a new configuration instance or set the\n     *       SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create\n     *       further DialogServiceConnectors.\n     * @member BotFrameworkConfig.fromAuthorizationToken\n     * @function\n     * @public\n     * @param authorizationToken The authorization token associated with the bot\n     * @param region The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the\n     *        resource name.\n     * @returns {BotFrameworkConfig} A new bot framework configuration instance.\n     */\n    static fromAuthorizationToken(authorizationToken, region, botId) {\n        Contracts.throwIfNullOrWhitespace(authorizationToken, \"authorizationToken\");\n        Contracts.throwIfNullOrWhitespace(region, \"region\");\n        const botFrameworkConfig = new DialogServiceConfigImpl();\n        botFrameworkConfig.setProperty(PropertyId.Conversation_DialogType, DialogServiceConfig.DialogTypes.BotFramework);\n        botFrameworkConfig.setProperty(PropertyId.SpeechServiceAuthorization_Token, authorizationToken);\n        botFrameworkConfig.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n        if (botId) {\n            botFrameworkConfig.setProperty(PropertyId.Conversation_ApplicationId, botId);\n        }\n        return botFrameworkConfig;\n    }\n    /**\n     * Creates an instance of a BotFrameworkConfig.\n     * This method is intended only for users who use a non-default service host. The standard resource path will be\n     * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.\n     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.\n     * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken\n     *       property on the created BotFrameworkConfig instance.\n     * Note: Added in version 1.15.0.\n     * @member BotFrameworkConfig.fromHost\n     * @function\n     * @public\n     * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.\n     *        wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in\n     *        wss://{host}.convai.speech.azure.us.\n     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization\n     *        token must be set.\n     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the\n     *        resource name.\n     * @returns {BotFrameworkConfig} A new bot framework configuration instance.\n     */\n    static fromHost(host, subscriptionKey, botId) {\n        Contracts.throwIfNullOrUndefined(host, \"host\");\n        const resolvedHost = host instanceof URL ? host : new URL(`wss://${host}.convai.speech.azure.us`);\n        Contracts.throwIfNullOrUndefined(resolvedHost, \"resolvedHost\");\n        const botFrameworkConfig = new DialogServiceConfigImpl();\n        botFrameworkConfig.setProperty(PropertyId.Conversation_DialogType, DialogServiceConfig.DialogTypes.BotFramework);\n        botFrameworkConfig.setProperty(PropertyId.SpeechServiceConnection_Host, resolvedHost.toString());\n        if (undefined !== subscriptionKey) {\n            botFrameworkConfig.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n        }\n        return botFrameworkConfig;\n    }\n    /**\n     * Creates an instance of a BotFrameworkConfig.\n     * This method is intended only for users who use a non-standard service endpoint or parameters.\n     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.\n     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the\n     *       fromEndpoint method, and then set authorizationToken=\"token\" on the created BotFrameworkConfig instance to\n     *       use the authorization token.\n     * Note: Added in version 1.15.0.\n     * @member BotFrameworkConfig.fromEndpoint\n     * @function\n     * @public\n     * @param {URL} endpoint - The service endpoint to connect to.\n     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization\n     *        token must be set.\n     * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.\n     */\n    static fromEndpoint(endpoint, subscriptionKey) {\n        Contracts.throwIfNull(endpoint, \"endpoint\");\n        const botFrameworkConfig = new DialogServiceConfigImpl();\n        botFrameworkConfig.setProperty(PropertyId.Conversation_DialogType, DialogServiceConfig.DialogTypes.BotFramework);\n        botFrameworkConfig.setProperty(PropertyId.SpeechServiceConnection_Endpoint, endpoint.toString());\n        if (undefined !== subscriptionKey) {\n            botFrameworkConfig.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n        }\n        return botFrameworkConfig;\n    }\n}\n\n//# sourceMappingURL=BotFrameworkConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { CancellationErrorCodePropertyName, EnumTranslation, SimpleSpeechPhrase } from \"../common.speech/Exports\";\nimport { CancellationDetailsBase } from \"./CancellationDetailsBase\";\nimport { CancellationErrorCode, CancellationReason, RecognitionResult } from \"./Exports\";\n/**\n * Contains detailed information about why a result was canceled.\n * @class CancellationDetails\n */\nexport class CancellationDetails extends CancellationDetailsBase {\n    constructor(reason, errorDetails, errorCode) {\n        super(reason, errorDetails, errorCode);\n    }\n    /**\n     * Creates an instance of CancellationDetails object for the canceled RecognitionResult.\n     * @member CancellationDetails.fromResult\n     * @function\n     * @public\n     * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.\n     * @returns {CancellationDetails} The cancellation details object being created.\n     */\n    static fromResult(result) {\n        let reason = CancellationReason.Error;\n        let errorCode = CancellationErrorCode.NoError;\n        if (result instanceof RecognitionResult && !!result.json) {\n            const simpleSpeech = SimpleSpeechPhrase.fromJSON(result.json);\n            reason = EnumTranslation.implTranslateCancelResult(simpleSpeech.RecognitionStatus);\n        }\n        if (!!result.properties) {\n            errorCode = CancellationErrorCode[result.properties.getProperty(CancellationErrorCodePropertyName, CancellationErrorCode[CancellationErrorCode.NoError])];\n        }\n        return new CancellationDetails(reason, result.errorDetails, errorCode);\n    }\n}\n\n//# sourceMappingURL=CancellationDetails.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Contains detailed information about why a result was canceled.\n * @class CancellationDetailsBase\n */\nexport class CancellationDetailsBase {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {CancellationReason} reason - The cancellation reason.\n     * @param {string} errorDetails - The error details, if provided.\n     */\n    constructor(reason, errorDetails, errorCode) {\n        this.privReason = reason;\n        this.privErrorDetails = errorDetails;\n        this.privErrorCode = errorCode;\n    }\n    /**\n     * The reason the recognition was canceled.\n     * @member CancellationDetailsBase.prototype.reason\n     * @function\n     * @public\n     * @returns {CancellationReason} Specifies the reason canceled.\n     */\n    get reason() {\n        return this.privReason;\n    }\n    /**\n     * In case of an unsuccessful recognition, provides details of the occurred error.\n     * @member CancellationDetailsBase.prototype.errorDetails\n     * @function\n     * @public\n     * @returns {string} A String that represents the error details.\n     */\n    get errorDetails() {\n        return this.privErrorDetails;\n    }\n    /**\n     * The error code in case of an unsuccessful recognition.\n     * Added in version 1.1.0.\n     * @return An error code that represents the error reason.\n     */\n    get ErrorCode() {\n        return this.privErrorCode;\n    }\n}\n\n//# sourceMappingURL=CancellationDetailsBase.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n *  Defines error code in case that CancellationReason is Error.\n *  Added in version 1.1.0.\n */\nexport var CancellationErrorCode;\n(function (CancellationErrorCode) {\n    /**\n     * Indicates that no error occurred during speech recognition.\n     */\n    CancellationErrorCode[CancellationErrorCode[\"NoError\"] = 0] = \"NoError\";\n    /**\n     * Indicates an authentication error.\n     */\n    CancellationErrorCode[CancellationErrorCode[\"AuthenticationFailure\"] = 1] = \"AuthenticationFailure\";\n    /**\n     * Indicates that one or more recognition parameters are invalid.\n     */\n    CancellationErrorCode[CancellationErrorCode[\"BadRequestParameters\"] = 2] = \"BadRequestParameters\";\n    /**\n     * Indicates that the number of parallel requests exceeded the number of allowed\n     * concurrent transcriptions for the subscription.\n     */\n    CancellationErrorCode[CancellationErrorCode[\"TooManyRequests\"] = 3] = \"TooManyRequests\";\n    /**\n     * Indicates a connection error.\n     */\n    CancellationErrorCode[CancellationErrorCode[\"ConnectionFailure\"] = 4] = \"ConnectionFailure\";\n    /**\n     * Indicates a time-out error when waiting for response from service.\n     */\n    CancellationErrorCode[CancellationErrorCode[\"ServiceTimeout\"] = 5] = \"ServiceTimeout\";\n    /**\n     * Indicates that an error is returned by the service.\n     */\n    CancellationErrorCode[CancellationErrorCode[\"ServiceError\"] = 6] = \"ServiceError\";\n    /**\n     * Indicates an unexpected runtime error.\n     */\n    CancellationErrorCode[CancellationErrorCode[\"RuntimeError\"] = 7] = \"RuntimeError\";\n})(CancellationErrorCode || (CancellationErrorCode = {}));\n\n//# sourceMappingURL=CancellationErrorCodes.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RecognitionEventArgs } from \"./Exports\";\n/**\n * Defines content of a CancellationEvent.\n * @class CancellationEventArgsBase\n */\nexport class CancellationEventArgsBase extends RecognitionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {CancellationReason} reason - The cancellation reason.\n     * @param {string} errorDetails - Error details, if provided.\n     * @param {number} offset - The offset.\n     * @param {string} sessionId - The session id.\n     */\n    constructor(reason, errorDetails, errorCode, offset, sessionId) {\n        super(offset, sessionId);\n        this.privReason = reason;\n        this.privErrorDetails = errorDetails;\n        this.privErrorCode = errorCode;\n    }\n    /**\n     * The reason the recognition was canceled.\n     * @member CancellationEventArgsBase.prototype.reason\n     * @function\n     * @public\n     * @returns {CancellationReason} Specifies the reason canceled.\n     */\n    get reason() {\n        return this.privReason;\n    }\n    /**\n     * The error code in case of an unsuccessful operation.\n     * @return An error code that represents the error reason.\n     */\n    get errorCode() {\n        return this.privErrorCode;\n    }\n    /**\n     * In case of an unsuccessful operation, provides details of the occurred error.\n     * @member CancellationEventArgsBase.prototype.errorDetails\n     * @function\n     * @public\n     * @returns {string} A String that represents the error details.\n     */\n    get errorDetails() {\n        return this.privErrorDetails;\n    }\n}\n\n//# sourceMappingURL=CancellationEventArgsBase.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines the possible reasons a recognition result might be canceled.\n * @class CancellationReason\n */\nexport var CancellationReason;\n(function (CancellationReason) {\n    /**\n     * Indicates that an error occurred during speech recognition.\n     * @member CancellationReason.Error\n     */\n    CancellationReason[CancellationReason[\"Error\"] = 0] = \"Error\";\n    /**\n     * Indicates that the end of the audio stream was reached.\n     * @member CancellationReason.EndOfStream\n     */\n    CancellationReason[CancellationReason[\"EndOfStream\"] = 1] = \"EndOfStream\";\n})(CancellationReason || (CancellationReason = {}));\n\n//# sourceMappingURL=CancellationReason.js.map\n","//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nimport { ServiceRecognizerBase, SynthesisAdapterBase, } from \"../common.speech/Exports\";\nimport { marshalPromiseToCallbacks, } from \"../common/Exports\";\nimport { ConnectionMessageImpl } from \"./ConnectionMessage\";\nimport { Contracts } from \"./Contracts\";\nimport { ConnectionEventArgs, ConnectionMessageEventArgs, ServiceEventArgs, } from \"./Exports\";\n/**\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\n * By default, a Recognizer autonomously manages connection to service when needed.\n * The Connection class provides additional methods for users to explicitly open or close a connection and\n * to subscribe to connection status changes.\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\n * in advance before starting recognition on the Recognizer associated with this Connection.\n * If the Recognizer needs to connect or disconnect to service, it will\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\n * status via Connected/Disconnected events.\n * Added in version 1.2.1.\n */\nexport class Connection {\n    /**\n     * Gets the Connection instance from the specified recognizer.\n     * @param recognizer The recognizer associated with the connection.\n     * @return The Connection instance of the recognizer.\n     */\n    static fromRecognizer(recognizer) {\n        const recoBase = recognizer.internalData;\n        const ret = new Connection();\n        ret.privInternalData = recoBase;\n        ret.setupEvents();\n        return ret;\n    }\n    /**\n     * Gets the Connection instance from the specified synthesizer.\n     * @param synthesizer The synthesizer associated with the connection.\n     * @return The Connection instance of the synthesizer.\n     */\n    static fromSynthesizer(synthesizer) {\n        const synthBase = synthesizer.internalData;\n        const ret = new Connection();\n        ret.privInternalData = synthBase;\n        ret.setupEvents();\n        return ret;\n    }\n    /**\n     * Starts to set up connection to the service.\n     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\n     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\n     *\n     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\n     * be notified when the connection is established.\n     */\n    openConnection(cb, err) {\n        marshalPromiseToCallbacks(this.privInternalData.connect(), cb, err);\n    }\n    /**\n     * Closes the connection the service.\n     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\n     *\n     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\n     */\n    closeConnection(cb, err) {\n        if (this.privInternalData instanceof SynthesisAdapterBase) {\n            throw new Error(\"Disconnecting a synthesizer's connection is currently not supported\");\n        }\n        else {\n            marshalPromiseToCallbacks(this.privInternalData.disconnect(), cb, err);\n        }\n    }\n    /**\n     * Appends a parameter in a message to service.\n     * Added in version 1.12.1.\n     * @param path The path of the network message.\n     * @param propertyName Name of the property\n     * @param propertyValue Value of the property. This is a json string.\n     */\n    setMessageProperty(path, propertyName, propertyValue) {\n        Contracts.throwIfNullOrWhitespace(propertyName, \"propertyName\");\n        if (this.privInternalData instanceof ServiceRecognizerBase) {\n            if (path.toLowerCase() !== \"speech.context\") {\n                throw new Error(\"Only speech.context message property sets are currently supported for recognizer\");\n            }\n            else {\n                this.privInternalData.speechContext.setSection(propertyName, propertyValue);\n            }\n        }\n        else if (this.privInternalData instanceof SynthesisAdapterBase) {\n            if (path.toLowerCase() !== \"synthesis.context\") {\n                throw new Error(\"Only synthesis.context message property sets are currently supported for synthesizer\");\n            }\n            else {\n                this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);\n            }\n        }\n    }\n    /**\n     * Sends a message to the speech service.\n     * Added in version 1.13.0.\n     * @param path The WebSocket path of the message\n     * @param payload The payload of the message. This is a json string or a ArrayBuffer.\n     * @param success A callback to indicate success.\n     * @param error A callback to indicate an error.\n     */\n    sendMessageAsync(path, payload, success, error) {\n        marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);\n    }\n    /**\n     * Dispose of associated resources.\n     */\n    close() {\n        /* tslint:disable:no-empty */\n    }\n    setupEvents() {\n        this.privEventListener = this.privInternalData.connectionEvents.attach((connectionEvent) => {\n            if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n                if (!!this.connected) {\n                    this.connected(new ConnectionEventArgs(connectionEvent.connectionId));\n                }\n            }\n            else if (connectionEvent.name === \"ConnectionClosedEvent\") {\n                if (!!this.disconnected) {\n                    this.disconnected(new ConnectionEventArgs(connectionEvent.connectionId));\n                }\n            }\n            else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\n                if (!!this.messageSent) {\n                    this.messageSent(new ConnectionMessageEventArgs(new ConnectionMessageImpl(connectionEvent.message)));\n                }\n            }\n            else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\n                if (!!this.messageReceived) {\n                    this.messageReceived(new ConnectionMessageEventArgs(new ConnectionMessageImpl(connectionEvent.message)));\n                }\n            }\n        });\n        this.privServiceEventListener = this.privInternalData.serviceEvents.attach((e) => {\n            if (!!this.receivedServiceMessage) {\n                this.receivedServiceMessage(new ServiceEventArgs(e.jsonString, e.name));\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=Connection.js.map\n","//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nimport { SessionEventArgs } from \"./Exports\";\n/**\n * Defines payload for connection events like Connected/Disconnected.\n * Added in version 1.2.0\n */\nexport class ConnectionEventArgs extends SessionEventArgs {\n}\n\n//# sourceMappingURL=ConnectionEventArgs.js.map\n","//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\nimport { MessageType } from \"../common/Exports\";\nimport { PropertyCollection } from \"./PropertyCollection\";\nimport { PropertyId } from \"./PropertyId\";\n/**\n * ConnectionMessage represents implementation specific messages sent to and received from\n * the speech service. These messages are provided for debugging purposes and should not\n * be used for production use cases with the Azure Cognitive Services Speech Service.\n * Messages sent to and received from the Speech Service are subject to change without\n * notice. This includes message contents, headers, payloads, ordering, etc.\n * Added in version 1.11.0.\n */\nexport class ConnectionMessage {\n}\n// tslint:disable-next-line:max-classes-per-file\nexport class ConnectionMessageImpl {\n    constructor(message) {\n        this.privConnectionMessage = message;\n        this.privProperties = new PropertyCollection();\n        if (!!this.privConnectionMessage.headers[HeaderNames.ConnectionId]) {\n            this.privProperties.setProperty(PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames.ConnectionId]);\n        }\n        Object.keys(this.privConnectionMessage.headers).forEach((header, index, array) => {\n            this.privProperties.setProperty(header, this.privConnectionMessage.headers[header]);\n        });\n    }\n    /**\n     * The message path.\n     */\n    get path() {\n        return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((key) => key.toLowerCase() === \"path\".toLowerCase())];\n    }\n    /**\n     * Checks to see if the ConnectionMessage is a text message.\n     * See also IsBinaryMessage().\n     */\n    get isTextMessage() {\n        return this.privConnectionMessage.messageType === MessageType.Text;\n    }\n    /**\n     * Checks to see if the ConnectionMessage is a binary message.\n     * See also GetBinaryMessage().\n     */\n    get isBinaryMessage() {\n        return this.privConnectionMessage.messageType === MessageType.Binary;\n    }\n    /**\n     * Gets the text message payload. Typically the text message content-type is\n     * application/json. To determine other content-types use\n     * Properties.GetProperty(\"Content-Type\").\n     */\n    get TextMessage() {\n        return this.privConnectionMessage.textBody;\n    }\n    /**\n     * Gets the binary message payload.\n     */\n    get binaryMessage() {\n        return this.privConnectionMessage.binaryBody;\n    }\n    /**\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    /**\n     * Returns a string that represents the connection message.\n     */\n    toString() {\n        return \"\";\n    }\n}\n\n//# sourceMappingURL=ConnectionMessage.js.map\n","//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nexport class ConnectionMessageEventArgs {\n    constructor(message) {\n        this.privConnectionMessage = message;\n    }\n    /**\n     * Gets the <see cref=\"ConnectionMessage\"/> associated with this <see cref=\"ConnectionMessageEventArgs\"/>.\n     */\n    get message() {\n        return this.privConnectionMessage;\n    }\n    /**\n     * Returns a string that represents the connection message event.\n     */\n    toString() {\n        return \"Message: \" + this.privConnectionMessage.toString();\n    }\n}\n\n//# sourceMappingURL=ConnectionMessageEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * @class Contracts\n * @private\n */\nexport class Contracts {\n    static throwIfNullOrUndefined(param, name) {\n        if (param === undefined || param === null) {\n            throw new Error(\"throwIfNullOrUndefined:\" + name);\n        }\n    }\n    static throwIfNull(param, name) {\n        if (param === null) {\n            throw new Error(\"throwIfNull:\" + name);\n        }\n    }\n    static throwIfNullOrWhitespace(param, name) {\n        Contracts.throwIfNullOrUndefined(param, name);\n        if ((\"\" + param).trim().length < 1) {\n            throw new Error(\"throwIfNullOrWhitespace:\" + name);\n        }\n    }\n    static throwIfDisposed(isDisposed) {\n        if (isDisposed) {\n            throw new Error(\"the object is already disposed\");\n        }\n    }\n    static throwIfArrayEmptyOrWhitespace(array, name) {\n        Contracts.throwIfNullOrUndefined(array, name);\n        if (array.length === 0) {\n            throw new Error(\"throwIfArrayEmptyOrWhitespace:\" + name);\n        }\n        for (const item of array) {\n            Contracts.throwIfNullOrWhitespace(item, name);\n        }\n    }\n    static throwIfFileDoesNotExist(param, name) {\n        Contracts.throwIfNullOrWhitespace(param, name);\n        // TODO check for file existence.\n    }\n    static throwIfNotUndefined(param, name) {\n        if (param !== undefined) {\n            throw new Error(\"throwIfNotUndefined:\" + name);\n        }\n    }\n}\n\n//# sourceMappingURL=Contracts.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { CancellationEventArgsBase, } from \"./CancellationEventArgsBase\";\n/**\n * Defines content of a RecognitionErrorEvent.\n * @class ConversationTranscriptionCanceledEventArgs\n */\nexport class ConversationTranscriptionCanceledEventArgs extends CancellationEventArgsBase {\n}\n\n//# sourceMappingURL=ConversationTranscriptionCanceledEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\nimport { DialogServiceConfig, DialogServiceConfigImpl } from \"./DialogServiceConfig\";\nimport { PropertyId } from \"./Exports\";\n/**\n * Class that defines configurations for the dialog service connector object for using a CustomCommands backend.\n * @class CustomCommandsConfig\n */\nexport class CustomCommandsConfig extends DialogServiceConfigImpl {\n    /**\n     * Creates an instance of CustomCommandsConfig.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Creates an instance of the bot framework config with the specified subscription and region.\n     * @member CustomCommandsConfig.fromSubscription\n     * @function\n     * @public\n     * @param applicationId Speech Commands application id.\n     * @param subscription Subscription key associated with the bot\n     * @param region The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n     * @returns {CustomCommandsConfig} A new bot framework config.\n     */\n    static fromSubscription(applicationId, subscription, region) {\n        Contracts.throwIfNullOrWhitespace(applicationId, \"applicationId\");\n        Contracts.throwIfNullOrWhitespace(subscription, \"subscription\");\n        Contracts.throwIfNullOrWhitespace(region, \"region\");\n        const customCommandsConfig = new DialogServiceConfigImpl();\n        customCommandsConfig.setProperty(PropertyId.Conversation_DialogType, DialogServiceConfig.DialogTypes.CustomCommands);\n        customCommandsConfig.setProperty(PropertyId.Conversation_ApplicationId, applicationId);\n        customCommandsConfig.setProperty(PropertyId.SpeechServiceConnection_Key, subscription);\n        customCommandsConfig.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n        return customCommandsConfig;\n    }\n    /**\n     * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.\n     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token\n     * expires, the caller needs to refresh it by calling this setter with a new valid token.\n     * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.\n     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer\n     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.\n     * @member CustomCommandsConfig.fromAuthorizationToken\n     * @function\n     * @public\n     * @param applicationId Speech Commands application id.\n     * @param authorizationToken The authorization token associated with the application.\n     * @param region The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n     * @returns {CustomCommandsConfig} A new speech commands config.\n     */\n    static fromAuthorizationToken(applicationId, authorizationToken, region) {\n        Contracts.throwIfNullOrWhitespace(applicationId, \"applicationId\");\n        Contracts.throwIfNullOrWhitespace(authorizationToken, \"authorizationToken\");\n        Contracts.throwIfNullOrWhitespace(region, \"region\");\n        const customCommandsConfig = new DialogServiceConfigImpl();\n        customCommandsConfig.setProperty(PropertyId.Conversation_DialogType, DialogServiceConfig.DialogTypes.CustomCommands);\n        customCommandsConfig.setProperty(PropertyId.Conversation_ApplicationId, applicationId);\n        customCommandsConfig.setProperty(PropertyId.SpeechServiceAuthorization_Token, authorizationToken);\n        customCommandsConfig.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n        return customCommandsConfig;\n    }\n    /**\n     * Sets the corresponding backend application identifier.\n     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId\n     * @function\n     * @public\n     * @param {string} value - The application identifier to set.\n     */\n    set applicationId(value) {\n        Contracts.throwIfNullOrWhitespace(value, \"value\");\n        this.setProperty(PropertyId.Conversation_ApplicationId, value);\n    }\n    /**\n     * Gets the corresponding backend application identifier.\n     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId\n     * @function\n     * @public\n     * @param {string} value - The application identifier to get.\n     */\n    get applicationId() {\n        return this.getProperty(PropertyId.Conversation_ApplicationId);\n    }\n}\n\n//# sourceMappingURL=CustomCommandsConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar _a;\nimport { Contracts } from \"./Contracts\";\nimport { PropertyId, SpeechConfigImpl } from \"./Exports\";\n/**\n * Class that defines base configurations for dialog service connector\n * @class DialogServiceConfig\n */\nexport class DialogServiceConfig {\n    /**\n     * Creates an instance of DialogService config.\n     * @constructor\n     */\n    constructor() { }\n    /**\n     * Sets the corresponding backend application identifier.\n     * @member DialogServiceConfig.prototype.Conversation_ApplicationId\n     * @function\n     * @public\n     * @param {string} value - The application identifier to set.\n     */\n    // tslint:disable-next-line: no-empty\n    set applicationId(value) { }\n}\nDialogServiceConfig.DialogTypes = (_a = class {\n    },\n    _a.BotFramework = \"bot_framework\",\n    _a.CustomCommands = \"custom_commands\",\n    _a);\n/**\n * Dialog Service configuration.\n * @class DialogServiceConfigImpl\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class DialogServiceConfigImpl extends DialogServiceConfig {\n    /**\n     * Creates an instance of dialogService config.\n     */\n    constructor() {\n        super();\n        this.privSpeechConfig = new SpeechConfigImpl();\n    }\n    /**\n     * Provides access to custom properties.\n     * @member DialogServiceConfigImpl.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The properties.\n     */\n    get properties() {\n        return this.privSpeechConfig.properties;\n    }\n    /**\n     * Gets the speech recognition language.\n     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage\n     * @function\n     * @public\n     */\n    get speechRecognitionLanguage() {\n        return this.privSpeechConfig.speechRecognitionLanguage;\n    }\n    /**\n     * Sets the speech recognition language.\n     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage\n     * @function\n     * @public\n     * @param {string} value - The language to set.\n     */\n    set speechRecognitionLanguage(value) {\n        Contracts.throwIfNullOrWhitespace(value, \"value\");\n        this.privSpeechConfig.speechRecognitionLanguage = value;\n    }\n    get outputFormat() {\n        return this.privSpeechConfig.outputFormat;\n    }\n    set outputFormat(value) {\n        this.privSpeechConfig.outputFormat = value;\n    }\n    /**\n     * Sets a named property as value\n     * @member DialogServiceConfigImpl.prototype.setProperty\n     * @function\n     * @public\n     * @param {PropertyId | string} name - The property to set.\n     * @param {string} value - The value.\n     */\n    setProperty(name, value) {\n        this.privSpeechConfig.setProperty(name, value);\n    }\n    /**\n     * Sets a named property as value\n     * @member DialogServiceConfigImpl.prototype.getProperty\n     * @function\n     * @public\n     * @param {PropertyId | string} name - The property to get.\n     * @param {string} def - The default value to return in case the property is not known.\n     * @returns {string} The current value, or provided default, of the given property.\n     */\n    getProperty(name, def) {\n        return this.privSpeechConfig.getProperty(name);\n    }\n    /**\n     * Sets the proxy configuration.\n     * Only relevant in Node.js environments.\n     * Added in version 1.4.0.\n     * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)\n     * @param proxyPort The port number of the proxy server.\n     * @param proxyUserName The user name of the proxy server.\n     * @param proxyPassword The password of the proxy server.\n     */\n    setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {\n        this.setProperty(PropertyId.SpeechServiceConnection_ProxyHostName, proxyHostName);\n        this.setProperty(PropertyId.SpeechServiceConnection_ProxyPort, `${proxyPort}`);\n        if (proxyUserName) {\n            this.setProperty(PropertyId.SpeechServiceConnection_ProxyUserName, proxyUserName);\n        }\n        if (proxyPassword) {\n            this.setProperty(PropertyId.SpeechServiceConnection_ProxyPassword, proxyPassword);\n        }\n    }\n    setServiceProperty(name, value, channel) {\n        this.privSpeechConfig.setServiceProperty(name, value, channel);\n    }\n    /**\n     * Dispose of associated resources.\n     * @member DialogServiceConfigImpl.prototype.close\n     * @function\n     * @public\n     */\n    close() {\n        return;\n    }\n}\n\n//# sourceMappingURL=DialogServiceConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DialogConnectionFactory } from \"../common.speech/DialogConnectorFactory\";\nimport { DialogServiceAdapter, RecognitionMode, RecognizerConfig, } from \"../common.speech/Exports\";\nimport { Deferred, marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { Recognizer } from \"./Exports\";\nimport { PropertyId } from \"./PropertyId\";\n/**\n * Dialog Service Connector\n * @class DialogServiceConnector\n */\nexport class DialogServiceConnector extends Recognizer {\n    /**\n     * Initializes an instance of the DialogServiceConnector.\n     * @constructor\n     * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.\n     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer\n     */\n    constructor(dialogConfig, audioConfig) {\n        const dialogServiceConfigImpl = dialogConfig;\n        Contracts.throwIfNull(dialogConfig, \"dialogConfig\");\n        super(audioConfig, dialogServiceConfigImpl.properties, new DialogConnectionFactory());\n        this.isTurnComplete = true;\n        this.privIsDisposed = false;\n        this.privProperties = dialogServiceConfigImpl.properties.clone();\n        const agentConfig = this.buildAgentConfig();\n        this.privReco.agentConfig.set(agentConfig);\n    }\n    /**\n     * Starts a connection to the service.\n     * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.\n     *\n     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\n     * be notified when the connection is established.\n     * @member DialogServiceConnector.prototype.connect\n     * @function\n     * @public\n     */\n    connect(cb, err) {\n        marshalPromiseToCallbacks(this.privReco.connect(), cb, err);\n    }\n    /**\n     * Closes the connection the service.\n     * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.\n     *\n     * If disconnect() is called during a recognition, recognition will fail and cancel with an error.\n     */\n    disconnect(cb, err) {\n        marshalPromiseToCallbacks(this.privReco.disconnect(), cb, err);\n    }\n    /**\n     * Gets the authorization token used to communicate with the service.\n     * @member DialogServiceConnector.prototype.authorizationToken\n     * @function\n     * @public\n     * @returns {string} Authorization token.\n     */\n    get authorizationToken() {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    /**\n     * Sets the authorization token used to communicate with the service.\n     * @member DialogServiceConnector.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} token - Authorization token.\n     */\n    set authorizationToken(token) {\n        Contracts.throwIfNullOrWhitespace(token, \"token\");\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, token);\n    }\n    /**\n     * The collection of properties and their values defined for this DialogServiceConnector.\n     * @member DialogServiceConnector.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    /** Gets the template for the activity generated by service from speech.\n     * Properties from the template will be stamped on the generated activity.\n     * It can be empty\n     */\n    get speechActivityTemplate() {\n        return this.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\n    }\n    /** Sets the template for the activity generated by service from speech.\n     * Properties from the template will be stamped on the generated activity.\n     * It can be null or empty.\n     * Note: it has to be a valid Json object.\n     */\n    set speechActivityTemplate(speechActivityTemplate) {\n        this.properties.setProperty(PropertyId.Conversation_Speech_Activity_Template, speechActivityTemplate);\n    }\n    /**\n     * Starts recognition and stops after the first utterance is recognized.\n     * @member DialogServiceConnector.prototype.listenOnceAsync\n     * @function\n     * @public\n     * @param cb - Callback that received the result when the reco has completed.\n     * @param err - Callback invoked in case of an error.\n     */\n    listenOnceAsync(cb, err) {\n        if (this.isTurnComplete) {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            const callbackHolder = () => __awaiter(this, void 0, void 0, function* () {\n                yield this.privReco.connect();\n                yield this.implRecognizerStop();\n                this.isTurnComplete = false;\n                const ret = new Deferred();\n                yield this.privReco.recognize(RecognitionMode.Conversation, ret.resolve, ret.reject);\n                const e = yield ret.promise;\n                yield this.implRecognizerStop();\n                return e;\n            });\n            const retPromise = callbackHolder();\n            retPromise.catch(() => {\n                // Destroy the recognizer.\n                /* tslint:disable:no-empty */ // We've done all we can here.\n                this.dispose(true).catch(() => { });\n            });\n            marshalPromiseToCallbacks(retPromise.finally(() => {\n                this.isTurnComplete = true;\n            }), cb, err);\n        }\n    }\n    sendActivityAsync(activity, cb, errCb) {\n        marshalPromiseToCallbacks(this.privReco.sendMessage(activity), cb, errCb);\n    }\n    /**\n     * closes all external resources held by an instance of this class.\n     * @member DialogServiceConnector.prototype.close\n     * @function\n     * @public\n     */\n    close(cb, err) {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        marshalPromiseToCallbacks(this.dispose(true), cb, err);\n    }\n    dispose(disposing) {\n        const _super = Object.create(null, {\n            dispose: { get: () => super.dispose }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privIsDisposed) {\n                return;\n            }\n            if (disposing) {\n                this.privIsDisposed = true;\n                yield this.implRecognizerStop();\n                yield _super.dispose.call(this, disposing);\n            }\n        });\n    }\n    createRecognizerConfig(speechConfig) {\n        return new RecognizerConfig(speechConfig, this.privProperties);\n    }\n    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n        const audioSource = audioConfig;\n        return new DialogServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);\n    }\n    buildAgentConfig() {\n        const communicationType = this.properties.getProperty(\"Conversation_Communication_Type\", \"Default\");\n        return {\n            botInfo: {\n                commType: communicationType,\n                commandsCulture: undefined,\n                connectionId: this.properties.getProperty(PropertyId.Conversation_Agent_Connection_Id),\n                conversationId: this.properties.getProperty(PropertyId.Conversation_Conversation_Id, undefined),\n                fromId: this.properties.getProperty(PropertyId.Conversation_From_Id, undefined),\n                ttsAudioFormat: this.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)\n            },\n            version: 0.2\n        };\n    }\n}\n\n//# sourceMappingURL=DialogServiceConnector.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport { AudioConfig } from \"./Audio/AudioConfig\";\nexport { AudioStreamFormat } from \"./Audio/AudioStreamFormat\";\nexport { AudioInputStream, PullAudioInputStream, PushAudioInputStream } from \"./Audio/AudioInputStream\";\nexport { AudioOutputStream, PullAudioOutputStream, PushAudioOutputStream } from \"./Audio/AudioOutputStream\";\nexport { CancellationReason } from \"./CancellationReason\";\nexport { PullAudioInputStreamCallback } from \"./Audio/PullAudioInputStreamCallback\";\nexport { PushAudioOutputStreamCallback } from \"./Audio/PushAudioOutputStreamCallback\";\nexport { KeywordRecognitionModel } from \"./KeywordRecognitionModel\";\nexport { SessionEventArgs } from \"./SessionEventArgs\";\nexport { RecognitionEventArgs } from \"./RecognitionEventArgs\";\nexport { OutputFormat } from \"./OutputFormat\";\nexport { IntentRecognitionEventArgs } from \"./IntentRecognitionEventArgs\";\nexport { RecognitionResult } from \"./RecognitionResult\";\nexport { SpeechRecognitionResult } from \"./SpeechRecognitionResult\";\nexport { IntentRecognitionResult } from \"./IntentRecognitionResult\";\nexport { LanguageUnderstandingModel } from \"./LanguageUnderstandingModel\";\nexport { SpeechRecognitionEventArgs, ConversationTranscriptionEventArgs } from \"./SpeechRecognitionEventArgs\";\nexport { SpeechRecognitionCanceledEventArgs } from \"./SpeechRecognitionCanceledEventArgs\";\nexport { TranslationRecognitionEventArgs } from \"./TranslationRecognitionEventArgs\";\nexport { TranslationSynthesisEventArgs } from \"./TranslationSynthesisEventArgs\";\nexport { TranslationRecognitionResult } from \"./TranslationRecognitionResult\";\nexport { TranslationSynthesisResult } from \"./TranslationSynthesisResult\";\nexport { ResultReason } from \"./ResultReason\";\nexport { SpeechConfig, SpeechConfigImpl } from \"./SpeechConfig\";\nexport { SpeechTranslationConfig, SpeechTranslationConfigImpl } from \"./SpeechTranslationConfig\";\nexport { PropertyCollection } from \"./PropertyCollection\";\nexport { PropertyId } from \"./PropertyId\";\nexport { Recognizer } from \"./Recognizer\";\nexport { SpeechRecognizer } from \"./SpeechRecognizer\";\nexport { IntentRecognizer } from \"./IntentRecognizer\";\nexport { VoiceProfileType } from \"./VoiceProfileType\";\nexport { TranslationRecognizer } from \"./TranslationRecognizer\";\nexport { Translations } from \"./Translations\";\nexport { NoMatchReason } from \"./NoMatchReason\";\nexport { NoMatchDetails } from \"./NoMatchDetails\";\nexport { TranslationRecognitionCanceledEventArgs } from \"./TranslationRecognitionCanceledEventArgs\";\nexport { IntentRecognitionCanceledEventArgs } from \"./IntentRecognitionCanceledEventArgs\";\nexport { CancellationDetailsBase } from \"./CancellationDetailsBase\";\nexport { CancellationDetails } from \"./CancellationDetails\";\nexport { CancellationErrorCode } from \"./CancellationErrorCodes\";\nexport { ConnectionEventArgs } from \"./ConnectionEventArgs\";\nexport { ServiceEventArgs } from \"./ServiceEventArgs\";\nexport { Connection } from \"./Connection\";\nexport { PhraseListGrammar } from \"./PhraseListGrammar\";\nexport { DialogServiceConfig } from \"./DialogServiceConfig\";\nexport { BotFrameworkConfig } from \"./BotFrameworkConfig\";\nexport { CustomCommandsConfig } from \"./CustomCommandsConfig\";\nexport { DialogServiceConnector } from \"./DialogServiceConnector\";\nexport { ActivityReceivedEventArgs } from \"./ActivityReceivedEventArgs\";\nexport { TurnStatusReceivedEventArgs } from \"./TurnStatusReceivedEventArgs\";\nexport { ServicePropertyChannel } from \"./ServicePropertyChannel\";\nexport { ProfanityOption } from \"./ProfanityOption\";\nexport { BaseAudioPlayer } from \"./Audio/BaseAudioPlayer\";\nexport { ConnectionMessageEventArgs } from \"./ConnectionMessageEventArgs\";\nexport { ConnectionMessage } from \"./ConnectionMessage\";\nexport { VoiceProfile } from \"./VoiceProfile\";\nexport { VoiceProfileEnrollmentResult, VoiceProfileEnrollmentCancellationDetails } from \"./VoiceProfileEnrollmentResult\";\nexport { VoiceProfileResult, VoiceProfileCancellationDetails } from \"./VoiceProfileResult\";\nexport { VoiceProfilePhraseResult } from \"./VoiceProfilePhraseResult\";\nexport { VoiceProfileClient } from \"./VoiceProfileClient\";\nexport { SpeakerRecognizer } from \"./SpeakerRecognizer\";\nexport { SpeakerIdentificationModel } from \"./SpeakerIdentificationModel\";\nexport { SpeakerVerificationModel } from \"./SpeakerVerificationModel\";\nexport { AutoDetectSourceLanguageConfig } from \"./AutoDetectSourceLanguageConfig\";\nexport { AutoDetectSourceLanguageResult } from \"./AutoDetectSourceLanguageResult\";\nexport { SourceLanguageConfig } from \"./SourceLanguageConfig\";\nexport { SpeakerRecognitionResult, SpeakerRecognitionResultType, SpeakerRecognitionCancellationDetails } from \"./SpeakerRecognitionResult\";\nexport { Conversation, ConversationExpirationEventArgs, ConversationParticipantsChangedEventArgs, ConversationTranslationCanceledEventArgs, ConversationTranslationEventArgs, ConversationTranslationResult, ConversationTranslator, ConversationTranscriber, Participant, ParticipantChangedReason, User } from \"./Transcription/Exports\";\nexport { SpeechSynthesisOutputFormat } from \"./SpeechSynthesisOutputFormat\";\nexport { SpeechSynthesizer } from \"./SpeechSynthesizer\";\nexport { SpeechSynthesisResult } from \"./SpeechSynthesisResult\";\nexport { SpeechSynthesisEventArgs } from \"./SpeechSynthesisEventArgs\";\nexport { SpeechSynthesisWordBoundaryEventArgs } from \"./SpeechSynthesisWordBoundaryEventArgs\";\nexport { SpeechSynthesisBookmarkEventArgs } from \"./SpeechSynthesisBookmarkEventArgs\";\nexport { SpeechSynthesisVisemeEventArgs } from \"./SpeechSynthesisVisemeEventArgs\";\nexport { SpeakerAudioDestination } from \"./Audio/SpeakerAudioDestination\";\nexport { ConversationTranscriptionCanceledEventArgs } from \"./ConversationTranscriptionCanceledEventArgs\";\nexport { PronunciationAssessmentGradingSystem } from \"./PronunciationAssessmentGradingSystem\";\nexport { PronunciationAssessmentGranularity } from \"./PronunciationAssessmentGranularity\";\nexport { PronunciationAssessmentConfig } from \"./PronunciationAssessmentConfig\";\nexport { PronunciationAssessmentResult } from \"./PronunciationAssessmentResult\";\n\n//# sourceMappingURL=Exports.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { IntentRecognitionEventArgs } from \"./Exports\";\n/**\n * Define payload of intent recognition canceled result events.\n * @class IntentRecognitionCanceledEventArgs\n */\nexport class IntentRecognitionCanceledEventArgs extends IntentRecognitionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {CancellationReason} result - The result of the intent recognition.\n     * @param {string} offset - The offset.\n     * @param {IntentRecognitionResult} sessionId - The session id.\n     */\n    constructor(reason, errorDetails, errorCode, result, offset, sessionId) {\n        super(result, offset, sessionId);\n        this.privReason = reason;\n        this.privErrorDetails = errorDetails;\n        this.privErrorCode = errorCode;\n    }\n    /**\n     * The reason the recognition was canceled.\n     * @member IntentRecognitionCanceledEventArgs.prototype.reason\n     * @function\n     * @public\n     * @returns {CancellationReason} Specifies the reason canceled.\n     */\n    get reason() {\n        return this.privReason;\n    }\n    /**\n     * The error code in case of an unsuccessful recognition.\n     * Added in version 1.1.0.\n     * @return An error code that represents the error reason.\n     */\n    get errorCode() {\n        return this.privErrorCode;\n    }\n    /**\n     * In case of an unsuccessful recognition, provides details of the occurred error.\n     * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails\n     * @function\n     * @public\n     * @returns {string} A String that represents the error details.\n     */\n    get errorDetails() {\n        return this.privErrorDetails;\n    }\n}\n\n//# sourceMappingURL=IntentRecognitionCanceledEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RecognitionEventArgs } from \"./Exports\";\n/**\n * Intent recognition result event arguments.\n * @class\n */\nexport class IntentRecognitionEventArgs extends RecognitionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param result - The result of the intent recognition.\n     * @param offset - The offset.\n     * @param sessionId - The session id.\n     */\n    constructor(result, offset, sessionId) {\n        super(offset, sessionId);\n        this.privResult = result;\n    }\n    /**\n     * Represents the intent recognition result.\n     * @member IntentRecognitionEventArgs.prototype.result\n     * @function\n     * @public\n     * @returns {IntentRecognitionResult} Represents the intent recognition result.\n     */\n    get result() {\n        return this.privResult;\n    }\n}\n\n//# sourceMappingURL=IntentRecognitionEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { SpeechRecognitionResult } from \"./Exports\";\n/**\n * Intent recognition result.\n * @class\n */\nexport class IntentRecognitionResult extends SpeechRecognitionResult {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param intentId - The intent id.\n     * @param resultId - The result id.\n     * @param reason - The reason.\n     * @param text - The recognized text.\n     * @param duration - The duration.\n     * @param offset - The offset into the stream.\n     * @param language - Primary Language detected, if provided.\n     * @param languageDetectionConfidence - Primary Language confidence (\"Unknown,\" \"Low,\" \"Medium,\" \"High\"...), if provided.\n     * @param errorDetails - Error details, if provided.\n     * @param json - Additional Json, if provided.\n     * @param properties - Additional properties, if provided.\n     */\n    constructor(intentId, resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {\n        super(resultId, reason, text, duration, offset, language, languageDetectionConfidence, undefined, errorDetails, json, properties);\n        this.privIntentId = intentId;\n    }\n    /**\n     * A String that represents the intent identifier being recognized.\n     * @member IntentRecognitionResult.prototype.intentId\n     * @function\n     * @public\n     * @returns {string} A String that represents the intent identifier being recognized.\n     */\n    get intentId() {\n        return this.privIntentId;\n    }\n}\n\n//# sourceMappingURL=IntentRecognitionResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AddedLmIntent, IntentConnectionFactory, IntentServiceRecognizer, RecognitionMode, RecognizerConfig, } from \"../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { PropertyId, Recognizer, } from \"./Exports\";\n/**\n * Intent recognizer.\n * @class\n */\nexport class IntentRecognizer extends Recognizer {\n    /**\n     * Initializes an instance of the IntentRecognizer.\n     * @constructor\n     * @param {SpeechConfig} speechConfig - The set of configuration properties.\n     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer\n     */\n    constructor(speechConfig, audioConfig) {\n        Contracts.throwIfNullOrUndefined(speechConfig, \"speechConfig\");\n        const configImpl = speechConfig;\n        Contracts.throwIfNullOrUndefined(configImpl, \"speechConfig\");\n        super(audioConfig, configImpl.properties, new IntentConnectionFactory());\n        this.privAddedIntents = [];\n        this.privAddedLmIntents = {};\n        this.privDisposedIntentRecognizer = false;\n        this.privProperties = configImpl.properties;\n        Contracts.throwIfNullOrWhitespace(this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage), PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n    }\n    /**\n     * Gets the spoken language of recognition.\n     * @member IntentRecognizer.prototype.speechRecognitionLanguage\n     * @function\n     * @public\n     * @returns {string} the spoken language of recognition.\n     */\n    get speechRecognitionLanguage() {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n    }\n    /**\n     * Gets the authorization token used to communicate with the service.\n     * @member IntentRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @returns {string} Authorization token.\n     */\n    get authorizationToken() {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    /**\n     * Gets/Sets the authorization token used to communicate with the service.\n     * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.\n     * @member IntentRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} value - Authorization token.\n     */\n    set authorizationToken(value) {\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, value);\n    }\n    /**\n     * The collection of properties and their values defined for this IntentRecognizer.\n     * @member IntentRecognizer.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The collection of properties and their\n     *          values defined for this IntentRecognizer.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    /**\n     * Starts intent recognition, and stops after the first utterance is recognized.\n     * The task returns the recognition text and intent as result.\n     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,\n     *       so it is suitable only for single shot recognition like command or query.\n     *       For long-running recognition, use StartContinuousRecognitionAsync() instead.\n     * @member IntentRecognizer.prototype.recognizeOnceAsync\n     * @function\n     * @public\n     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.\n     * @param err - Callback invoked in case of an error.\n     */\n    recognizeOnceAsync(cb, err) {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n        if (Object.keys(this.privAddedLmIntents).length !== 0 || undefined !== this.privUmbrellaIntent) {\n            const context = this.buildSpeechContext();\n            this.privReco.speechContext.setSection(\"intent\", context.Intent);\n            this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);\n            const intentReco = this.privReco;\n            intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);\n        }\n        marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(RecognitionMode.Interactive), cb, err);\n    }\n    /**\n     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.\n     * User must subscribe to events to receive recognition results.\n     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the recognition has started.\n     * @param err - Callback invoked in case of an error.\n     */\n    startContinuousRecognitionAsync(cb, err) {\n        if (Object.keys(this.privAddedLmIntents).length !== 0 || undefined !== this.privUmbrellaIntent) {\n            const context = this.buildSpeechContext();\n            this.privReco.speechContext.setSection(\"intent\", context.Intent);\n            this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);\n            const intentReco = this.privReco;\n            intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);\n        }\n        marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(RecognitionMode.Conversation), cb, err);\n    }\n    /**\n     * Stops continuous intent recognition.\n     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the recognition has stopped.\n     * @param err - Callback invoked in case of an error.\n     */\n    stopContinuousRecognitionAsync(cb, err) {\n        marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);\n    }\n    /**\n     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.\n     * User must subscribe to events to receive recognition results.\n     * Note: Key word spotting functionality is only available on the Speech Devices SDK.\n     *       This functionality is currently not included in the SDK itself.\n     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync\n     * @function\n     * @public\n     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.\n     * @param cb - Callback invoked once the recognition has started.\n     * @param err - Callback invoked in case of an error.\n     */\n    startKeywordRecognitionAsync(model, cb, err) {\n        Contracts.throwIfNull(model, \"model\");\n        if (!!err) {\n            err(\"Not yet implemented.\");\n        }\n    }\n    /**\n     * Stops continuous speech recognition.\n     * Note: Key word spotting functionality is only available on the Speech Devices SDK.\n     *       This functionality is currently not included in the SDK itself.\n     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the recognition has stopped.\n     * @param err - Callback invoked in case of an error.\n     */\n    stopKeywordRecognitionAsync(cb, err) {\n        if (!!cb) {\n            cb();\n        }\n    }\n    /**\n     * Adds a phrase that should be recognized as intent.\n     * @member IntentRecognizer.prototype.addIntent\n     * @function\n     * @public\n     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.\n     * @param {string} phrase - A String that specifies the phrase representing the intent.\n     */\n    addIntent(simplePhrase, intentId) {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n        Contracts.throwIfNullOrWhitespace(intentId, \"intentId\");\n        Contracts.throwIfNullOrWhitespace(simplePhrase, \"simplePhrase\");\n        this.privAddedIntents.push([intentId, simplePhrase]);\n    }\n    /**\n     * Adds an intent from Language Understanding service for recognition.\n     * @member IntentRecognizer.prototype.addIntentWithLanguageModel\n     * @function\n     * @public\n     * @param {string} intentId - A String that represents the identifier of the intent\n     *        to be recognized. Ignored if intentName is empty.\n     * @param {string} model - The intent model from Language Understanding service.\n     * @param {string} intentName - The intent name defined in the intent model. If it\n     *        is empty, all intent names defined in the model will be added.\n     */\n    addIntentWithLanguageModel(intentId, model, intentName) {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n        Contracts.throwIfNullOrWhitespace(intentId, \"intentId\");\n        Contracts.throwIfNull(model, \"model\");\n        const modelImpl = model;\n        Contracts.throwIfNullOrWhitespace(modelImpl.appId, \"model.appId\");\n        this.privAddedLmIntents[intentId] = new AddedLmIntent(modelImpl, intentName);\n    }\n    /**\n     * @summary Adds all intents from the specified Language Understanding Model.\n     * @member IntentRecognizer.prototype.addAllIntents\n     * @function\n     * @public\n     * @function\n     * @public\n     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.\n     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.\n     */\n    addAllIntents(model, intentId) {\n        Contracts.throwIfNull(model, \"model\");\n        const modelImpl = model;\n        Contracts.throwIfNullOrWhitespace(modelImpl.appId, \"model.appId\");\n        this.privUmbrellaIntent = new AddedLmIntent(modelImpl, intentId);\n    }\n    /**\n     * closes all external resources held by an instance of this class.\n     * @member IntentRecognizer.prototype.close\n     * @function\n     * @public\n     */\n    close(cb, errorCb) {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n        marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n    }\n    createRecognizerConfig(speechConfig) {\n        return new RecognizerConfig(speechConfig, this.properties);\n    }\n    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n        const audioImpl = audioConfig;\n        return new IntentServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);\n    }\n    dispose(disposing) {\n        const _super = Object.create(null, {\n            dispose: { get: () => super.dispose }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privDisposedIntentRecognizer) {\n                return;\n            }\n            if (disposing) {\n                this.privDisposedIntentRecognizer = true;\n                yield _super.dispose.call(this, disposing);\n            }\n        });\n    }\n    buildSpeechContext() {\n        let appId;\n        let region;\n        let subscriptionKey;\n        const refGrammers = [];\n        if (undefined !== this.privUmbrellaIntent) {\n            appId = this.privUmbrellaIntent.modelImpl.appId;\n            region = this.privUmbrellaIntent.modelImpl.region;\n            subscriptionKey = this.privUmbrellaIntent.modelImpl.subscriptionKey;\n        }\n        // Build the reference grammer array.\n        for (const intentId of Object.keys(this.privAddedLmIntents)) {\n            const addedLmIntent = this.privAddedLmIntents[intentId];\n            // validate all the same model, region, and key...\n            if (appId === undefined) {\n                appId = addedLmIntent.modelImpl.appId;\n            }\n            else {\n                if (appId !== addedLmIntent.modelImpl.appId) {\n                    throw new Error(\"Intents must all be from the same LUIS model\");\n                }\n            }\n            if (region === undefined) {\n                region = addedLmIntent.modelImpl.region;\n            }\n            else {\n                if (region !== addedLmIntent.modelImpl.region) {\n                    throw new Error(\"Intents must all be from the same LUIS model in a single region\");\n                }\n            }\n            if (subscriptionKey === undefined) {\n                subscriptionKey = addedLmIntent.modelImpl.subscriptionKey;\n            }\n            else {\n                if (subscriptionKey !== addedLmIntent.modelImpl.subscriptionKey) {\n                    throw new Error(\"Intents must all use the same subscription key\");\n                }\n            }\n            const grammer = \"luis/\" + appId + \"-PRODUCTION#\" + intentId;\n            refGrammers.push(grammer);\n        }\n        return {\n            Intent: {\n                id: appId,\n                key: (subscriptionKey === undefined) ? this.privProperties.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key]) : subscriptionKey,\n                provider: \"LUIS\",\n            },\n            ReferenceGrammars: (undefined === this.privUmbrellaIntent) ? refGrammers : [\"luis/\" + appId + \"-PRODUCTION\"],\n        };\n    }\n}\n\n//# sourceMappingURL=IntentRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\n/**\n * Represents a keyword recognition model for recognizing when\n * the user says a keyword to initiate further speech recognition.\n * @class KeywordRecognitionModel\n */\nexport class KeywordRecognitionModel {\n    /**\n     * Create and initializes a new instance.\n     * @constructor\n     */\n    constructor() {\n        this.privDisposed = false;\n    }\n    /**\n     * Creates a keyword recognition model using the specified filename.\n     * @member KeywordRecognitionModel.fromFile\n     * @function\n     * @public\n     * @param {string} fileName - A string that represents file name for the keyword recognition model.\n     *        Note, the file can point to a zip file in which case the model\n     *        will be extracted from the zip.\n     * @returns {KeywordRecognitionModel} The keyword recognition model being created.\n     */\n    static fromFile(fileName) {\n        Contracts.throwIfFileDoesNotExist(fileName, \"fileName\");\n        throw new Error(\"Not yet implemented.\");\n    }\n    /**\n     * Creates a keyword recognition model using the specified filename.\n     * @member KeywordRecognitionModel.fromStream\n     * @function\n     * @public\n     * @param {string} file - A File that represents file for the keyword recognition model.\n     *        Note, the file can point to a zip file in which case the model will be extracted from the zip.\n     * @returns {KeywordRecognitionModel} The keyword recognition model being created.\n     */\n    static fromStream(file) {\n        Contracts.throwIfNull(file, \"file\");\n        throw new Error(\"Not yet implemented.\");\n    }\n    /**\n     * Dispose of associated resources.\n     * @member KeywordRecognitionModel.prototype.close\n     * @function\n     * @public\n     */\n    close() {\n        if (this.privDisposed) {\n            return;\n        }\n        this.privDisposed = true;\n    }\n}\n\n//# sourceMappingURL=KeywordRecognitionModel.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\n/**\n * Language understanding model\n * @class LanguageUnderstandingModel\n */\nexport class LanguageUnderstandingModel {\n    /**\n     * Creates and initializes a new instance\n     * @constructor\n     */\n    constructor() {\n    }\n    /**\n     * Creates an language understanding model using the specified endpoint.\n     * @member LanguageUnderstandingModel.fromEndpoint\n     * @function\n     * @public\n     * @param {URL} uri - A String that represents the endpoint of the language understanding model.\n     * @returns {LanguageUnderstandingModel} The language understanding model being created.\n     */\n    static fromEndpoint(uri) {\n        Contracts.throwIfNull(uri, \"uri\");\n        Contracts.throwIfNullOrWhitespace(uri.hostname, \"uri\");\n        const langModelImp = new LanguageUnderstandingModelImpl();\n        // Need to extract the app ID from the URL.\n        // URL is in the format: https://<region>.api.cognitive.microsoft.com/luis/v2.0/apps/<Guid>?subscription-key=<key>&timezoneOffset=-360\n        // Start tearing the string apart.\n        // region can be extracted from the host name.\n        const firstDot = uri.host.indexOf(\".\");\n        if (-1 === firstDot) {\n            throw new Error(\"Could not determine region from endpoint\");\n        }\n        langModelImp.region = uri.host.substr(0, firstDot);\n        // Now the app ID.\n        const lastSegment = uri.pathname.lastIndexOf(\"/\") + 1;\n        if (-1 === lastSegment) {\n            throw new Error(\"Could not determine appId from endpoint\");\n        }\n        langModelImp.appId = uri.pathname.substr(lastSegment);\n        // And finally the key.\n        langModelImp.subscriptionKey = uri.searchParams.get(\"subscription-key\");\n        if (undefined === langModelImp.subscriptionKey) {\n            throw new Error(\"Could not determine subscription key from endpoint\");\n        }\n        return langModelImp;\n    }\n    /**\n     * Creates an language understanding model using the application id of Language Understanding service.\n     * @member LanguageUnderstandingModel.fromAppId\n     * @function\n     * @public\n     * @param {string} appId - A String that represents the application id of Language Understanding service.\n     * @returns {LanguageUnderstandingModel} The language understanding model being created.\n     */\n    static fromAppId(appId) {\n        Contracts.throwIfNullOrWhitespace(appId, \"appId\");\n        const langModelImp = new LanguageUnderstandingModelImpl();\n        langModelImp.appId = appId;\n        return langModelImp;\n    }\n    /**\n     * Creates a language understanding model using hostname, subscription key and application\n     * id of Language Understanding service.\n     * @member LanguageUnderstandingModel.fromSubscription\n     * @function\n     * @public\n     * @param {string} subscriptionKey - A String that represents the subscription key of\n     *        Language Understanding service.\n     * @param {string} appId - A String that represents the application id of Language\n     *        Understanding service.\n     * @param {LanguageUnderstandingModel} region - A String that represents the region\n     *        of the Language Understanding service (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n     * @returns {LanguageUnderstandingModel} The language understanding model being created.\n     */\n    static fromSubscription(subscriptionKey, appId, region) {\n        Contracts.throwIfNullOrWhitespace(subscriptionKey, \"subscriptionKey\");\n        Contracts.throwIfNullOrWhitespace(appId, \"appId\");\n        Contracts.throwIfNullOrWhitespace(region, \"region\");\n        const langModelImp = new LanguageUnderstandingModelImpl();\n        langModelImp.appId = appId;\n        langModelImp.region = region;\n        langModelImp.subscriptionKey = subscriptionKey;\n        return langModelImp;\n    }\n}\n/**\n * @private\n * @class LanguageUnderstandingModelImpl\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class LanguageUnderstandingModelImpl extends LanguageUnderstandingModel {\n}\n\n//# sourceMappingURL=LanguageUnderstandingModel.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RecognitionStatus, SimpleSpeechPhrase } from \"../../src/common.speech/Exports\";\nimport { NoMatchReason } from \"./Exports\";\n/**\n * Contains detailed information for NoMatch recognition results.\n * @class NoMatchDetails\n */\nexport class NoMatchDetails {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {NoMatchReason} reason - The no-match reason.\n     */\n    constructor(reason) {\n        this.privReason = reason;\n    }\n    /**\n     * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.\n     * @member NoMatchDetails.fromResult\n     * @function\n     * @public\n     * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}\n     *        result - The recognition result that was not recognized.\n     * @returns {NoMatchDetails} The no match details object being created.\n     */\n    static fromResult(result) {\n        const simpleSpeech = SimpleSpeechPhrase.fromJSON(result.json);\n        let reason = NoMatchReason.NotRecognized;\n        switch (simpleSpeech.RecognitionStatus) {\n            case RecognitionStatus.BabbleTimeout:\n                reason = NoMatchReason.InitialBabbleTimeout;\n                break;\n            case RecognitionStatus.InitialSilenceTimeout:\n                reason = NoMatchReason.InitialSilenceTimeout;\n                break;\n            default:\n                reason = NoMatchReason.NotRecognized;\n                break;\n        }\n        return new NoMatchDetails(reason);\n    }\n    /**\n     * The reason the recognition was canceled.\n     * @member NoMatchDetails.prototype.reason\n     * @function\n     * @public\n     * @returns {NoMatchReason} Specifies the reason canceled.\n     */\n    get reason() {\n        return this.privReason;\n    }\n}\n\n//# sourceMappingURL=NoMatchDetails.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines the possible reasons a recognition result might not be recognized.\n * @class NoMatchReason\n */\nexport var NoMatchReason;\n(function (NoMatchReason) {\n    /**\n     * Indicates that speech was detected, but not recognized.\n     * @member NoMatchReason.NotRecognized\n     */\n    NoMatchReason[NoMatchReason[\"NotRecognized\"] = 0] = \"NotRecognized\";\n    /**\n     * Indicates that the start of the audio stream contained only silence,\n     * and the service timed out waiting for speech.\n     * @member NoMatchReason.InitialSilenceTimeout\n     */\n    NoMatchReason[NoMatchReason[\"InitialSilenceTimeout\"] = 1] = \"InitialSilenceTimeout\";\n    /**\n     * Indicates that the start of the audio stream contained only noise,\n     * and the service timed out waiting for speech.\n     * @member NoMatchReason.InitialBabbleTimeout\n     */\n    NoMatchReason[NoMatchReason[\"InitialBabbleTimeout\"] = 2] = \"InitialBabbleTimeout\";\n})(NoMatchReason || (NoMatchReason = {}));\n\n//# sourceMappingURL=NoMatchReason.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Define Speech Recognizer output formats.\n * @class OutputFormat\n */\nexport var OutputFormat;\n(function (OutputFormat) {\n    /**\n     * @member OutputFormat.Simple\n     */\n    OutputFormat[OutputFormat[\"Simple\"] = 0] = \"Simple\";\n    /**\n     * @member OutputFormat.Detailed\n     */\n    OutputFormat[OutputFormat[\"Detailed\"] = 1] = \"Detailed\";\n})(OutputFormat || (OutputFormat = {}));\n\n//# sourceMappingURL=OutputFormat.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Allows additions of new phrases to improve speech recognition.\n *\n * Phrases added to the recognizer are effective at the start of the next recognition, or the next time the SpeechSDK must reconnect\n * to the speech service.\n */\nexport class PhraseListGrammar {\n    constructor(recogBase) {\n        this.privGrammerBuilder = recogBase.dynamicGrammar;\n    }\n    /**\n     * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.\n     * @param recognizer The recognizer to add phrase lists to.\n     */\n    static fromRecognizer(recognizer) {\n        const recoBase = recognizer.internalData;\n        return new PhraseListGrammar(recoBase);\n    }\n    /**\n     * Adds a single phrase to the current recognizer.\n     * @param phrase Phrase to add.\n     */\n    addPhrase(phrase) {\n        this.privGrammerBuilder.addPhrase(phrase);\n    }\n    /**\n     * Adds multiple phrases to the current recognizer.\n     * @param phrases Array of phrases to add.\n     */\n    addPhrases(phrases) {\n        this.privGrammerBuilder.addPhrase(phrases);\n    }\n    /**\n     * Clears all phrases added to the current recognizer.\n     */\n    clear() {\n        this.privGrammerBuilder.clearPhrases();\n    }\n}\n\n//# sourceMappingURL=PhraseListGrammar.js.map\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * Profanity option.\n * Added in version 1.7.0.\n */\nexport var ProfanityOption;\n(function (ProfanityOption) {\n    ProfanityOption[ProfanityOption[\"Masked\"] = 0] = \"Masked\";\n    ProfanityOption[ProfanityOption[\"Removed\"] = 1] = \"Removed\";\n    ProfanityOption[ProfanityOption[\"Raw\"] = 2] = \"Raw\";\n})(ProfanityOption || (ProfanityOption = {}));\n\n//# sourceMappingURL=ProfanityOption.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\nimport { PronunciationAssessmentGradingSystem, PronunciationAssessmentGranularity, PropertyCollection, PropertyId } from \"./Exports\";\n/**\n * Pronunciation assessment configuration.\n * @class PronunciationAssessmentConfig\n * Added in version 1.15.0.\n */\nexport class PronunciationAssessmentConfig {\n    /**\n     * PronunciationAssessmentConfig constructor.\n     * @constructor\n     * @param {string} referenceText\n     * @param gradingSystem\n     * @param granularity\n     * @param enableMiscue\n     */\n    constructor(referenceText, gradingSystem = PronunciationAssessmentGradingSystem.FivePoint, granularity = PronunciationAssessmentGranularity.Phoneme, enableMiscue = false) {\n        Contracts.throwIfNullOrUndefined(referenceText, \"referenceText\");\n        this.privProperties = new PropertyCollection();\n        this.privProperties.setProperty(PropertyId.PronunciationAssessment_ReferenceText, referenceText);\n        this.privProperties.setProperty(PropertyId.PronunciationAssessment_GradingSystem, PronunciationAssessmentGradingSystem[gradingSystem]);\n        this.privProperties.setProperty(PropertyId.PronunciationAssessment_Granularity, PronunciationAssessmentGranularity[granularity]);\n        this.privProperties.setProperty(PropertyId.PronunciationAssessment_EnableMiscue, String(enableMiscue));\n    }\n    /**\n     * @member PronunciationAssessmentConfig.fromJSON\n     * @function\n     * @public\n     * @param {string} json The json string containing the pronunciation assessment parameters.\n     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig\n     * @summary Creates an instance of the PronunciationAssessmentConfig from json.\n     */\n    static fromJSON(json) {\n        Contracts.throwIfNullOrUndefined(json, \"json\");\n        const config = new PronunciationAssessmentConfig(\"\");\n        config.privProperties = new PropertyCollection();\n        config.properties.setProperty(PropertyId.PronunciationAssessment_Json, json);\n        return config;\n    }\n    toJSON() {\n        this.updateJson();\n        return this.privProperties.getProperty(PropertyId.PronunciationAssessment_Params);\n    }\n    applyTo(recognizer) {\n        this.updateJson();\n        const recoBase = recognizer.internalData;\n        recoBase.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(PropertyId.PronunciationAssessment_Params));\n    }\n    /**\n     * Gets the reference text.\n     * @member PronunciationAssessmentConfig.prototype.referenceText\n     * @function\n     * @public\n     * @returns {string} Reference text.\n     */\n    get referenceText() {\n        return this.properties.getProperty(PropertyId.PronunciationAssessment_ReferenceText);\n    }\n    /**\n     * Gets/Sets the reference text.\n     * @member PronunciationAssessmentConfig.prototype.referenceText\n     * @function\n     * @public\n     * @param {string} referenceText - Reference text.\n     */\n    set referenceText(referenceText) {\n        Contracts.throwIfNullOrWhitespace(referenceText, \"referenceText\");\n        this.properties.setProperty(PropertyId.PronunciationAssessment_ReferenceText, referenceText);\n    }\n    /**\n     * @member PronunciationAssessmentConfig.prototype.properties\n     * @function\n     * @public\n     * @return {PropertyCollection} Properties of the config.\n     * @summary Gets a pronunciation assessment config properties\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    updateJson() {\n        const jsonString = this.privProperties.getProperty(PropertyId.PronunciationAssessment_Json, \"{}\");\n        const paramsJson = JSON.parse(jsonString);\n        const referenceText = this.privProperties.getProperty(PropertyId.PronunciationAssessment_ReferenceText);\n        if (referenceText) {\n            paramsJson.referenceText = referenceText;\n        }\n        const gradingSystem = this.privProperties.getProperty(PropertyId.PronunciationAssessment_GradingSystem);\n        if (gradingSystem) {\n            paramsJson.gradingSystem = gradingSystem;\n        }\n        const granularity = this.privProperties.getProperty(PropertyId.PronunciationAssessment_Granularity);\n        if (granularity) {\n            paramsJson.granularity = granularity;\n        }\n        // always set dimension to Comprehensive\n        paramsJson.dimension = \"Comprehensive\";\n        const enableMiscueString = this.privProperties.getProperty(PropertyId.PronunciationAssessment_EnableMiscue);\n        if (enableMiscueString === \"true\") {\n            paramsJson.enableMiscue = true;\n        }\n        else if (enableMiscueString === \"false\") {\n            paramsJson.enableMiscue = false;\n        }\n        this.privProperties.setProperty(PropertyId.PronunciationAssessment_Params, JSON.stringify(paramsJson));\n    }\n}\n\n//# sourceMappingURL=PronunciationAssessmentConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines the point system for pronunciation score calibration; default value is FivePoint.\n * Added in version 1.15.0\n * @class PronunciationAssessmentGradingSystem\n */\nexport var PronunciationAssessmentGradingSystem;\n(function (PronunciationAssessmentGradingSystem) {\n    /**\n     * Five point calibration\n     * @member PronunciationAssessmentGradingSystem.FivePoint\n     */\n    PronunciationAssessmentGradingSystem[PronunciationAssessmentGradingSystem[\"FivePoint\"] = 1] = \"FivePoint\";\n    /**\n     * Hundred mark\n     * @member PronunciationAssessmentGradingSystem.HundredMark\n     */\n    PronunciationAssessmentGradingSystem[PronunciationAssessmentGradingSystem[\"HundredMark\"] = 2] = \"HundredMark\";\n})(PronunciationAssessmentGradingSystem || (PronunciationAssessmentGradingSystem = {}));\n\n//# sourceMappingURL=PronunciationAssessmentGradingSystem.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines the pronunciation evaluation granularity; default value is Phoneme.\n * Added in version 1.15.0\n * @class PronunciationAssessmentGranularity\n */\nexport var PronunciationAssessmentGranularity;\n(function (PronunciationAssessmentGranularity) {\n    /**\n     * Shows the score on the full text, word and phoneme level\n     * @member PronunciationAssessmentGranularity.Phoneme\n     */\n    PronunciationAssessmentGranularity[PronunciationAssessmentGranularity[\"Phoneme\"] = 1] = \"Phoneme\";\n    /**\n     * Shows the score on the full text and word level\n     * @member PronunciationAssessmentGranularity.Word\n     */\n    PronunciationAssessmentGranularity[PronunciationAssessmentGranularity[\"Word\"] = 2] = \"Word\";\n    /**\n     * Shows the score on the full text level only\n     * @member PronunciationAssessmentGranularity.FullText\n     */\n    PronunciationAssessmentGranularity[PronunciationAssessmentGranularity[\"FullText\"] = 3] = \"FullText\";\n})(PronunciationAssessmentGranularity || (PronunciationAssessmentGranularity = {}));\n\n//# sourceMappingURL=PronunciationAssessmentGranularity.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\nimport { PropertyId } from \"./Exports\";\n/**\n * Pronunciation assessment results.\n * @class PronunciationAssessmentResult\n * Added in version 1.15.0.\n */\nexport class PronunciationAssessmentResult {\n    constructor(jsonString) {\n        const j = JSON.parse(jsonString);\n        Contracts.throwIfNullOrUndefined(j.NBest[0], \"NBest\");\n        this.privPronJson = j.NBest[0];\n    }\n    /**\n     * @member PronunciationAssessmentResult.fromResult\n     * @function\n     * @public\n     * @param {RecognitionResult} result The recognition result.\n     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig\n     * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.\n     */\n    static fromResult(result) {\n        Contracts.throwIfNullOrUndefined(result, \"result\");\n        const json = result.properties.getProperty(PropertyId.SpeechServiceResponse_JsonResult);\n        Contracts.throwIfNullOrUndefined(json, \"json\");\n        return new PronunciationAssessmentResult(json);\n    }\n    /**\n     * Gets the detail result of pronunciation assessment.\n     * @member PronunciationAssessmentConfig.prototype.detailResult\n     * @function\n     * @public\n     * @returns {any} detail result.\n     */\n    get detailResult() {\n        return this.privPronJson;\n    }\n    /**\n     * The score indicating the pronunciation accuracy of the given speech, which indicates\n     * how closely the phonemes match a native speaker's pronunciation.\n     * @member PronunciationAssessmentResult.prototype.accuracyScore\n     * @function\n     * @public\n     * @returns {number} Accuracy score.\n     */\n    get accuracyScore() {\n        return this.detailResult.PronunciationAssessment.AccuracyScore;\n    }\n    /**\n     * The overall score indicating the pronunciation quality of the given speech.\n     * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.\n     * @member PronunciationAssessmentResult.prototype.pronunciationScore\n     * @function\n     * @public\n     * @returns {number} Pronunciation score.\n     */\n    get pronunciationScore() {\n        return this.detailResult.PronunciationAssessment.PronScore;\n    }\n    /**\n     * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.\n     * @member PronunciationAssessmentResult.prototype.completenessScore\n     * @function\n     * @public\n     * @returns {number} Completeness score.\n     */\n    get completenessScore() {\n        return this.detailResult.PronunciationAssessment.CompletenessScore;\n    }\n    /**\n     * The score indicating the fluency of the given speech.\n     * @member PronunciationAssessmentResult.prototype.fluencyScore\n     * @function\n     * @public\n     * @returns {number} Fluency score.\n     */\n    get fluencyScore() {\n        return this.detailResult.PronunciationAssessment.FluencyScore;\n    }\n}\n\n//# sourceMappingURL=PronunciationAssessmentResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { PropertyId } from \"./Exports\";\n/**\n * Represents collection of properties and their values.\n * @class PropertyCollection\n */\nexport class PropertyCollection {\n    constructor() {\n        this.privKeys = [];\n        this.privValues = [];\n    }\n    /**\n     * Returns the property value in type String. The parameter must have the same type as String.\n     * Currently only String, int and bool are allowed.\n     * If the name is not available, the specified defaultValue is returned.\n     * @member PropertyCollection.prototype.getProperty\n     * @function\n     * @public\n     * @param {string} key - The parameter name.\n     * @param {string} def - The default value which is returned if the parameter\n     *        is not available in the collection.\n     * @returns {string} value of the parameter.\n     */\n    getProperty(key, def) {\n        let keyToUse;\n        if (typeof key === \"string\") {\n            keyToUse = key;\n        }\n        else {\n            keyToUse = PropertyId[key];\n        }\n        for (let n = 0; n < this.privKeys.length; n++) {\n            if (this.privKeys[n] === keyToUse) {\n                return this.privValues[n];\n            }\n        }\n        return def;\n    }\n    /**\n     * Sets the String value of the parameter specified by name.\n     * @member PropertyCollection.prototype.setProperty\n     * @function\n     * @public\n     * @param {string} key - The parameter name.\n     * @param {string} value - The value of the parameter.\n     */\n    setProperty(key, value) {\n        let keyToUse;\n        if (typeof key === \"string\") {\n            keyToUse = key;\n        }\n        else {\n            keyToUse = PropertyId[key];\n        }\n        for (let n = 0; n < this.privKeys.length; n++) {\n            if (this.privKeys[n] === keyToUse) {\n                this.privValues[n] = value;\n                return;\n            }\n        }\n        this.privKeys.push(keyToUse);\n        this.privValues.push(value);\n    }\n    /**\n     * Clones the collection.\n     * @member PropertyCollection.prototype.clone\n     * @function\n     * @public\n     * @returns {PropertyCollection} A copy of the collection.\n     */\n    clone() {\n        const clonedMap = new PropertyCollection();\n        for (let n = 0; n < this.privKeys.length; n++) {\n            clonedMap.privKeys.push(this.privKeys[n]);\n            clonedMap.privValues.push(this.privValues[n]);\n        }\n        return clonedMap;\n    }\n    /**\n     * Merges this set of properties into another, no overwrites.\n     * @member PropertyCollection.prototype.mergeTo\n     * @function\n     * @public\n     * @param {PropertyCollection} The collection to merge into.\n     */\n    mergeTo(destinationCollection) {\n        this.privKeys.forEach((key) => {\n            if (destinationCollection.getProperty(key, undefined) === undefined) {\n                const value = this.getProperty(key);\n                destinationCollection.setProperty(key, value);\n            }\n        });\n    }\n    /**\n     * Get the keys in Property Collection.\n     * @member PropertyCollection.prototype.keys\n     * @function\n     * @public\n     * @returns {string []} Keys in the collection.\n     */\n    get keys() {\n        return this.privKeys;\n    }\n}\n\n//# sourceMappingURL=PropertyCollection.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines speech property ids.\n * @class PropertyId\n */\nexport var PropertyId;\n(function (PropertyId) {\n    /**\n     * The Cognitive Services Speech Service subscription Key. If you are using an intent recognizer, you need to specify\n     * to specify the LUIS endpoint key for your particular LUIS app. Under normal circumstances, you shouldn't\n     * have to use this property directly.\n     * Instead, use [[SpeechConfig.fromSubscription]].\n     * @member PropertyId.SpeechServiceConnection_Key\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_Key\"] = 0] = \"SpeechServiceConnection_Key\";\n    /**\n     * The Cognitive Services Speech Service endpoint (url). Under normal circumstances, you shouldn't\n     * have to use this property directly.\n     * Instead, use [[SpeechConfig.fromEndpoint]].\n     * NOTE: This endpoint is not the same as the endpoint used to obtain an access token.\n     * @member PropertyId.SpeechServiceConnection_Endpoint\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_Endpoint\"] = 1] = \"SpeechServiceConnection_Endpoint\";\n    /**\n     * The Cognitive Services Speech Service region. Under normal circumstances, you shouldn't have to\n     * use this property directly.\n     * Instead, use [[SpeechConfig.fromSubscription]], [[SpeechConfig.fromEndpoint]], [[SpeechConfig.fromAuthorizationToken]].\n     * @member PropertyId.SpeechServiceConnection_Region\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_Region\"] = 2] = \"SpeechServiceConnection_Region\";\n    /**\n     * The Cognitive Services Speech Service authorization token (aka access token). Under normal circumstances,\n     * you shouldn't have to use this property directly.\n     * Instead, use [[SpeechConfig.fromAuthorizationToken]], [[SpeechRecognizer.authorizationToken]],\n     * [[IntentRecognizer.authorizationToken]], [[TranslationRecognizer.authorizationToken]], [[SpeakerRecognizer.authorizationToken]].\n     * @member PropertyId.SpeechServiceAuthorization_Token\n     */\n    PropertyId[PropertyId[\"SpeechServiceAuthorization_Token\"] = 3] = \"SpeechServiceAuthorization_Token\";\n    /**\n     * The Cognitive Services Speech Service authorization type. Currently unused.\n     * @member PropertyId.SpeechServiceAuthorization_Type\n     */\n    PropertyId[PropertyId[\"SpeechServiceAuthorization_Type\"] = 4] = \"SpeechServiceAuthorization_Type\";\n    /**\n     * The Cognitive Services Speech Service endpoint id. Under normal circumstances, you shouldn't\n     * have to use this property directly.\n     * Instead, use [[SpeechConfig.endpointId]].\n     * NOTE: The endpoint id is available in the Speech Portal, listed under Endpoint Details.\n     * @member PropertyId.SpeechServiceConnection_EndpointId\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_EndpointId\"] = 5] = \"SpeechServiceConnection_EndpointId\";\n    /**\n     * The list of comma separated languages (BCP-47 format) used as target translation languages. Under normal circumstances,\n     * you shouldn't have to use this property directly.\n     * Instead use [[SpeechTranslationConfig.addTargetLanguage]],\n     * [[SpeechTranslationConfig.targetLanguages]], [[TranslationRecognizer.targetLanguages]].\n     * @member PropertyId.SpeechServiceConnection_TranslationToLanguages\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_TranslationToLanguages\"] = 6] = \"SpeechServiceConnection_TranslationToLanguages\";\n    /**\n     * The name of the Cognitive Service Text to Speech Service Voice. Under normal circumstances, you shouldn't have to use this\n     * property directly.\n     * Instead, use [[SpeechTranslationConfig.voiceName]].\n     * NOTE: Valid voice names can be found <a href=\"https://aka.ms/csspeech/voicenames\">here</a>.\n     * @member PropertyId.SpeechServiceConnection_TranslationVoice\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_TranslationVoice\"] = 7] = \"SpeechServiceConnection_TranslationVoice\";\n    /**\n     * Translation features.\n     * @member PropertyId.SpeechServiceConnection_TranslationFeatures\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_TranslationFeatures\"] = 8] = \"SpeechServiceConnection_TranslationFeatures\";\n    /**\n     * The Language Understanding Service Region. Under normal circumstances, you shouldn't have to use this property directly.\n     * Instead, use [[LanguageUnderstandingModel]].\n     * @member PropertyId.SpeechServiceConnection_IntentRegion\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_IntentRegion\"] = 9] = \"SpeechServiceConnection_IntentRegion\";\n    /**\n     * The host name of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.\n     * You shouldn't have to use this property directly.\n     * Instead use <see cref=\"SpeechConfig.SetProxy(string,int,string,string)\"/>.\n     * Added in version 1.4.0.\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_ProxyHostName\"] = 10] = \"SpeechServiceConnection_ProxyHostName\";\n    /**\n     * The port of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.\n     * You shouldn't have to use this property directly.\n     * Instead use <see cref=\"SpeechConfig.SetProxy(string,int,string,string)\"/>.\n     * Added in version 1.4.0.\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_ProxyPort\"] = 11] = \"SpeechServiceConnection_ProxyPort\";\n    /**\n     * The user name of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.\n     * You shouldn't have to use this property directly.\n     * Instead use <see cref=\"SpeechConfig.SetProxy(string,int,string,string)\"/>.\n     * Added in version 1.4.0.\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_ProxyUserName\"] = 12] = \"SpeechServiceConnection_ProxyUserName\";\n    /**\n     * The password of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.\n     * You shouldn't have to use this property directly.\n     * Instead use <see cref=\"SpeechConfig.SetProxy(string,int,string,string)\"/>.\n     * Added in version 1.4.0.\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_ProxyPassword\"] = 13] = \"SpeechServiceConnection_ProxyPassword\";\n    /**\n     * The Cognitive Services Speech Service recognition Mode. Can be \"INTERACTIVE\", \"CONVERSATION\", \"DICTATION\".\n     * This property is intended to be read-only. The SDK is using it internally.\n     * @member PropertyId.SpeechServiceConnection_RecoMode\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_RecoMode\"] = 14] = \"SpeechServiceConnection_RecoMode\";\n    /**\n     * The spoken language to be recognized (in BCP-47 format). Under normal circumstances, you shouldn't have to use this property\n     * directly.\n     * Instead, use [[SpeechConfig.speechRecognitionLanguage]].\n     * @member PropertyId.SpeechServiceConnection_RecoLanguage\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_RecoLanguage\"] = 15] = \"SpeechServiceConnection_RecoLanguage\";\n    /**\n     * The session id. This id is a universally unique identifier (aka UUID) representing a specific binding of an audio input stream\n     * and the underlying speech recognition instance to which it is bound. Under normal circumstances, you shouldn't have to use this\n     * property directly.\n     * Instead use [[SessionEventArgs.sessionId]].\n     * @member PropertyId.Speech_SessionId\n     */\n    PropertyId[PropertyId[\"Speech_SessionId\"] = 16] = \"Speech_SessionId\";\n    /**\n     * The spoken language to be synthesized (e.g. en-US)\n     * @member PropertyId.SpeechServiceConnection_SynthLanguage\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_SynthLanguage\"] = 17] = \"SpeechServiceConnection_SynthLanguage\";\n    /**\n     * The name of the TTS voice to be used for speech synthesis\n     * @member PropertyId.SpeechServiceConnection_SynthVoice\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_SynthVoice\"] = 18] = \"SpeechServiceConnection_SynthVoice\";\n    /**\n     * The string to specify TTS output audio format\n     * @member PropertyId.SpeechServiceConnection_SynthOutputFormat\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_SynthOutputFormat\"] = 19] = \"SpeechServiceConnection_SynthOutputFormat\";\n    /**\n     * The list of comma separated languages used as possible source languages\n     * Added in version 1.13.0\n     * @member PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_AutoDetectSourceLanguages\"] = 20] = \"SpeechServiceConnection_AutoDetectSourceLanguages\";\n    /**\n     * The requested Cognitive Services Speech Service response output format (simple or detailed). Under normal circumstances, you shouldn't have\n     * to use this property directly.\n     * Instead use [[SpeechConfig.outputFormat]].\n     * @member PropertyId.SpeechServiceResponse_RequestDetailedResultTrueFalse\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_RequestDetailedResultTrueFalse\"] = 21] = \"SpeechServiceResponse_RequestDetailedResultTrueFalse\";\n    /**\n     * The requested Cognitive Services Speech Service response output profanity level. Currently unused.\n     * @member PropertyId.SpeechServiceResponse_RequestProfanityFilterTrueFalse\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_RequestProfanityFilterTrueFalse\"] = 22] = \"SpeechServiceResponse_RequestProfanityFilterTrueFalse\";\n    /**\n     * The Cognitive Services Speech Service response output (in JSON format). This property is available on recognition result objects only.\n     * @member PropertyId.SpeechServiceResponse_JsonResult\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_JsonResult\"] = 23] = \"SpeechServiceResponse_JsonResult\";\n    /**\n     * The Cognitive Services Speech Service error details (in JSON format). Under normal circumstances, you shouldn't have to\n     * use this property directly. Instead use [[CancellationDetails.errorDetails]].\n     * @member PropertyId.SpeechServiceResponse_JsonErrorDetails\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_JsonErrorDetails\"] = 24] = \"SpeechServiceResponse_JsonErrorDetails\";\n    /**\n     * The cancellation reason. Currently unused.\n     * @member PropertyId.CancellationDetails_Reason\n     */\n    PropertyId[PropertyId[\"CancellationDetails_Reason\"] = 25] = \"CancellationDetails_Reason\";\n    /**\n     * The cancellation text. Currently unused.\n     * @member PropertyId.CancellationDetails_ReasonText\n     */\n    PropertyId[PropertyId[\"CancellationDetails_ReasonText\"] = 26] = \"CancellationDetails_ReasonText\";\n    /**\n     * The Cancellation detailed text. Currently unused.\n     * @member PropertyId.CancellationDetails_ReasonDetailedText\n     */\n    PropertyId[PropertyId[\"CancellationDetails_ReasonDetailedText\"] = 27] = \"CancellationDetails_ReasonDetailedText\";\n    /**\n     * The Language Understanding Service response output (in JSON format). Available via [[IntentRecognitionResult]]\n     * @member PropertyId.LanguageUnderstandingServiceResponse_JsonResult\n     */\n    PropertyId[PropertyId[\"LanguageUnderstandingServiceResponse_JsonResult\"] = 28] = \"LanguageUnderstandingServiceResponse_JsonResult\";\n    /**\n     * The URL string built from speech configuration.\n     * This property is intended to be read-only. The SDK is using it internally.\n     * NOTE: Added in version 1.7.0.\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_Url\"] = 29] = \"SpeechServiceConnection_Url\";\n    /**\n     * The initial silence timeout value (in milliseconds) used by the service.\n     * Added in version 1.7.0\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_InitialSilenceTimeoutMs\"] = 30] = \"SpeechServiceConnection_InitialSilenceTimeoutMs\";\n    /**\n     * The end silence timeout value (in milliseconds) used by the service.\n     * Added in version 1.7.0\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_EndSilenceTimeoutMs\"] = 31] = \"SpeechServiceConnection_EndSilenceTimeoutMs\";\n    /**\n     * A boolean value specifying whether audio logging is enabled in the service or not.\n     * Added in version 1.7.0\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_EnableAudioLogging\"] = 32] = \"SpeechServiceConnection_EnableAudioLogging\";\n    /**\n     * The requested Cognitive Services Speech Service response output profanity setting.\n     * Allowed values are \"masked\", \"removed\", and \"raw\".\n     * Added in version 1.7.0.\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_ProfanityOption\"] = 33] = \"SpeechServiceResponse_ProfanityOption\";\n    /**\n     * A string value specifying which post processing option should be used by service.\n     * Allowed values are \"TrueText\".\n     * Added in version 1.7.0\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_PostProcessingOption\"] = 34] = \"SpeechServiceResponse_PostProcessingOption\";\n    /**\n     *  A boolean value specifying whether to include word-level timestamps in the response result.\n     * Added in version 1.7.0\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_RequestWordLevelTimestamps\"] = 35] = \"SpeechServiceResponse_RequestWordLevelTimestamps\";\n    /**\n     * The number of times a word has to be in partial results to be returned.\n     * Added in version 1.7.0\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_StablePartialResultThreshold\"] = 36] = \"SpeechServiceResponse_StablePartialResultThreshold\";\n    /**\n     * A string value specifying the output format option in the response result. Internal use only.\n     * Added in version 1.7.0.\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_OutputFormatOption\"] = 37] = \"SpeechServiceResponse_OutputFormatOption\";\n    /**\n     * A boolean value to request for stabilizing translation partial results by omitting words in the end.\n     * Added in version 1.7.0.\n     */\n    PropertyId[PropertyId[\"SpeechServiceResponse_TranslationRequestStablePartialResult\"] = 38] = \"SpeechServiceResponse_TranslationRequestStablePartialResult\";\n    /**\n     * Identifier used to connect to the backend service.\n     * @member PropertyId.Conversation_ApplicationId\n     */\n    PropertyId[PropertyId[\"Conversation_ApplicationId\"] = 39] = \"Conversation_ApplicationId\";\n    /**\n     * Type of dialog backend to connect to.\n     * @member PropertyId.Conversation_DialogType\n     */\n    PropertyId[PropertyId[\"Conversation_DialogType\"] = 40] = \"Conversation_DialogType\";\n    /**\n     * Silence timeout for listening\n     * @member PropertyId.Conversation_Initial_Silence_Timeout\n     */\n    PropertyId[PropertyId[\"Conversation_Initial_Silence_Timeout\"] = 41] = \"Conversation_Initial_Silence_Timeout\";\n    /**\n     * From Id to add to speech recognition activities.\n     * @member PropertyId.Conversation_From_Id\n     */\n    PropertyId[PropertyId[\"Conversation_From_Id\"] = 42] = \"Conversation_From_Id\";\n    /**\n     * ConversationId for the session.\n     * @member PropertyId.Conversation_Conversation_Id\n     */\n    PropertyId[PropertyId[\"Conversation_Conversation_Id\"] = 43] = \"Conversation_Conversation_Id\";\n    /**\n     * Comma separated list of custom voice deployment ids.\n     * @member PropertyId.Conversation_Custom_Voice_Deployment_Ids\n     */\n    PropertyId[PropertyId[\"Conversation_Custom_Voice_Deployment_Ids\"] = 44] = \"Conversation_Custom_Voice_Deployment_Ids\";\n    /**\n     * Speech activity template, stamp properties from the template on the activity generated by the service for speech.\n     * @member PropertyId.Conversation_Speech_Activity_Template\n     * Added in version 1.10.0.\n     */\n    PropertyId[PropertyId[\"Conversation_Speech_Activity_Template\"] = 45] = \"Conversation_Speech_Activity_Template\";\n    /**\n     * Enables or disables the receipt of turn status messages as obtained on the turnStatusReceived event.\n     * @member PropertyId.Conversation_Request_Bot_Status_Messages\n     * Added in version 1.15.0.\n     */\n    PropertyId[PropertyId[\"Conversation_Request_Bot_Status_Messages\"] = 46] = \"Conversation_Request_Bot_Status_Messages\";\n    /**\n     * Specifies the connection ID to be provided in the Agent configuration message, e.g. a Direct Line token for\n     * channel authentication.\n     * Added in version 1.15.1.\n     */\n    PropertyId[PropertyId[\"Conversation_Agent_Connection_Id\"] = 47] = \"Conversation_Agent_Connection_Id\";\n    /**\n     * The Cognitive Services Speech Service host (url). Under normal circumstances, you shouldn't have to use this property directly.\n     * Instead, use [[SpeechConfig.fromHost]].\n     */\n    PropertyId[PropertyId[\"SpeechServiceConnection_Host\"] = 48] = \"SpeechServiceConnection_Host\";\n    /**\n     * Set the host for service calls to the Conversation Translator REST management and websocket calls.\n     */\n    PropertyId[PropertyId[\"ConversationTranslator_Host\"] = 49] = \"ConversationTranslator_Host\";\n    /**\n     * Optionally set the the host's display name.\n     * Used when joining a conversation.\n     */\n    PropertyId[PropertyId[\"ConversationTranslator_Name\"] = 50] = \"ConversationTranslator_Name\";\n    /**\n     * Optionally set a value for the X-CorrelationId request header.\n     * Used for troubleshooting errors in the server logs. It should be a valid guid.\n     */\n    PropertyId[PropertyId[\"ConversationTranslator_CorrelationId\"] = 51] = \"ConversationTranslator_CorrelationId\";\n    /**\n     * Set the conversation token to be sent to the speech service. This enables the\n     * service to service call from the speech service to the Conversation Translator service for relaying\n     * recognitions. For internal use.\n     */\n    PropertyId[PropertyId[\"ConversationTranslator_Token\"] = 52] = \"ConversationTranslator_Token\";\n    /**\n     * The reference text of the audio for pronunciation evaluation.\n     * For this and the following pronunciation assessment parameters, see\n     * https://docs.microsoft.com/azure/cognitive-services/speech-service/rest-speech-to-text#pronunciation-assessment-parameters for details.\n     * Under normal circumstances, you shouldn't have to use this property directly.\n     * Added in version 1.15.0\n     */\n    PropertyId[PropertyId[\"PronunciationAssessment_ReferenceText\"] = 53] = \"PronunciationAssessment_ReferenceText\";\n    /**\n     * The point system for pronunciation score calibration (FivePoint or HundredMark).\n     * Under normal circumstances, you shouldn't have to use this property directly.\n     * Added in version 1.15.0\n     */\n    PropertyId[PropertyId[\"PronunciationAssessment_GradingSystem\"] = 54] = \"PronunciationAssessment_GradingSystem\";\n    /**\n     * The pronunciation evaluation granularity (Phoneme, Word, or FullText).\n     * Under normal circumstances, you shouldn't have to use this property directly.\n     * Added in version 1.15.0\n     */\n    PropertyId[PropertyId[\"PronunciationAssessment_Granularity\"] = 55] = \"PronunciationAssessment_Granularity\";\n    /**\n     * Defines if enable miscue calculation.\n     * With this enabled, the pronounced words will be compared to the reference text,\n     * and will be marked with omission/insertion based on the comparison. The default setting is False.\n     * Under normal circumstances, you shouldn't have to use this property directly.\n     * Added in version 1.15.0\n     */\n    PropertyId[PropertyId[\"PronunciationAssessment_EnableMiscue\"] = 56] = \"PronunciationAssessment_EnableMiscue\";\n    /**\n     * The json string of pronunciation assessment parameters\n     * Under normal circumstances, you shouldn't have to use this property directly.\n     * Added in version 1.15.0\n     */\n    PropertyId[PropertyId[\"PronunciationAssessment_Json\"] = 57] = \"PronunciationAssessment_Json\";\n    /**\n     * Pronunciation assessment parameters.\n     * This property is intended to be read-only. The SDK is using it internally.\n     * Added in version 1.15.0\n     */\n    PropertyId[PropertyId[\"PronunciationAssessment_Params\"] = 58] = \"PronunciationAssessment_Params\";\n    /**\n     * Version of Speaker Recognition API to use.\n     * Added in version 1.18.0\n     */\n    PropertyId[PropertyId[\"SpeakerRecognition_Api_Version\"] = 59] = \"SpeakerRecognition_Api_Version\";\n})(PropertyId || (PropertyId = {}));\n\n//# sourceMappingURL=PropertyId.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { SessionEventArgs } from \"./Exports\";\n/**\n * Defines payload for session events like Speech Start/End Detected\n * @class\n */\nexport class RecognitionEventArgs extends SessionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {number} offset - The offset.\n     * @param {string} sessionId - The session id.\n     */\n    constructor(offset, sessionId) {\n        super(sessionId);\n        this.privOffset = offset;\n    }\n    /**\n     * Represents the message offset\n     * @member RecognitionEventArgs.prototype.offset\n     * @function\n     * @public\n     */\n    get offset() {\n        return this.privOffset;\n    }\n}\n\n//# sourceMappingURL=RecognitionEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines result of speech recognition.\n * @class RecognitionResult\n */\nexport class RecognitionResult {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {string} resultId - The result id.\n     * @param {ResultReason} reason - The reason.\n     * @param {string} text - The recognized text.\n     * @param {number} duration - The duration.\n     * @param {number} offset - The offset into the stream.\n     * @param {string} language - Primary Language detected, if provided.\n     * @param {string} languageDetectionConfidence - Primary Language confidence (\"Unknown,\" \"Low,\" \"Medium,\" \"High\"...), if provided.\n     * @param {string} errorDetails - Error details, if provided.\n     * @param {string} json - Additional Json, if provided.\n     * @param {PropertyCollection} properties - Additional properties, if provided.\n     */\n    constructor(resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {\n        this.privResultId = resultId;\n        this.privReason = reason;\n        this.privText = text;\n        this.privDuration = duration;\n        this.privOffset = offset;\n        this.privLanguage = language;\n        this.privLanguageDetectionConfidence = languageDetectionConfidence;\n        this.privErrorDetails = errorDetails;\n        this.privJson = json;\n        this.privProperties = properties;\n    }\n    /**\n     * Specifies the result identifier.\n     * @member RecognitionResult.prototype.resultId\n     * @function\n     * @public\n     * @returns {string} Specifies the result identifier.\n     */\n    get resultId() {\n        return this.privResultId;\n    }\n    /**\n     * Specifies status of the result.\n     * @member RecognitionResult.prototype.reason\n     * @function\n     * @public\n     * @returns {ResultReason} Specifies status of the result.\n     */\n    get reason() {\n        return this.privReason;\n    }\n    /**\n     * Presents the recognized text in the result.\n     * @member RecognitionResult.prototype.text\n     * @function\n     * @public\n     * @returns {string} Presents the recognized text in the result.\n     */\n    get text() {\n        return this.privText;\n    }\n    /**\n     * Duration of recognized speech in 100 nano second incements.\n     * @member RecognitionResult.prototype.duration\n     * @function\n     * @public\n     * @returns {number} Duration of recognized speech in 100 nano second incements.\n     */\n    get duration() {\n        return this.privDuration;\n    }\n    /**\n     * Offset of recognized speech in 100 nano second incements.\n     * @member RecognitionResult.prototype.offset\n     * @function\n     * @public\n     * @returns {number} Offset of recognized speech in 100 nano second incements.\n     */\n    get offset() {\n        return this.privOffset;\n    }\n    /**\n     * Primary Language detected.\n     * @member RecognitionResult.prototype.language\n     * @function\n     * @public\n     * @returns {string} language detected.\n     */\n    get language() {\n        return this.privLanguage;\n    }\n    /**\n     * Primary Language detection confidence (Unknown, Low, Medium, High).\n     * @member RecognitionResult.prototype.languageDetectionConfidence\n     * @function\n     * @public\n     * @returns {string} detection confidence strength.\n     */\n    get languageDetectionConfidence() {\n        return this.privLanguageDetectionConfidence;\n    }\n    /**\n     * In case of an unsuccessful recognition, provides details of the occurred error.\n     * @member RecognitionResult.prototype.errorDetails\n     * @function\n     * @public\n     * @returns {string} a brief description of an error.\n     */\n    get errorDetails() {\n        return this.privErrorDetails;\n    }\n    /**\n     * A string containing Json serialized recognition result as it was received from the service.\n     * @member RecognitionResult.prototype.json\n     * @function\n     * @private\n     * @returns {string} Json serialized representation of the result.\n     */\n    get json() {\n        return this.privJson;\n    }\n    /**\n     *  The set of properties exposed in the result.\n     * @member RecognitionResult.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The set of properties exposed in the result.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n}\n\n//# sourceMappingURL=RecognitionResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CognitiveSubscriptionKeyAuthentication, CognitiveTokenAuthentication, Context, OS, ServiceRecognizerBase, SpeechServiceConfig, } from \"../common.speech/Exports\";\nimport { Deferred, marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { AudioConfig, PropertyId, } from \"./Exports\";\n/**\n * Defines the base class Recognizer which mainly contains common event handlers.\n * @class Recognizer\n */\nexport class Recognizer {\n    /**\n     * Creates and initializes an instance of a Recognizer\n     * @constructor\n     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer\n     */\n    constructor(audioConfig, properties, connectionFactory) {\n        this.audioConfig = (audioConfig !== undefined) ? audioConfig : AudioConfig.fromDefaultMicrophoneInput();\n        this.privDisposed = false;\n        this.privProperties = properties.clone();\n        this.privConnectionFactory = connectionFactory;\n        this.implCommonRecognizerSetup();\n    }\n    /**\n     * Dispose of associated resources.\n     * @member Recognizer.prototype.close\n     * @function\n     * @public\n     */\n    close(cb, errorCb) {\n        Contracts.throwIfDisposed(this.privDisposed);\n        marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n    }\n    /**\n     * @Internal\n     * Internal data member to support fromRecognizer* pattern methods on other classes.\n     * Do not use externally, object returned will change without warning or notice.\n     */\n    get internalData() {\n        return this.privReco;\n    }\n    /**\n     * This method performs cleanup of resources.\n     * The Boolean parameter disposing indicates whether the method is called\n     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).\n     * Derived classes should override this method to dispose resource if needed.\n     * @member Recognizer.prototype.dispose\n     * @function\n     * @public\n     * @param {boolean} disposing - Flag to request disposal.\n     */\n    dispose(disposing) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privDisposed) {\n                return;\n            }\n            this.privDisposed = true;\n            if (disposing) {\n                if (this.privReco) {\n                    yield this.privReco.audioSource.turnOff();\n                    yield this.privReco.dispose();\n                }\n            }\n        });\n    }\n    /**\n     * This method returns the current state of the telemetry setting.\n     * @member Recognizer.prototype.telemetryEnabled\n     * @function\n     * @public\n     * @returns true if the telemetry is enabled, false otherwise.\n     */\n    static get telemetryEnabled() {\n        return ServiceRecognizerBase.telemetryDataEnabled;\n    }\n    /**\n     * This method globally enables or disables telemetry.\n     * @member Recognizer.prototype.enableTelemetry\n     * @function\n     * @public\n     * @param enabled - Global setting for telemetry collection.\n     * If set to true, telemetry information like microphone errors,\n     * recognition errors are collected and sent to Microsoft.\n     * If set to false, no telemetry is sent to Microsoft.\n     */\n    /* tslint:disable:member-ordering */\n    static enableTelemetry(enabled) {\n        ServiceRecognizerBase.telemetryDataEnabled = enabled;\n    }\n    // Does the generic recognizer setup that is common across all recognizer types.\n    implCommonRecognizerSetup() {\n        let osPlatform = (typeof window !== \"undefined\") ? \"Browser\" : \"Node\";\n        let osName = \"unknown\";\n        let osVersion = \"unknown\";\n        if (typeof navigator !== \"undefined\") {\n            osPlatform = osPlatform + \"/\" + navigator.platform;\n            osName = navigator.userAgent;\n            osVersion = navigator.appVersion;\n        }\n        const recognizerConfig = this.createRecognizerConfig(new SpeechServiceConfig(new Context(new OS(osPlatform, osName, osVersion))));\n        this.privReco = this.createServiceRecognizer(Recognizer.getAuthFromProperties(this.privProperties), this.privConnectionFactory, this.audioConfig, recognizerConfig);\n    }\n    recognizeOnceAsyncImpl(recognitionMode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            Contracts.throwIfDisposed(this.privDisposed);\n            const ret = new Deferred();\n            yield this.implRecognizerStop();\n            yield this.privReco.recognize(recognitionMode, ret.resolve, ret.reject);\n            const result = yield ret.promise;\n            yield this.implRecognizerStop();\n            return result;\n        });\n    }\n    startContinuousRecognitionAsyncImpl(recognitionMode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            Contracts.throwIfDisposed(this.privDisposed);\n            yield this.implRecognizerStop();\n            yield this.privReco.recognize(recognitionMode, undefined, undefined);\n        });\n    }\n    stopContinuousRecognitionAsyncImpl() {\n        return __awaiter(this, void 0, void 0, function* () {\n            Contracts.throwIfDisposed(this.privDisposed);\n            yield this.implRecognizerStop();\n        });\n    }\n    implRecognizerStop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privReco) {\n                yield this.privReco.stopRecognizing();\n            }\n            return;\n        });\n    }\n    static getAuthFromProperties(properties) {\n        const subscriptionKey = properties.getProperty(PropertyId.SpeechServiceConnection_Key, undefined);\n        const authentication = (subscriptionKey && subscriptionKey !== \"\") ?\n            new CognitiveSubscriptionKeyAuthentication(subscriptionKey) :\n            new CognitiveTokenAuthentication((authFetchEventId) => {\n                const authorizationToken = properties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\n                return Promise.resolve(authorizationToken);\n            }, (authFetchEventId) => {\n                const authorizationToken = properties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\n                return Promise.resolve(authorizationToken);\n            });\n        return authentication;\n    }\n}\n\n//# sourceMappingURL=Recognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines the possible reasons a recognition result might be generated.\n * @class ResultReason\n */\nexport var ResultReason;\n(function (ResultReason) {\n    /**\n     * Indicates speech could not be recognized. More details\n     * can be found in the NoMatchDetails object.\n     * @member ResultReason.NoMatch\n     */\n    ResultReason[ResultReason[\"NoMatch\"] = 0] = \"NoMatch\";\n    /**\n     * Indicates that the recognition was canceled. More details\n     * can be found using the CancellationDetails object.\n     * @member ResultReason.Canceled\n     */\n    ResultReason[ResultReason[\"Canceled\"] = 1] = \"Canceled\";\n    /**\n     * Indicates the speech result contains hypothesis text.\n     * @member ResultReason.RecognizedSpeech\n     */\n    ResultReason[ResultReason[\"RecognizingSpeech\"] = 2] = \"RecognizingSpeech\";\n    /**\n     * Indicates the speech result contains final text that has been recognized.\n     * Speech Recognition is now complete for this phrase.\n     * @member ResultReason.RecognizedSpeech\n     */\n    ResultReason[ResultReason[\"RecognizedSpeech\"] = 3] = \"RecognizedSpeech\";\n    /**\n     * Indicates the speech result contains a finalized acceptance of a provided keyword.\n     * Speech recognition will continue unless otherwise configured.\n     * @member ResultReason.RecognizedKeyword\n     */\n    ResultReason[ResultReason[\"RecognizedKeyword\"] = 4] = \"RecognizedKeyword\";\n    /**\n     * Indicates the intent result contains hypothesis text and intent.\n     * @member ResultReason.RecognizingIntent\n     */\n    ResultReason[ResultReason[\"RecognizingIntent\"] = 5] = \"RecognizingIntent\";\n    /**\n     * Indicates the intent result contains final text and intent.\n     * Speech Recognition and Intent determination are now complete for this phrase.\n     * @member ResultReason.RecognizedIntent\n     */\n    ResultReason[ResultReason[\"RecognizedIntent\"] = 6] = \"RecognizedIntent\";\n    /**\n     * Indicates the translation result contains hypothesis text and its translation(s).\n     * @member ResultReason.TranslatingSpeech\n     */\n    ResultReason[ResultReason[\"TranslatingSpeech\"] = 7] = \"TranslatingSpeech\";\n    /**\n     * Indicates the translation result contains final text and corresponding translation(s).\n     * Speech Recognition and Translation are now complete for this phrase.\n     * @member ResultReason.TranslatedSpeech\n     */\n    ResultReason[ResultReason[\"TranslatedSpeech\"] = 8] = \"TranslatedSpeech\";\n    /**\n     * Indicates the synthesized audio result contains a non-zero amount of audio data\n     * @member ResultReason.SynthesizingAudio\n     */\n    ResultReason[ResultReason[\"SynthesizingAudio\"] = 9] = \"SynthesizingAudio\";\n    /**\n     * Indicates the synthesized audio is now complete for this phrase.\n     * @member ResultReason.SynthesizingAudioCompleted\n     */\n    ResultReason[ResultReason[\"SynthesizingAudioCompleted\"] = 10] = \"SynthesizingAudioCompleted\";\n    /**\n     * Indicates the speech synthesis is now started\n     * @member ResultReason.SynthesizingAudioStarted\n     */\n    ResultReason[ResultReason[\"SynthesizingAudioStarted\"] = 11] = \"SynthesizingAudioStarted\";\n    /**\n     * Indicates the voice profile is being enrolled and customers need to send more audio to create a voice profile.\n     * @member ResultReason.EnrollingVoiceProfile\n     */\n    ResultReason[ResultReason[\"EnrollingVoiceProfile\"] = 12] = \"EnrollingVoiceProfile\";\n    /**\n     * Indicates the voice profile has been enrolled.\n     * @member ResultReason.EnrolledVoiceProfile\n     */\n    ResultReason[ResultReason[\"EnrolledVoiceProfile\"] = 13] = \"EnrolledVoiceProfile\";\n    /**\n     * Indicates successful identification of some speakers.\n     * @member ResultReason.RecognizedSpeakers\n     */\n    ResultReason[ResultReason[\"RecognizedSpeakers\"] = 14] = \"RecognizedSpeakers\";\n    /**\n     * Indicates successfully verified one speaker.\n     * @member ResultReason.RecognizedSpeaker\n     */\n    ResultReason[ResultReason[\"RecognizedSpeaker\"] = 15] = \"RecognizedSpeaker\";\n    /**\n     * Indicates a voice profile has been reset successfully.\n     * @member ResultReason.ResetVoiceProfile\n     */\n    ResultReason[ResultReason[\"ResetVoiceProfile\"] = 16] = \"ResetVoiceProfile\";\n    /**\n     * Indicates a voice profile has been deleted successfully.\n     * @member ResultReason.DeletedVoiceProfile\n     */\n    ResultReason[ResultReason[\"DeletedVoiceProfile\"] = 17] = \"DeletedVoiceProfile\";\n})(ResultReason || (ResultReason = {}));\n\n//# sourceMappingURL=ResultReason.js.map\n","//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nimport { SessionEventArgs } from \"./Exports\";\n/**\n * Defines payload for any Service message event\n * Added in version 1.9.0\n */\nexport class ServiceEventArgs extends SessionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {string} json - json payload of the USP message.\n     */\n    constructor(json, name, sessionId) {\n        super(sessionId);\n        this.privJsonResult = json;\n        this.privEventName = name;\n    }\n    get jsonString() {\n        return this.privJsonResult;\n    }\n    get eventName() {\n        return this.privEventName;\n    }\n}\n\n//# sourceMappingURL=ServiceEventArgs.js.map\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * Defines channels used to pass property settings to service.\n * Added in version 1.7.0.\n */\nexport var ServicePropertyChannel;\n(function (ServicePropertyChannel) {\n    /**\n     * Uses URI query parameter to pass property settings to service.\n     */\n    ServicePropertyChannel[ServicePropertyChannel[\"UriQueryParameter\"] = 0] = \"UriQueryParameter\";\n})(ServicePropertyChannel || (ServicePropertyChannel = {}));\n\n//# sourceMappingURL=ServicePropertyChannel.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines content for session events like SessionStarted/Stopped, SoundStarted/Stopped.\n * @class SessionEventArgs\n */\nexport class SessionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {string} sessionId - The session id.\n     */\n    constructor(sessionId) {\n        this.privSessionId = sessionId;\n    }\n    /**\n     * Represents the session identifier.\n     * @member SessionEventArgs.prototype.sessionId\n     * @function\n     * @public\n     * @returns {string} Represents the session identifier.\n     */\n    get sessionId() {\n        return this.privSessionId;\n    }\n}\n\n//# sourceMappingURL=SessionEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\n/**\n * Source Language configuration.\n * @class SourceLanguageConfig\n */\nexport class SourceLanguageConfig {\n    constructor(language, endpointId) {\n        Contracts.throwIfNullOrUndefined(language, \"language\");\n        this.privLanguage = language;\n        this.privEndpointId = endpointId;\n    }\n    /**\n     * @member SourceLanguageConfig.fromLanguage\n     * @function\n     * @public\n     * @param {string} language language (eg. \"en-US\") value of config.\n     * @param {string?} endpointId endpointId of model bound to given language of config.\n     * @return {SourceLanguageConfig} Instance of SourceLanguageConfig\n     * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.\n     * Added in version 1.13.0.\n     */\n    static fromLanguage(language, endpointId) {\n        return new SourceLanguageConfig(language, endpointId);\n    }\n    get language() {\n        return this.privLanguage;\n    }\n    get endpointId() {\n        return this.privEndpointId;\n    }\n}\n\n//# sourceMappingURL=SourceLanguageConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\nimport { VoiceProfileType, } from \"./Exports\";\n/**\n * Defines SpeakerIdentificationModel class for Speaker Recognition\n * Model contains a set of profiles against which to identify speaker(s)\n * @class SpeakerIdentificationModel\n */\nexport class SpeakerIdentificationModel {\n    constructor(profiles) {\n        this.privVoiceProfiles = [];\n        Contracts.throwIfNullOrUndefined(profiles, \"VoiceProfiles\");\n        if (profiles.length === 0) {\n            throw new Error(\"Empty Voice Profiles array\");\n        }\n        profiles.forEach((profile) => {\n            if (profile.profileType !== VoiceProfileType.TextIndependentIdentification) {\n                throw new Error(\"Identification model can only be created from Identification profile: \" + profile.profileId);\n            }\n            this.privVoiceProfiles.push(profile);\n        });\n    }\n    static fromProfiles(profiles) {\n        return new SpeakerIdentificationModel(profiles);\n    }\n    get voiceProfileIds() {\n        return this.privVoiceProfiles.map((profile) => profile.profileId).join(\",\");\n    }\n}\n\n//# sourceMappingURL=SpeakerIdentificationModel.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { CancellationErrorCodePropertyName } from \"../common.speech/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { CancellationDetailsBase, CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, } from \"./Exports\";\nexport var SpeakerRecognitionResultType;\n(function (SpeakerRecognitionResultType) {\n    SpeakerRecognitionResultType[SpeakerRecognitionResultType[\"Verify\"] = 0] = \"Verify\";\n    SpeakerRecognitionResultType[SpeakerRecognitionResultType[\"Identify\"] = 1] = \"Identify\";\n})(SpeakerRecognitionResultType || (SpeakerRecognitionResultType = {}));\n/**\n * Output format\n * @class SpeakerRecognitionResult\n */\nexport class SpeakerRecognitionResult {\n    constructor(resultType, data, profileId, resultReason = ResultReason.RecognizedSpeaker) {\n        this.privProperties = new PropertyCollection();\n        this.privReason = resultReason;\n        if (this.privReason !== ResultReason.Canceled) {\n            if (resultType === SpeakerRecognitionResultType.Identify) {\n                const json = JSON.parse(data);\n                Contracts.throwIfNullOrUndefined(json, \"JSON\");\n                this.privProfileId = json.identifiedProfile.profileId;\n                this.privScore = json.identifiedProfile.score;\n            }\n            else {\n                const json = JSON.parse(data);\n                Contracts.throwIfNullOrUndefined(json, \"JSON\");\n                this.privScore = json.score;\n                if (json.recognitionResult.toLowerCase() !== \"accept\") {\n                    this.privReason = ResultReason.NoMatch;\n                }\n                if (profileId !== undefined && profileId !== \"\") {\n                    this.privProfileId = profileId;\n                }\n            }\n        }\n        else {\n            const json = JSON.parse(data);\n            Contracts.throwIfNullOrUndefined(json, \"JSON\");\n            this.privErrorDetails = json.statusText;\n            this.privProperties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[CancellationErrorCode.ServiceError]);\n        }\n        this.privProperties.setProperty(PropertyId.SpeechServiceResponse_JsonResult, data);\n    }\n    get properties() {\n        return this.privProperties;\n    }\n    get reason() {\n        return this.privReason;\n    }\n    get profileId() {\n        return this.privProfileId;\n    }\n    get errorDetails() {\n        return this.privErrorDetails;\n    }\n    get score() {\n        return this.privScore;\n    }\n}\n/**\n * @class SpeakerRecognitionCancellationDetails\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class SpeakerRecognitionCancellationDetails extends CancellationDetailsBase {\n    constructor(reason, errorDetails, errorCode) {\n        super(reason, errorDetails, errorCode);\n    }\n    /**\n     * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult\n     * @member SpeakerRecognitionCancellationDetails.fromResult\n     * @function\n     * @public\n     * @param {SpeakerRecognitionResult} result - The result that was canceled.\n     * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.\n     */\n    static fromResult(result) {\n        const reason = CancellationReason.Error;\n        let errorCode = CancellationErrorCode.NoError;\n        if (!!result.properties) {\n            errorCode = CancellationErrorCode[result.properties.getProperty(CancellationErrorCodePropertyName, CancellationErrorCode[CancellationErrorCode.NoError])];\n        }\n        return new SpeakerRecognitionCancellationDetails(reason, result.errorDetails, errorCode);\n    }\n}\n\n//# sourceMappingURL=SpeakerRecognitionResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Context, OS, SpeakerIdMessageAdapter, SpeakerRecognitionConfig, } from \"../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { PropertyId, ResultReason, SpeakerIdentificationModel, SpeakerRecognitionResult, SpeakerRecognitionResultType, SpeakerVerificationModel, } from \"./Exports\";\n/**\n * Defines SpeakerRecognizer class for Speaker Recognition\n * Handles operations from user for Voice Profile operations (e.g. createProfile, deleteProfile)\n * @class SpeakerRecognizer\n */\nexport class SpeakerRecognizer {\n    /**\n     * SpeakerRecognizer constructor.\n     * @constructor\n     * @param {SpeechConfig} speechConfig - An set of initial properties for this recognizer (authentication key, region, &c)\n     */\n    constructor(speechConfig, audioConfig) {\n        const speechConfigImpl = speechConfig;\n        Contracts.throwIfNull(speechConfigImpl, \"speechConfig\");\n        this.privAudioConfigImpl = audioConfig;\n        Contracts.throwIfNull(this.privAudioConfigImpl, \"audioConfig\");\n        this.privProperties = speechConfigImpl.properties.clone();\n        this.implSRSetup();\n    }\n    /**\n     * Gets the authorization token used to communicate with the service.\n     * @member SpeakerRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @returns {string} Authorization token.\n     */\n    get authorizationToken() {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    /**\n     * Gets/Sets the authorization token used to communicate with the service.\n     * @member SpeakerRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} token - Authorization token.\n     */\n    set authorizationToken(token) {\n        Contracts.throwIfNullOrWhitespace(token, \"token\");\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, token);\n    }\n    /**\n     * The collection of properties and their values defined for this SpeakerRecognizer.\n     * @member SpeakerRecognizer.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    /**\n     * Get recognition result for model using given audio\n     * @member SpeakerRecognizer.prototype.recognizeOnceAsync\n     * @function\n     * @public\n     * @param {SpeakerIdentificationModel} model Model containing Voice Profiles to be identified\n     * @param cb - Callback invoked once result is returned.\n     * @param err - Callback invoked in case of an error.\n     */\n    recognizeOnceAsync(model, cb, err) {\n        if (model instanceof SpeakerIdentificationModel) {\n            const responsePromise = this.privAdapter.identifySpeaker(model, this.privAudioConfigImpl);\n            marshalPromiseToCallbacks(this.getResult(responsePromise, SpeakerRecognitionResultType.Identify, undefined), cb, err);\n        }\n        else if (model instanceof SpeakerVerificationModel) {\n            const responsePromise = this.privAdapter.verifySpeaker(model, this.privAudioConfigImpl);\n            marshalPromiseToCallbacks(this.getResult(responsePromise, SpeakerRecognitionResultType.Verify, model.voiceProfile.profileId), cb, err);\n        }\n        else {\n            throw new Error(\"SpeakerRecognizer.recognizeOnce: Unexpected model type\");\n        }\n    }\n    /**\n     * Included for compatibility\n     * @member SpeakerRecognizer.prototype.close\n     * @function\n     * @public\n     */\n    close() {\n        return;\n    }\n    // Does class setup, swiped from Recognizer.\n    implSRSetup() {\n        let osPlatform = (typeof window !== \"undefined\") ? \"Browser\" : \"Node\";\n        let osName = \"unknown\";\n        let osVersion = \"unknown\";\n        if (typeof navigator !== \"undefined\") {\n            osPlatform = osPlatform + \"/\" + navigator.platform;\n            osName = navigator.userAgent;\n            osVersion = navigator.appVersion;\n        }\n        const recognizerConfig = new SpeakerRecognitionConfig(new Context(new OS(osPlatform, osName, osVersion)), this.privProperties);\n        this.privAdapter = new SpeakerIdMessageAdapter(recognizerConfig);\n    }\n    getResult(responsePromise, resultType, profileId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield responsePromise;\n            return new SpeakerRecognitionResult(resultType, response.data, profileId, response.ok ? ResultReason.RecognizedSpeaker : ResultReason.Canceled);\n        });\n    }\n}\n\n//# sourceMappingURL=SpeakerRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\nimport { VoiceProfileType, } from \"./Exports\";\n/**\n * Defines SpeakerVerificationModel class for Speaker Recognition\n * Model contains a profile against which to verify a speaker\n * @class SpeakerVerificationModel\n */\nexport class SpeakerVerificationModel {\n    constructor(profile) {\n        Contracts.throwIfNullOrUndefined(profile, \"VoiceProfile\");\n        if (profile.profileType === VoiceProfileType.TextIndependentIdentification) {\n            throw new Error(\"Verification model cannot be created from Identification profile\");\n        }\n        this.privVoiceProfile = profile;\n    }\n    static fromProfile(profile) {\n        return new SpeakerVerificationModel(profile);\n    }\n    get voiceProfile() {\n        return this.privVoiceProfile;\n    }\n}\n\n//# sourceMappingURL=SpeakerVerificationModel.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ForceDictationPropertyName, OutputFormatPropertyName, ServicePropertiesPropertyName } from \"../common.speech/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { OutputFormat, ProfanityOption, PropertyCollection, PropertyId, SpeechSynthesisOutputFormat, } from \"./Exports\";\n/**\n * Speech configuration.\n * @class SpeechConfig\n */\nexport class SpeechConfig {\n    /**\n     * Creates and initializes an instance.\n     * @constructor\n     */\n    constructor() { }\n    /**\n     * Static instance of SpeechConfig returned by passing subscriptionKey and service region.\n     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.\n     * @member SpeechConfig.fromSubscription\n     * @function\n     * @public\n     * @param {string} subscriptionKey - The subscription key.\n     * @param {string} region - The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n     * @returns {SpeechConfig} The speech factory\n     */\n    static fromSubscription(subscriptionKey, region) {\n        Contracts.throwIfNullOrWhitespace(subscriptionKey, \"subscriptionKey\");\n        Contracts.throwIfNullOrWhitespace(region, \"region\");\n        const speechImpl = new SpeechConfigImpl();\n        speechImpl.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n        speechImpl.setProperty(PropertyId.SpeechServiceConnection_IntentRegion, region);\n        speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n        return speechImpl;\n    }\n    /**\n     * Creates an instance of the speech config with specified endpoint and subscription key.\n     * This method is intended only for users who use a non-standard service endpoint or parameters.\n     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.\n     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.\n     * For example, if language is defined in the uri as query parameter \"language=de-DE\", and also set by\n     *              SpeechConfig.speechRecognitionLanguage = \"en-US\", the language setting in uri takes precedence,\n     *              and the effective language is \"de-DE\". Only the parameters that are not specified in the\n     *              endpoint URL can be set by other APIs.\n     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the\n     *       fromEndpoint method, and then set authorizationToken=\"token\" on the created SpeechConfig instance to\n     *       use the authorization token.\n     * @member SpeechConfig.fromEndpoint\n     * @function\n     * @public\n     * @param {URL} endpoint - The service endpoint to connect to.\n     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.\n     * @returns {SpeechConfig} A speech factory instance.\n     */\n    static fromEndpoint(endpoint, subscriptionKey) {\n        Contracts.throwIfNull(endpoint, \"endpoint\");\n        const speechImpl = new SpeechConfigImpl();\n        speechImpl.setProperty(PropertyId.SpeechServiceConnection_Endpoint, endpoint.href);\n        if (undefined !== subscriptionKey) {\n            speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n        }\n        return speechImpl;\n    }\n    /**\n     * Creates an instance of the speech config with specified host and subscription key.\n     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.\n     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.\n     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.\n     * Note: To use an authorization token with fromHost, use fromHost(URL),\n     * and then set the AuthorizationToken property on the created SpeechConfig instance.\n     * Note: Added in version 1.9.0.\n     * @member SpeechConfig.fromHost\n     * @function\n     * @public\n     * @param {URL} host - The service endpoint to connect to. Format is \"protocol://host:port\" where \":port\" is optional.\n     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.\n     * @returns {SpeechConfig} A speech factory instance.\n     */\n    static fromHost(hostName, subscriptionKey) {\n        Contracts.throwIfNull(hostName, \"hostName\");\n        const speechImpl = new SpeechConfigImpl();\n        speechImpl.setProperty(PropertyId.SpeechServiceConnection_Host, hostName.protocol + \"//\" + hostName.hostname + (hostName.port === \"\" ? \"\" : \":\" + hostName.port));\n        if (undefined !== subscriptionKey) {\n            speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n        }\n        return speechImpl;\n    }\n    /**\n     * Creates an instance of the speech factory with specified initial authorization token and region.\n     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token\n     *       expires, the caller needs to refresh it by calling this setter with a new valid token.\n     * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want\n     *       to use the Intent recognizer. As configuration values are copied when creating a new recognizer,\n     *       the new token value will not apply to recognizers that have already been created. For recognizers\n     *       that have been created before, you need to set authorization token of the corresponding recognizer\n     *       to refresh the token. Otherwise, the recognizers will encounter errors during recognition.\n     * @member SpeechConfig.fromAuthorizationToken\n     * @function\n     * @public\n     * @param {string} authorizationToken - The initial authorization token.\n     * @param {string} region - The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n     * @returns {SpeechConfig} A speech factory instance.\n     */\n    static fromAuthorizationToken(authorizationToken, region) {\n        Contracts.throwIfNull(authorizationToken, \"authorizationToken\");\n        Contracts.throwIfNullOrWhitespace(region, \"region\");\n        const speechImpl = new SpeechConfigImpl();\n        speechImpl.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n        speechImpl.setProperty(PropertyId.SpeechServiceConnection_IntentRegion, region);\n        speechImpl.authorizationToken = authorizationToken;\n        return speechImpl;\n    }\n    /**\n     * Closes the configuration.\n     * @member SpeechConfig.prototype.close\n     * @function\n     * @public\n     */\n    /* tslint:disable:no-empty */\n    close() { }\n}\n/**\n * @public\n * @class SpeechConfigImpl\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class SpeechConfigImpl extends SpeechConfig {\n    constructor() {\n        super();\n        this.privProperties = new PropertyCollection();\n        this.speechRecognitionLanguage = \"en-US\"; // Should we have a default?\n        this.outputFormat = OutputFormat.Simple;\n    }\n    get properties() {\n        return this.privProperties;\n    }\n    get endPoint() {\n        return new URL(this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Endpoint));\n    }\n    get subscriptionKey() {\n        return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Key);\n    }\n    get region() {\n        return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Region);\n    }\n    get authorizationToken() {\n        return this.privProperties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    set authorizationToken(value) {\n        this.privProperties.setProperty(PropertyId.SpeechServiceAuthorization_Token, value);\n    }\n    get speechRecognitionLanguage() {\n        return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n    }\n    set speechRecognitionLanguage(value) {\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecoLanguage, value);\n    }\n    get autoDetectSourceLanguages() {\n        return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);\n    }\n    set autoDetectSourceLanguages(value) {\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, value);\n    }\n    get outputFormat() {\n        return OutputFormat[this.privProperties.getProperty(OutputFormatPropertyName, undefined)];\n    }\n    set outputFormat(value) {\n        this.privProperties.setProperty(OutputFormatPropertyName, OutputFormat[value]);\n    }\n    get endpointId() {\n        return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_EndpointId);\n    }\n    set endpointId(value) {\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_EndpointId, value);\n    }\n    setProperty(name, value) {\n        Contracts.throwIfNull(value, \"value\");\n        this.privProperties.setProperty(name, value);\n    }\n    getProperty(name, def) {\n        return this.privProperties.getProperty(name, def);\n    }\n    setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {\n        this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName);\n        this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyPort], proxyPort);\n        this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName);\n        this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);\n    }\n    setServiceProperty(name, value, channel) {\n        const currentProperties = JSON.parse(this.privProperties.getProperty(ServicePropertiesPropertyName, \"{}\"));\n        currentProperties[name] = value;\n        this.privProperties.setProperty(ServicePropertiesPropertyName, JSON.stringify(currentProperties));\n    }\n    setProfanity(profanity) {\n        this.privProperties.setProperty(PropertyId.SpeechServiceResponse_ProfanityOption, ProfanityOption[profanity]);\n    }\n    enableAudioLogging() {\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_EnableAudioLogging, \"true\");\n    }\n    requestWordLevelTimestamps() {\n        this.privProperties.setProperty(PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, \"true\");\n    }\n    enableDictation() {\n        this.privProperties.setProperty(ForceDictationPropertyName, \"true\");\n    }\n    clone() {\n        const ret = new SpeechConfigImpl();\n        ret.privProperties = this.privProperties.clone();\n        return ret;\n    }\n    get speechSynthesisLanguage() {\n        return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_SynthLanguage);\n    }\n    set speechSynthesisLanguage(language) {\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_SynthLanguage, language);\n    }\n    get speechSynthesisVoiceName() {\n        return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_SynthVoice);\n    }\n    set speechSynthesisVoiceName(voice) {\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_SynthVoice, voice);\n    }\n    get speechSynthesisOutputFormat() {\n        return SpeechSynthesisOutputFormat[this.privProperties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)];\n    }\n    set speechSynthesisOutputFormat(format) {\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, SpeechSynthesisOutputFormat[format]);\n    }\n}\n\n//# sourceMappingURL=SpeechConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { CancellationEventArgsBase, } from \"./CancellationEventArgsBase\";\nexport class SpeechRecognitionCanceledEventArgs extends CancellationEventArgsBase {\n}\n\n//# sourceMappingURL=SpeechRecognitionCanceledEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RecognitionEventArgs } from \"./Exports\";\n/**\n * Defines contents of speech recognizing/recognized event.\n * @class SpeechRecognitionEventArgs\n */\nexport class SpeechRecognitionEventArgs extends RecognitionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {SpeechRecognitionResult} result - The speech recognition result.\n     * @param {number} offset - The offset.\n     * @param {string} sessionId - The session id.\n     */\n    constructor(result, offset, sessionId) {\n        super(offset, sessionId);\n        this.privResult = result;\n    }\n    /**\n     * Specifies the recognition result.\n     * @member SpeechRecognitionEventArgs.prototype.result\n     * @function\n     * @public\n     * @returns {SpeechRecognitionResult} the recognition result.\n     */\n    get result() {\n        return this.privResult;\n    }\n}\n/**\n * Defines contents of conversation transcribed/transcribing event.\n * @class ConversationTranscriptionEventArgs\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class ConversationTranscriptionEventArgs extends SpeechRecognitionEventArgs {\n}\n\n//# sourceMappingURL=SpeechRecognitionEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RecognitionResult } from \"./Exports\";\n/**\n * Defines result of speech recognition.\n * @class SpeechRecognitionResult\n */\nexport class SpeechRecognitionResult extends RecognitionResult {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @public\n     * @param {string} resultId - The result id.\n     * @param {ResultReason} reason - The reason.\n     * @param {string} text - The recognized text.\n     * @param {number} duration - The duration.\n     * @param {number} offset - The offset into the stream.\n     * @param {string} language - Primary Language detected, if provided.\n     * @param {string} languageDetectionConfidence - Primary Language confidence (\"Unknown,\" \"Low,\" \"Medium,\" \"High\"...), if provided.\n     * @param {string} speakerId - speaker id for conversation transcription, if provided.\n     * @param {string} errorDetails - Error details, if provided.\n     * @param {string} json - Additional Json, if provided.\n     * @param {PropertyCollection} properties - Additional properties, if provided.\n     */\n    constructor(resultId, reason, text, duration, offset, language, languageDetectionConfidence, speakerId, errorDetails, json, properties) {\n        super(resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties);\n        this.privSpeakerId = speakerId;\n    }\n    /**\n     * speaker id from conversation transcription/id scenarios\n     * @member SpeechRecognitionResult.prototype.speakerId\n     * @function\n     * @public\n     * @returns {string} id of speaker in given result\n     */\n    get speakerId() {\n        return this.privSpeakerId;\n    }\n}\n\n//# sourceMappingURL=SpeechRecognitionResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { OutputFormatPropertyName, RecognitionMode, RecognizerConfig, SpeechConnectionFactory, SpeechServiceRecognizer, } from \"../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { OutputFormat, PropertyId, Recognizer, } from \"./Exports\";\n/**\n * Performs speech recognition from microphone, file, or other audio input streams, and gets transcribed text as result.\n * @class SpeechRecognizer\n */\nexport class SpeechRecognizer extends Recognizer {\n    /**\n     * SpeechRecognizer constructor.\n     * @constructor\n     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer\n     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer\n     */\n    constructor(speechConfig, audioConfig) {\n        const speechConfigImpl = speechConfig;\n        Contracts.throwIfNull(speechConfigImpl, \"speechConfig\");\n        Contracts.throwIfNullOrWhitespace(speechConfigImpl.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage), PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n        super(audioConfig, speechConfigImpl.properties, new SpeechConnectionFactory());\n        this.privDisposedRecognizer = false;\n    }\n    /**\n     * SpeechRecognizer constructor.\n     * @constructor\n     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer\n     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer\n     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer\n     */\n    static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {\n        const speechConfigImpl = speechConfig;\n        autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);\n        const recognizer = new SpeechRecognizer(speechConfig, audioConfig);\n        return recognizer;\n    }\n    /**\n     * Gets the endpoint id of a customized speech model that is used for speech recognition.\n     * @member SpeechRecognizer.prototype.endpointId\n     * @function\n     * @public\n     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.\n     */\n    get endpointId() {\n        Contracts.throwIfDisposed(this.privDisposedRecognizer);\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_EndpointId, \"00000000-0000-0000-0000-000000000000\");\n    }\n    /**\n     * Gets the authorization token used to communicate with the service.\n     * @member SpeechRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @returns {string} Authorization token.\n     */\n    get authorizationToken() {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    /**\n     * Gets/Sets the authorization token used to communicate with the service.\n     * @member SpeechRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} token - Authorization token.\n     */\n    set authorizationToken(token) {\n        Contracts.throwIfNullOrWhitespace(token, \"token\");\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, token);\n    }\n    /**\n     * Gets the spoken language of recognition.\n     * @member SpeechRecognizer.prototype.speechRecognitionLanguage\n     * @function\n     * @public\n     * @returns {string} The spoken language of recognition.\n     */\n    get speechRecognitionLanguage() {\n        Contracts.throwIfDisposed(this.privDisposedRecognizer);\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n    }\n    /**\n     * Gets the output format of recognition.\n     * @member SpeechRecognizer.prototype.outputFormat\n     * @function\n     * @public\n     * @returns {OutputFormat} The output format of recognition.\n     */\n    get outputFormat() {\n        Contracts.throwIfDisposed(this.privDisposedRecognizer);\n        if (this.properties.getProperty(OutputFormatPropertyName, OutputFormat[OutputFormat.Simple]) === OutputFormat[OutputFormat.Simple]) {\n            return OutputFormat.Simple;\n        }\n        else {\n            return OutputFormat.Detailed;\n        }\n    }\n    /**\n     * The collection of properties and their values defined for this SpeechRecognizer.\n     * @member SpeechRecognizer.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    /**\n     * Starts speech recognition, and stops after the first utterance is recognized.\n     * The task returns the recognition text as result.\n     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,\n     *       so it is suitable only for single shot recognition\n     *       like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.\n     * @member SpeechRecognizer.prototype.recognizeOnceAsync\n     * @function\n     * @public\n     * @param cb - Callback that received the SpeechRecognitionResult.\n     * @param err - Callback invoked in case of an error.\n     */\n    recognizeOnceAsync(cb, err) {\n        marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(RecognitionMode.Interactive), cb, err);\n    }\n    /**\n     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.\n     * User must subscribe to events to receive recognition results.\n     * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the recognition has started.\n     * @param err - Callback invoked in case of an error.\n     */\n    startContinuousRecognitionAsync(cb, err) {\n        marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(RecognitionMode.Conversation), cb, err);\n    }\n    /**\n     * Stops continuous speech recognition.\n     * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the recognition has stopped.\n     * @param err - Callback invoked in case of an error.\n     */\n    stopContinuousRecognitionAsync(cb, err) {\n        marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);\n    }\n    /**\n     * Starts speech recognition with keyword spotting, until\n     * stopKeywordRecognitionAsync() is called.\n     * User must subscribe to events to receive recognition results.\n     * Note: Key word spotting functionality is only available on the\n     *      Speech Devices SDK. This functionality is currently not included in the SDK itself.\n     * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync\n     * @function\n     * @public\n     * @param {KeywordRecognitionModel} model The keyword recognition model that\n     *        specifies the keyword to be recognized.\n     * @param cb - Callback invoked once the recognition has started.\n     * @param err - Callback invoked in case of an error.\n     */\n    startKeywordRecognitionAsync(model, cb, err) {\n        Contracts.throwIfNull(model, \"model\");\n        if (!!err) {\n            err(\"Not yet implemented.\");\n        }\n    }\n    /**\n     * Stops continuous speech recognition.\n     * Note: Key word spotting functionality is only available on the\n     *       Speech Devices SDK. This functionality is currently not included in the SDK itself.\n     * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the recognition has stopped.\n     * @param err - Callback invoked in case of an error.\n     */\n    stopKeywordRecognitionAsync(cb, err) {\n        if (!!cb) {\n            cb();\n        }\n    }\n    /**\n     * closes all external resources held by an instance of this class.\n     * @member SpeechRecognizer.prototype.close\n     * @function\n     * @public\n     */\n    close(cb, errorCb) {\n        Contracts.throwIfDisposed(this.privDisposedRecognizer);\n        marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n    }\n    /**\n     * Disposes any resources held by the object.\n     * @member SpeechRecognizer.prototype.dispose\n     * @function\n     * @public\n     * @param {boolean} disposing - true if disposing the object.\n     */\n    dispose(disposing) {\n        const _super = Object.create(null, {\n            dispose: { get: () => super.dispose }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privDisposedRecognizer) {\n                return;\n            }\n            if (disposing) {\n                this.privDisposedRecognizer = true;\n                yield this.implRecognizerStop();\n            }\n            yield _super.dispose.call(this, disposing);\n        });\n    }\n    createRecognizerConfig(speechConfig) {\n        return new RecognizerConfig(speechConfig, this.properties);\n    }\n    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n        const configImpl = audioConfig;\n        return new SpeechServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);\n    }\n}\n\n//# sourceMappingURL=SpeechRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines contents of speech synthesis bookmark event.\n * @class SpeechSynthesisBookmarkEventArgs\n * Added in version 1.16.0\n */\nexport class SpeechSynthesisBookmarkEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {number} audioOffset - The audio offset.\n     * @param {string} text - The bookmark text.\n     */\n    constructor(audioOffset, text) {\n        this.privAudioOffset = audioOffset;\n        this.privText = text;\n    }\n    /**\n     * Specifies the audio offset.\n     * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset\n     * @function\n     * @public\n     * @returns {number} the audio offset.\n     */\n    get audioOffset() {\n        return this.privAudioOffset;\n    }\n    /**\n     * Specifies the bookmark.\n     * @member SpeechSynthesisBookmarkEventArgs.prototype.text\n     * @function\n     * @public\n     * @returns {string} the bookmark text.\n     */\n    get text() {\n        return this.privText;\n    }\n}\n\n//# sourceMappingURL=SpeechSynthesisBookmarkEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines contents of speech synthesis events.\n * @class SpeechSynthesisEventArgs\n * Added in version 1.11.0\n */\nexport class SpeechSynthesisEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {SpeechSynthesisResult} result - The speech synthesis result.\n     */\n    constructor(result) {\n        this.privResult = result;\n    }\n    /**\n     * Specifies the synthesis result.\n     * @member SpeechSynthesisEventArgs.prototype.result\n     * @function\n     * @public\n     * @returns {SpeechSynthesisResult} the synthesis result.\n     */\n    get result() {\n        return this.privResult;\n    }\n}\n\n//# sourceMappingURL=SpeechSynthesisEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Define speech synthesis audio output formats.\n * @enum SpeechSynthesisOutputFormat\n * Updated in version 1.17.0\n */\nexport var SpeechSynthesisOutputFormat;\n(function (SpeechSynthesisOutputFormat) {\n    /**\n     * raw-8khz-8bit-mono-mulaw\n     * @member SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw,\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Raw8Khz8BitMonoMULaw\"] = 0] = \"Raw8Khz8BitMonoMULaw\";\n    /**\n     * riff-16khz-16kbps-mono-siren\n     * @note Unsupported by the service. Do not use this value.\n     * @member SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Riff16Khz16KbpsMonoSiren\"] = 1] = \"Riff16Khz16KbpsMonoSiren\";\n    /**\n     * audio-16khz-16kbps-mono-siren\n     * @note Unsupported by the service. Do not use this value.\n     * @member SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Audio16Khz16KbpsMonoSiren\"] = 2] = \"Audio16Khz16KbpsMonoSiren\";\n    /**\n     * audio-16khz-32kbitrate-mono-mp3\n     * @member SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Audio16Khz32KBitRateMonoMp3\"] = 3] = \"Audio16Khz32KBitRateMonoMp3\";\n    /**\n     * audio-16khz-128kbitrate-mono-mp3\n     * @member SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Audio16Khz128KBitRateMonoMp3\"] = 4] = \"Audio16Khz128KBitRateMonoMp3\";\n    /**\n     * audio-16khz-64kbitrate-mono-mp3\n     * @member SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Audio16Khz64KBitRateMonoMp3\"] = 5] = \"Audio16Khz64KBitRateMonoMp3\";\n    /**\n     * audio-24khz-48kbitrate-mono-mp3\n     * @member SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Audio24Khz48KBitRateMonoMp3\"] = 6] = \"Audio24Khz48KBitRateMonoMp3\";\n    /**\n     * audio-24khz-96kbitrate-mono-mp3\n     * @member SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Audio24Khz96KBitRateMonoMp3\"] = 7] = \"Audio24Khz96KBitRateMonoMp3\";\n    /**\n     * audio-24khz-160kbitrate-mono-mp3\n     * @member SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Audio24Khz160KBitRateMonoMp3\"] = 8] = \"Audio24Khz160KBitRateMonoMp3\";\n    /**\n     * raw-16khz-16bit-mono-truesilk\n     * @member SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Raw16Khz16BitMonoTrueSilk\"] = 9] = \"Raw16Khz16BitMonoTrueSilk\";\n    /**\n     * riff-16khz-16bit-mono-pcm\n     * @member SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Riff16Khz16BitMonoPcm\"] = 10] = \"Riff16Khz16BitMonoPcm\";\n    /**\n     * riff-8khz-16bit-mono-pcm\n     * @member SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Riff8Khz16BitMonoPcm\"] = 11] = \"Riff8Khz16BitMonoPcm\";\n    /**\n     * riff-24khz-16bit-mono-pcm\n     * @member SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Riff24Khz16BitMonoPcm\"] = 12] = \"Riff24Khz16BitMonoPcm\";\n    /**\n     * riff-8khz-8bit-mono-mulaw\n     * @member SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Riff8Khz8BitMonoMULaw\"] = 13] = \"Riff8Khz8BitMonoMULaw\";\n    /**\n     * raw-16khz-16bit-mono-pcm\n     * @member SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Raw16Khz16BitMonoPcm\"] = 14] = \"Raw16Khz16BitMonoPcm\";\n    /**\n     * raw-24khz-16bit-mono-pcm\n     * @member SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Raw24Khz16BitMonoPcm\"] = 15] = \"Raw24Khz16BitMonoPcm\";\n    /**\n     * raw-8khz-16bit-mono-pcm\n     * @member SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Raw8Khz16BitMonoPcm\"] = 16] = \"Raw8Khz16BitMonoPcm\";\n    /**\n     * ogg-16khz-16bit-mono-opus\n     * @member SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Ogg16Khz16BitMonoOpus\"] = 17] = \"Ogg16Khz16BitMonoOpus\";\n    /**\n     * ogg-24khz-16bit-mono-opus\n     * @member SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Ogg24Khz16BitMonoOpus\"] = 18] = \"Ogg24Khz16BitMonoOpus\";\n    /**\n     * raw-48khz-16bit-mono-pcm\n     * @member SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Raw48Khz16BitMonoPcm\"] = 19] = \"Raw48Khz16BitMonoPcm\";\n    /**\n     * riff-48khz-16bit-mono-pcm\n     * @member SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Riff48Khz16BitMonoPcm\"] = 20] = \"Riff48Khz16BitMonoPcm\";\n    /**\n     * audio-48khz-96kbitrate-mono-mp3\n     * @member SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Audio48Khz96KBitRateMonoMp3\"] = 21] = \"Audio48Khz96KBitRateMonoMp3\";\n    /**\n     * audio-48khz-192kbitrate-mono-mp3\n     * @member SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Audio48Khz192KBitRateMonoMp3\"] = 22] = \"Audio48Khz192KBitRateMonoMp3\";\n    /**\n     * ogg-48khz-16bit-mono-opus\n     * Added in version 1.16.0\n     * @member SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Ogg48Khz16BitMonoOpus\"] = 23] = \"Ogg48Khz16BitMonoOpus\";\n    /**\n     * webm-16khz-16bit-mono-opus\n     * Added in version 1.16.0\n     * @member SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Webm16Khz16BitMonoOpus\"] = 24] = \"Webm16Khz16BitMonoOpus\";\n    /**\n     * webm-24khz-16bit-mono-opus\n     * Added in version 1.16.0\n     * @member SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Webm24Khz16BitMonoOpus\"] = 25] = \"Webm24Khz16BitMonoOpus\";\n    /**\n     * raw-24khz-16bit-mono-truesilk\n     * Added in version 1.17.0\n     * @member SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Raw24Khz16BitMonoTrueSilk\"] = 26] = \"Raw24Khz16BitMonoTrueSilk\";\n    /**\n     * raw-8khz-8bit-mono-alaw\n     * Added in version 1.17.0\n     * @member SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Raw8Khz8BitMonoALaw\"] = 27] = \"Raw8Khz8BitMonoALaw\";\n    /**\n     * riff-8khz-8bit-mono-alaw\n     * Added in version 1.17.0\n     * @member SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw\n     */\n    SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat[\"Riff8Khz8BitMonoALaw\"] = 28] = \"Riff8Khz8BitMonoALaw\";\n})(SpeechSynthesisOutputFormat || (SpeechSynthesisOutputFormat = {}));\n\n//# sourceMappingURL=SpeechSynthesisOutputFormat.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines result of speech synthesis.\n * @class SpeechSynthesisResult\n * Added in version 1.11.0\n */\nexport class SpeechSynthesisResult {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {string} resultId - The result id.\n     * @param {ResultReason} reason - The reason.\n     * @param {number} audioData - The offset into the stream.\n     * @param {string} errorDetails - Error details, if provided.\n     * @param {PropertyCollection} properties - Additional properties, if provided.\n     */\n    constructor(resultId, reason, audioData, errorDetails, properties) {\n        this.privResultId = resultId;\n        this.privReason = reason;\n        this.privAudioData = audioData;\n        this.privErrorDetails = errorDetails;\n        this.privProperties = properties;\n    }\n    /**\n     * Specifies the result identifier.\n     * @member SpeechSynthesisResult.prototype.resultId\n     * @function\n     * @public\n     * @returns {string} Specifies the result identifier.\n     */\n    get resultId() {\n        return this.privResultId;\n    }\n    /**\n     * Specifies status of the result.\n     * @member SpeechSynthesisResult.prototype.reason\n     * @function\n     * @public\n     * @returns {ResultReason} Specifies status of the result.\n     */\n    get reason() {\n        return this.privReason;\n    }\n    /**\n     * The synthesized audio data\n     * @member SpeechSynthesisResult.prototype.audioData\n     * @function\n     * @public\n     * @returns {ArrayBuffer} The synthesized audio data.\n     */\n    get audioData() {\n        return this.privAudioData;\n    }\n    /**\n     * In case of an unsuccessful synthesis, provides details of the occurred error.\n     * @member SpeechSynthesisResult.prototype.errorDetails\n     * @function\n     * @public\n     * @returns {string} a brief description of an error.\n     */\n    get errorDetails() {\n        return this.privErrorDetails;\n    }\n    /**\n     *  The set of properties exposed in the result.\n     * @member SpeechSynthesisResult.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The set of properties exposed in the result.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n}\n\n//# sourceMappingURL=SpeechSynthesisResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines contents of speech synthesis viseme event.\n * @class SpeechSynthesisVisemeEventArgs\n * Added in version 1.16.0\n */\nexport class SpeechSynthesisVisemeEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {number} audioOffset - The audio offset.\n     * @param {number} visemeId - The viseme ID.\n     * @param {string} animation - The animation, could be in svg or other format.\n     */\n    constructor(audioOffset, visemeId, animation) {\n        this.privAudioOffset = audioOffset;\n        this.privVisemeId = visemeId;\n        this.privAnimation = animation;\n    }\n    /**\n     * Specifies the audio offset.\n     * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset\n     * @function\n     * @public\n     * @returns {number} the audio offset.\n     */\n    get audioOffset() {\n        return this.privAudioOffset;\n    }\n    /**\n     * Specifies the viseme ID.\n     * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId\n     * @function\n     * @public\n     * @returns {number} the viseme ID.\n     */\n    get visemeId() {\n        return this.privVisemeId;\n    }\n    /**\n     * Specifies the animation.\n     * @member SpeechSynthesisVisemeEventArgs.prototype.animation\n     * @function\n     * @public\n     * @returns {string} the animation, could be in svg or other format.\n     */\n    get animation() {\n        return this.privAnimation;\n    }\n}\n\n//# sourceMappingURL=SpeechSynthesisVisemeEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines contents of speech synthesis word boundary event.\n * @class SpeechSynthesisWordBoundaryEventArgs\n * Added in version 1.11.0\n */\nexport class SpeechSynthesisWordBoundaryEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {number} audioOffset - The audio offset.\n     * @param {string} text - The text.\n     * @param {number} wordLength - The length of the word.\n     * @param {number} textOffset - The text offset.\n     */\n    constructor(audioOffset, text, wordLength, textOffset) {\n        this.privAudioOffset = audioOffset;\n        this.privText = text;\n        this.privWordLength = wordLength;\n        this.privTextOffset = textOffset;\n    }\n    /**\n     * Specifies the audio offset.\n     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset\n     * @function\n     * @public\n     * @returns {number} the audio offset.\n     */\n    get audioOffset() {\n        return this.privAudioOffset;\n    }\n    /**\n     * Specifies the text of the word boundary event.\n     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text\n     * @function\n     * @public\n     * @returns {string} the text.\n     */\n    get text() {\n        return this.privText;\n    }\n    /**\n     * Specifies the word length\n     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength\n     * @function\n     * @public\n     * @returns {number} the word length\n     */\n    get wordLength() {\n        return this.privWordLength;\n    }\n    /**\n     * Specifies the text offset.\n     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset\n     * @function\n     * @public\n     * @returns {number} the text offset.\n     */\n    get textOffset() {\n        return this.privTextOffset;\n    }\n}\n\n//# sourceMappingURL=SpeechSynthesisWordBoundaryEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AutoDetectSourceLanguagesOpenRangeOptionName, CognitiveSubscriptionKeyAuthentication, CognitiveTokenAuthentication, Context, OS, SpeechServiceConfig, SpeechSynthesisConnectionFactory, SynthesisAdapterBase, SynthesizerConfig, } from \"../common.speech/Exports\";\nimport { createNoDashGuid, marshalPromiseToCallbacks, Queue } from \"../common/Exports\";\nimport { AudioFileWriter } from \"./Audio/AudioFileWriter\";\nimport { AudioOutputFormatImpl } from \"./Audio/AudioOutputFormat\";\nimport { PushAudioOutputStreamImpl } from \"./Audio/AudioOutputStream\";\nimport { Contracts } from \"./Contracts\";\nimport { AudioConfig, PropertyId, PullAudioOutputStream, PushAudioOutputStreamCallback, SpeechSynthesisOutputFormat, } from \"./Exports\";\n/**\n * Defines the class SpeechSynthesizer for text to speech.\n * Updated in version 1.16.0\n * @class SpeechSynthesizer\n */\nexport class SpeechSynthesizer {\n    /**\n     * SpeechSynthesizer constructor.\n     * @constructor\n     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.\n     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.\n     */\n    constructor(speechConfig, audioConfig) {\n        const speechConfigImpl = speechConfig;\n        Contracts.throwIfNull(speechConfigImpl, \"speechConfig\");\n        if (audioConfig !== null) {\n            if (audioConfig === undefined) {\n                this.audioConfig = (typeof window === \"undefined\") ? undefined : AudioConfig.fromDefaultSpeakerOutput();\n            }\n            else {\n                this.audioConfig = audioConfig;\n            }\n        }\n        this.privProperties = speechConfigImpl.properties.clone();\n        this.privDisposed = false;\n        this.privSynthesizing = false;\n        this.privConnectionFactory = new SpeechSynthesisConnectionFactory();\n        this.synthesisRequestQueue = new Queue();\n        this.implCommonSynthesizeSetup();\n    }\n    /**\n     * Gets the authorization token used to communicate with the service.\n     * @member SpeechSynthesizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @returns {string} Authorization token.\n     */\n    get authorizationToken() {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    /**\n     * Gets/Sets the authorization token used to communicate with the service.\n     * @member SpeechSynthesizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} token - Authorization token.\n     */\n    set authorizationToken(token) {\n        Contracts.throwIfNullOrWhitespace(token, \"token\");\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, token);\n    }\n    /**\n     * The collection of properties and their values defined for this SpeechSynthesizer.\n     * @member SpeechSynthesizer.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    /**\n     * Indicates if auto detect source language is enabled\n     * @member SpeechSynthesizer.prototype.properties\n     * @function\n     * @public\n     * @returns {boolean} if auto detect source language is enabled\n     */\n    get autoDetectSourceLanguage() {\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === AutoDetectSourceLanguagesOpenRangeOptionName;\n    }\n    /**\n     * SpeechSynthesizer constructor.\n     * @constructor\n     * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer\n     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer\n     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer\n     */\n    static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {\n        const speechConfigImpl = speechConfig;\n        autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);\n        return new SpeechSynthesizer(speechConfig, audioConfig);\n    }\n    buildSsml(text) {\n        const languageToDefaultVoice = {\n            [\"ar-EG\"]: \"ar-EG-SalmaNeural\",\n            [\"ar-SA\"]: \"ar-SA-HamedNeural\",\n            [\"bg-BG\"]: \"bg-BG-BorislavNeural\",\n            [\"ca-ES\"]: \"ca-ES-JoanaNeural\",\n            [\"cs-CZ\"]: \"cs-CZ-AntoninNeural\",\n            [\"cy-GB\"]: \"cy-GB-AledNeural\",\n            [\"da-DK\"]: \"da-DK-ChristelNeural\",\n            [\"de-AT\"]: \"de-AT-IngridNeural\",\n            [\"de-CH\"]: \"de-CH-JanNeural\",\n            [\"de-DE\"]: \"de-DE-KatjaNeural\",\n            [\"el-GR\"]: \"el-GR-AthinaNeural\",\n            [\"en-AU\"]: \"en-AU-NatashaNeural\",\n            [\"en-CA\"]: \"en-CA-ClaraNeural\",\n            [\"en-GB\"]: \"en-GB-LibbyNeural\",\n            [\"en-HK\"]: \"en-HK-SamNeural\",\n            [\"en-IE\"]: \"en-IE-ConnorNeural\",\n            [\"en-IN\"]: \"en-IN-NeerjaNeural\",\n            [\"en-NZ\"]: \"en-NZ-MitchellNeural\",\n            [\"en-PH\"]: \"en-PH-JamesNeural\",\n            [\"en-SG\"]: \"en-SG-LunaNeural\",\n            [\"en-US\"]: \"en-US-JennyNeural\",\n            [\"en-ZA\"]: \"en-ZA-LeahNeural\",\n            [\"es-AR\"]: \"es-AR-ElenaNeural\",\n            [\"es-CO\"]: \"es-CO-GonzaloNeural\",\n            [\"es-ES\"]: \"es-ES-AlvaroNeural\",\n            [\"es-MX\"]: \"es-MX-DaliaNeural\",\n            [\"es-US\"]: \"es-US-AlonsoNeural\",\n            [\"et-EE\"]: \"et-EE-AnuNeural\",\n            [\"fi-FI\"]: \"fi-FI-SelmaNeural\",\n            [\"fr-BE\"]: \"fr-BE-CharlineNeural\",\n            [\"fr-CA\"]: \"fr-CA-SylvieNeural\",\n            [\"fr-CH\"]: \"fr-CH-ArianeNeural\",\n            [\"fr-FR\"]: \"fr-FR-DeniseNeural\",\n            [\"ga-IE\"]: \"ga-IE-ColmNeural\",\n            [\"gu-IN\"]: \"gu-IN-DhwaniNeural\",\n            [\"he-IL\"]: \"he-IL-AvriNeural\",\n            [\"hi-IN\"]: \"hi-IN-MadhurNeural\",\n            [\"hr-HR\"]: \"hr-HR-GabrijelaNeural\",\n            [\"hu-HU\"]: \"hu-HU-NoemiNeural\",\n            [\"id-ID\"]: \"id-ID-ArdiNeural\",\n            [\"it-IT\"]: \"it-IT-IsabellaNeural\",\n            [\"ja-JP\"]: \"ja-JP-NanamiNeural\",\n            [\"ko-KR\"]: \"ko-KR-SunHiNeural\",\n            [\"lt-LT\"]: \"lt-LT-LeonasNeural\",\n            [\"lv-LV\"]: \"lv-LV-EveritaNeural\",\n            [\"mr-IN\"]: \"mr-IN-AarohiNeural\",\n            [\"ms-MY\"]: \"ms-MY-OsmanNeural\",\n            [\"mt-MT\"]: \"mt-MT-GraceNeural\",\n            [\"nb-NO\"]: \"nb-NO-PernilleNeural\",\n            [\"nl-BE\"]: \"nl-BE-ArnaudNeural\",\n            [\"nl-NL\"]: \"nl-NL-ColetteNeural\",\n            [\"pl-PL\"]: \"pl-PL-AgnieszkaNeural\",\n            [\"pt-BR\"]: \"pt-BR-FranciscaNeural\",\n            [\"pt-PT\"]: \"pt-PT-DuarteNeural\",\n            [\"ro-RO\"]: \"ro-RO-AlinaNeural\",\n            [\"ru-RU\"]: \"ru-RU-SvetlanaNeural\",\n            [\"sk-SK\"]: \"sk-SK-LukasNeural\",\n            [\"sl-SI\"]: \"sl-SI-PetraNeural\",\n            [\"sv-SE\"]: \"sv-SE-SofieNeural\",\n            [\"sw-KE\"]: \"sw-KE-RafikiNeural\",\n            [\"ta-IN\"]: \"ta-IN-PallaviNeural\",\n            [\"te-IN\"]: \"te-IN-MohanNeural\",\n            [\"th-TH\"]: \"th-TH-PremwadeeNeural\",\n            [\"tr-TR\"]: \"tr-TR-AhmetNeural\",\n            [\"uk-UA\"]: \"uk-UA-OstapNeural\",\n            [\"ur-PK\"]: \"ur-PK-AsadNeural\",\n            [\"vi-VN\"]: \"vi-VN-HoaiMyNeural\",\n            [\"zh-CN\"]: \"zh-CN-XiaoxiaoNeural\",\n            [\"zh-HK\"]: \"zh-HK-HiuMaanNeural\",\n            [\"zh-TW\"]: \"zh-TW-HsiaoChenNeural\",\n        };\n        let language = this.properties.getProperty(PropertyId.SpeechServiceConnection_SynthLanguage, \"en-US\");\n        let voice = this.properties.getProperty(PropertyId.SpeechServiceConnection_SynthVoice, \"\");\n        let ssml = SpeechSynthesizer.XMLEncode(text);\n        if (this.autoDetectSourceLanguage) {\n            language = \"en-US\";\n        }\n        else {\n            voice = voice || languageToDefaultVoice[language];\n        }\n        if (voice) {\n            ssml = `<voice name='${voice}'>${ssml}</voice>`;\n        }\n        ssml = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='${language}'>${ssml}</speak>`;\n        return ssml;\n    }\n    /**\n     * Executes speech synthesis on plain text.\n     * The task returns the synthesis result.\n     * @member SpeechSynthesizer.prototype.speakTextAsync\n     * @function\n     * @public\n     * @param text - Text to be synthesized.\n     * @param cb - Callback that received the SpeechSynthesisResult.\n     * @param err - Callback invoked in case of an error.\n     * @param stream - AudioOutputStream to receive the synthesized audio.\n     */\n    speakTextAsync(text, cb, err, stream) {\n        this.speakImpl(text, false, cb, err, stream);\n    }\n    /**\n     * Executes speech synthesis on SSML.\n     * The task returns the synthesis result.\n     * @member SpeechSynthesizer.prototype.speakSsmlAsync\n     * @function\n     * @public\n     * @param ssml - SSML to be synthesized.\n     * @param cb - Callback that received the SpeechSynthesisResult.\n     * @param err - Callback invoked in case of an error.\n     * @param stream - AudioOutputStream to receive the synthesized audio.\n     */\n    speakSsmlAsync(ssml, cb, err, stream) {\n        this.speakImpl(ssml, true, cb, err, stream);\n    }\n    /**\n     * Dispose of associated resources.\n     * @member SpeechSynthesizer.prototype.close\n     * @function\n     * @public\n     */\n    close(cb, err) {\n        Contracts.throwIfDisposed(this.privDisposed);\n        marshalPromiseToCallbacks(this.dispose(true), cb, err);\n    }\n    /**\n     * @Internal\n     * Do not use externally, object returned will change without warning or notice.\n     */\n    get internalData() {\n        return this.privAdapter;\n    }\n    /**\n     * This method performs cleanup of resources.\n     * The Boolean parameter disposing indicates whether the method is called\n     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).\n     * Derived classes should override this method to dispose resource if needed.\n     * @member SpeechSynthesizer.prototype.dispose\n     * @function\n     * @public\n     * @param {boolean} disposing - Flag to request disposal.\n     */\n    dispose(disposing) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privDisposed) {\n                return;\n            }\n            if (disposing) {\n                if (this.privAdapter) {\n                    yield this.privAdapter.dispose();\n                }\n            }\n            this.privDisposed = true;\n        });\n    }\n    //\n    // ################################################################################################################\n    // IMPLEMENTATION.\n    // Move to independent class\n    // ################################################################################################################\n    //\n    createSynthesizerConfig(speechConfig) {\n        return new SynthesizerConfig(speechConfig, this.privProperties);\n    }\n    // Creates the synthesis adapter\n    createSynthesisAdapter(authentication, connectionFactory, audioConfig, synthesizerConfig) {\n        return new SynthesisAdapterBase(authentication, connectionFactory, synthesizerConfig, this, this.audioConfig);\n    }\n    implCommonSynthesizeSetup() {\n        let osPlatform = (typeof window !== \"undefined\") ? \"Browser\" : \"Node\";\n        let osName = \"unknown\";\n        let osVersion = \"unknown\";\n        if (typeof navigator !== \"undefined\") {\n            osPlatform = osPlatform + \"/\" + navigator.platform;\n            osName = navigator.userAgent;\n            osVersion = navigator.appVersion;\n        }\n        const synthesizerConfig = this.createSynthesizerConfig(new SpeechServiceConfig(new Context(new OS(osPlatform, osName, osVersion))));\n        const subscriptionKey = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Key, undefined);\n        const authentication = (subscriptionKey && subscriptionKey !== \"\") ?\n            new CognitiveSubscriptionKeyAuthentication(subscriptionKey) :\n            new CognitiveTokenAuthentication((authFetchEventId) => {\n                const authorizationToken = this.privProperties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\n                return Promise.resolve(authorizationToken);\n            }, (authFetchEventId) => {\n                const authorizationToken = this.privProperties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\n                return Promise.resolve(authorizationToken);\n            });\n        this.privAdapter = this.createSynthesisAdapter(authentication, this.privConnectionFactory, this.audioConfig, synthesizerConfig);\n        this.privAdapter.audioOutputFormat = AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(SpeechSynthesisOutputFormat[this.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)]);\n    }\n    speakImpl(text, IsSsml, cb, err, dataStream) {\n        try {\n            Contracts.throwIfDisposed(this.privDisposed);\n            const requestId = createNoDashGuid();\n            let audioDestination;\n            if (dataStream instanceof PushAudioOutputStreamCallback) {\n                audioDestination = new PushAudioOutputStreamImpl(dataStream);\n            }\n            else if (dataStream instanceof PullAudioOutputStream) {\n                audioDestination = dataStream;\n            }\n            else if (dataStream !== undefined) {\n                audioDestination = new AudioFileWriter(dataStream);\n            }\n            else {\n                audioDestination = undefined;\n            }\n            this.synthesisRequestQueue.enqueue(new SynthesisRequest(requestId, text, IsSsml, (e) => {\n                this.privSynthesizing = false;\n                if (!!cb) {\n                    try {\n                        cb(e);\n                    }\n                    catch (e) {\n                        if (!!err) {\n                            err(e);\n                        }\n                    }\n                }\n                cb = undefined;\n                /* tslint:disable:no-empty */\n                this.adapterSpeak().catch(() => { });\n            }, (e) => {\n                if (!!err) {\n                    err(e);\n                }\n            }, audioDestination));\n            /* tslint:disable:no-empty */\n            this.adapterSpeak().catch(() => { });\n        }\n        catch (error) {\n            if (!!err) {\n                if (error instanceof Error) {\n                    const typedError = error;\n                    err(typedError.name + \": \" + typedError.message);\n                }\n                else {\n                    err(error);\n                }\n            }\n            // Destroy the synthesizer.\n            /* tslint:disable:no-empty */\n            this.dispose(true).catch(() => { });\n        }\n    }\n    adapterSpeak() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.privDisposed && !this.privSynthesizing) {\n                this.privSynthesizing = true;\n                const request = yield this.synthesisRequestQueue.dequeue();\n                return this.privAdapter.Speak(request.text, request.isSSML, request.requestId, request.cb, request.err, request.dataStream);\n            }\n        });\n    }\n    static XMLEncode(text) {\n        return text.replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\")\n            .replace(/\"/g, \"&quot;\")\n            .replace(/'/g, \"&apos;\");\n    }\n}\n// tslint:disable-next-line:max-classes-per-file\nexport class SynthesisRequest {\n    constructor(requestId, text, isSSML, cb, err, dataStream) {\n        this.requestId = requestId;\n        this.text = text;\n        this.isSSML = isSSML;\n        this.cb = cb;\n        this.err = err;\n        this.dataStream = dataStream;\n    }\n}\n\n//# sourceMappingURL=SpeechSynthesizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ForceDictationPropertyName, OutputFormatPropertyName, ServicePropertiesPropertyName } from \"../common.speech/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { OutputFormat, ProfanityOption, PropertyCollection, PropertyId, SpeechConfig, SpeechSynthesisOutputFormat, } from \"./Exports\";\n/**\n * Speech translation configuration.\n * @class SpeechTranslationConfig\n */\nexport class SpeechTranslationConfig extends SpeechConfig {\n    /**\n     * Creates an instance of recognizer config.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.\n     * @member SpeechTranslationConfig.fromSubscription\n     * @function\n     * @public\n     * @param {string} subscriptionKey - The subscription key.\n     * @param {string} region - The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n     * @returns {SpeechTranslationConfig} The speech translation config.\n     */\n    static fromSubscription(subscriptionKey, region) {\n        Contracts.throwIfNullOrWhitespace(subscriptionKey, \"subscriptionKey\");\n        Contracts.throwIfNullOrWhitespace(region, \"region\");\n        const ret = new SpeechTranslationConfigImpl();\n        ret.properties.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n        ret.properties.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n        return ret;\n    }\n    /**\n     * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.\n     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token\n     *       expires, the caller needs to refresh it by setting the property authorizationToken with a new\n     *       valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance\n     *       will encounter errors during recognition.\n     * As configuration values are copied when creating a new recognizer, the new token value will not apply\n     * to recognizers that have already been created.\n     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer\n     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.\n     * @member SpeechTranslationConfig.fromAuthorizationToken\n     * @function\n     * @public\n     * @param {string} authorizationToken - The authorization token.\n     * @param {string} region - The region name (see the <a href=\"https://aka.ms/csspeech/region\">region page</a>).\n     * @returns {SpeechTranslationConfig} The speech translation config.\n     */\n    static fromAuthorizationToken(authorizationToken, region) {\n        Contracts.throwIfNullOrWhitespace(authorizationToken, \"authorizationToken\");\n        Contracts.throwIfNullOrWhitespace(region, \"region\");\n        const ret = new SpeechTranslationConfigImpl();\n        ret.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, authorizationToken);\n        ret.properties.setProperty(PropertyId.SpeechServiceConnection_Region, region);\n        return ret;\n    }\n    /**\n     * Creates an instance of the speech config with specified host and subscription key.\n     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.\n     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.\n     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.\n     * Note: To use an authorization token with fromHost, use fromHost(URL),\n     * and then set the AuthorizationToken property on the created SpeechConfig instance.\n     * Note: Added in version 1.9.0.\n     * @member SpeechConfig.fromHost\n     * @function\n     * @public\n     * @param {URL} host - The service endpoint to connect to. Format is \"protocol://host:port\" where \":port\" is optional.\n     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.\n     * @returns {SpeechConfig} A speech factory instance.\n     */\n    static fromHost(hostName, subscriptionKey) {\n        Contracts.throwIfNull(hostName, \"hostName\");\n        const speechImpl = new SpeechTranslationConfigImpl();\n        speechImpl.setProperty(PropertyId.SpeechServiceConnection_Host, hostName.protocol + \"//\" + hostName.hostname + (hostName.port === \"\" ? \"\" : \":\" + hostName.port));\n        if (undefined !== subscriptionKey) {\n            speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n        }\n        return speechImpl;\n    }\n    /**\n     * Creates an instance of the speech translation config with specified endpoint and subscription key.\n     * This method is intended only for users who use a non-standard service endpoint or paramters.\n     * Note: The query properties specified in the endpoint URL are not changed, even if they are\n     *       set by any other APIs. For example, if language is defined in the uri as query parameter\n     *       \"language=de-DE\", and also set by the speechRecognitionLanguage property, the language\n     *       setting in uri takes precedence, and the effective language is \"de-DE\".\n     * Only the properties that are not specified in the endpoint URL can be set by other APIs.\n     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the\n     *       fromEndpoint method, and then set authorizationToken=\"token\" on the created SpeechConfig instance to\n     *       use the authorization token.\n     * @member SpeechTranslationConfig.fromEndpoint\n     * @function\n     * @public\n     * @param {URL} endpoint - The service endpoint to connect to.\n     * @param {string} subscriptionKey - The subscription key.\n     * @returns {SpeechTranslationConfig} A speech config instance.\n     */\n    static fromEndpoint(endpoint, subscriptionKey) {\n        Contracts.throwIfNull(endpoint, \"endpoint\");\n        Contracts.throwIfNull(subscriptionKey, \"subscriptionKey\");\n        const ret = new SpeechTranslationConfigImpl();\n        ret.properties.setProperty(PropertyId.SpeechServiceConnection_Endpoint, endpoint.href);\n        ret.properties.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey);\n        return ret;\n    }\n}\n/**\n * @private\n * @class SpeechTranslationConfigImpl\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class SpeechTranslationConfigImpl extends SpeechTranslationConfig {\n    constructor() {\n        super();\n        this.privSpeechProperties = new PropertyCollection();\n        this.outputFormat = OutputFormat.Simple;\n    }\n    /**\n     * Gets/Sets the authorization token.\n     * If this is set, subscription key is ignored.\n     * User needs to make sure the provided authorization token is valid and not expired.\n     * @member SpeechTranslationConfigImpl.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} value - The authorization token.\n     */\n    set authorizationToken(value) {\n        Contracts.throwIfNullOrWhitespace(value, \"value\");\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceAuthorization_Token, value);\n    }\n    /**\n     * Sets the speech recognition language.\n     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage\n     * @function\n     * @public\n     * @param {string} value - The authorization token.\n     */\n    set speechRecognitionLanguage(value) {\n        Contracts.throwIfNullOrWhitespace(value, \"value\");\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceConnection_RecoLanguage, value);\n    }\n    /**\n     * Gets the speech recognition language.\n     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage\n     * @function\n     * @public\n     * @return {string} The speechRecognitionLanguage.\n     */\n    get speechRecognitionLanguage() {\n        return this.privSpeechProperties.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n    }\n    /**\n     * @member SpeechTranslationConfigImpl.prototype.subscriptionKey\n     * @function\n     * @public\n     */\n    get subscriptionKey() {\n        return this.privSpeechProperties.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key]);\n    }\n    /**\n     * Gets the output format\n     * @member SpeechTranslationConfigImpl.prototype.outputFormat\n     * @function\n     * @public\n     */\n    get outputFormat() {\n        return OutputFormat[this.privSpeechProperties.getProperty(OutputFormatPropertyName, undefined)];\n    }\n    /**\n     * Gets/Sets the output format\n     * @member SpeechTranslationConfigImpl.prototype.outputFormat\n     * @function\n     * @public\n     */\n    set outputFormat(value) {\n        this.privSpeechProperties.setProperty(OutputFormatPropertyName, OutputFormat[value]);\n    }\n    /**\n     * Gets the endpoint id.\n     * @member SpeechTranslationConfigImpl.prototype.endpointId\n     * @function\n     * @public\n     */\n    get endpointId() {\n        return this.privSpeechProperties.getProperty(PropertyId.SpeechServiceConnection_EndpointId);\n    }\n    /**\n     * Gets/Sets the endpoint id.\n     * @member SpeechTranslationConfigImpl.prototype.endpointId\n     * @function\n     * @public\n     */\n    set endpointId(value) {\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceConnection_EndpointId, value);\n    }\n    /**\n     * Add a (text) target language to translate into.\n     * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage\n     * @function\n     * @public\n     * @param {string} value - The language such as de-DE\n     */\n    addTargetLanguage(value) {\n        Contracts.throwIfNullOrWhitespace(value, \"value\");\n        const languages = this.targetLanguages;\n        languages.push(value);\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(\",\"));\n    }\n    /**\n     * Gets the (text) target language to translate into.\n     * @member SpeechTranslationConfigImpl.prototype.targetLanguages\n     * @function\n     * @public\n     * @param {string} value - The language such as de-DE\n     */\n    get targetLanguages() {\n        if (this.privSpeechProperties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {\n            return this.privSpeechProperties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n        }\n        else {\n            return [];\n        }\n    }\n    /**\n     * Gets the voice name.\n     * @member SpeechTranslationConfigImpl.prototype.voiceName\n     * @function\n     * @public\n     */\n    get voiceName() {\n        return this.getProperty(PropertyId[PropertyId.SpeechServiceConnection_TranslationVoice]);\n    }\n    /**\n     * Gets/Sets the voice of the translated language, enable voice synthesis output.\n     * @member SpeechTranslationConfigImpl.prototype.voiceName\n     * @function\n     * @public\n     * @param {string} value - The name of the voice.\n     */\n    set voiceName(value) {\n        Contracts.throwIfNullOrWhitespace(value, \"value\");\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceConnection_TranslationVoice, value);\n    }\n    /**\n     * Provides the region.\n     * @member SpeechTranslationConfigImpl.prototype.region\n     * @function\n     * @public\n     * @returns {string} The region.\n     */\n    get region() {\n        return this.privSpeechProperties.getProperty(PropertyId.SpeechServiceConnection_Region);\n    }\n    setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {\n        this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName);\n        this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyPort], proxyPort);\n        this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName);\n        this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);\n    }\n    /**\n     * Gets an arbitrary property value.\n     * @member SpeechTranslationConfigImpl.prototype.getProperty\n     * @function\n     * @public\n     * @param {string} name - The name of the property.\n     * @param {string} def - The default value of the property in case it is not set.\n     * @returns {string} The value of the property.\n     */\n    getProperty(name, def) {\n        return this.privSpeechProperties.getProperty(name, def);\n    }\n    /**\n     * Gets/Sets an arbitrary property value.\n     * @member SpeechTranslationConfigImpl.prototype.setProperty\n     * @function\n     * @public\n     * @param {string} name - The name of the property.\n     * @param {string} value - The value of the property.\n     */\n    setProperty(name, value) {\n        this.privSpeechProperties.setProperty(name, value);\n    }\n    /**\n     * Provides access to custom properties.\n     * @member SpeechTranslationConfigImpl.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The properties.\n     */\n    get properties() {\n        return this.privSpeechProperties;\n    }\n    /**\n     * Dispose of associated resources.\n     * @member SpeechTranslationConfigImpl.prototype.close\n     * @function\n     * @public\n     */\n    close() {\n        return;\n    }\n    setServiceProperty(name, value, channel) {\n        const currentProperties = JSON.parse(this.privSpeechProperties.getProperty(ServicePropertiesPropertyName, \"{}\"));\n        currentProperties[name] = value;\n        this.privSpeechProperties.setProperty(ServicePropertiesPropertyName, JSON.stringify(currentProperties));\n    }\n    setProfanity(profanity) {\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceResponse_ProfanityOption, ProfanityOption[profanity]);\n    }\n    enableAudioLogging() {\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceConnection_EnableAudioLogging, \"true\");\n    }\n    requestWordLevelTimestamps() {\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, \"true\");\n    }\n    enableDictation() {\n        this.privSpeechProperties.setProperty(ForceDictationPropertyName, \"true\");\n    }\n    get speechSynthesisLanguage() {\n        return this.privSpeechProperties.getProperty(PropertyId.SpeechServiceConnection_SynthLanguage);\n    }\n    set speechSynthesisLanguage(language) {\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceConnection_SynthLanguage, language);\n    }\n    get speechSynthesisVoiceName() {\n        return this.privSpeechProperties.getProperty(PropertyId.SpeechServiceConnection_SynthVoice);\n    }\n    set speechSynthesisVoiceName(voice) {\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceConnection_SynthVoice, voice);\n    }\n    get speechSynthesisOutputFormat() {\n        return SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)];\n    }\n    set speechSynthesisOutputFormat(format) {\n        this.privSpeechProperties.setProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, SpeechSynthesisOutputFormat[format]);\n    }\n}\n\n//# sourceMappingURL=SpeechTranslationConfig.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConversationConnectionConfig, ConversationManager, ConversationRecognizerFactory, ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, InternalParticipants } from \"../../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../../common/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { ConversationParticipantsChangedEventArgs, ConversationTranslationEventArgs, Participant, ParticipantChangedReason, ProfanityOption, PropertyCollection, PropertyId, } from \"../Exports\";\nexport class Conversation {\n    constructor() { }\n    /**\n     * Create a conversation\n     * @param speechConfig\n     * @param cb\n     * @param err\n     */\n    static createConversationAsync(speechConfig, arg2, arg3, arg4) {\n        Contracts.throwIfNullOrUndefined(speechConfig, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"config\"));\n        Contracts.throwIfNullOrUndefined(speechConfig.region, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Region\"));\n        if (!speechConfig.subscriptionKey && !speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceAuthorization_Token])) {\n            Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Key\"));\n        }\n        if (typeof arg2 === \"string\") {\n            const conversationImpl = new ConversationImpl(speechConfig, arg2);\n            marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () { return; }))(), arg3, arg4);\n            return conversationImpl;\n        }\n        else {\n            const conversationImpl = new ConversationImpl(speechConfig);\n            const cb = arg2;\n            const err = arg3;\n            conversationImpl.createConversationAsync((() => {\n                if (!!cb) {\n                    cb();\n                }\n            }), (error) => {\n                if (!!err) {\n                    err(error);\n                }\n            });\n            return conversationImpl;\n        }\n    }\n}\n// tslint:disable-next-line:max-classes-per-file\nexport class ConversationImpl extends Conversation {\n    /**\n     * Create a conversation impl\n     * @param speechConfig\n     * @param {string} id - optional conversationId\n     */\n    constructor(speechConfig, id) {\n        super();\n        this.privIsDisposed = false;\n        this.privIsConnected = false;\n        this.privErrors = ConversationConnectionConfig.restErrors;\n        this.privConversationId = \"\";\n        /** websocket callbacks */\n        this.onConnected = (e) => {\n            this.privIsConnected = true;\n            try {\n                if (!!this.privConversationTranslator.sessionStarted) {\n                    this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);\n                }\n            }\n            catch (e) {\n                //\n            }\n        };\n        this.onDisconnected = (e) => __awaiter(this, void 0, void 0, function* () {\n            yield this.close(false);\n            try {\n                if (!!this.privConversationTranslator.sessionStopped) {\n                    this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);\n                }\n            }\n            catch (e) {\n                //\n            }\n        });\n        this.onCanceled = (r, e) => __awaiter(this, void 0, void 0, function* () {\n            yield this.close(false); // ?\n            try {\n                if (!!this.privConversationTranslator.canceled) {\n                    this.privConversationTranslator.canceled(this.privConversationTranslator, e);\n                }\n            }\n            catch (e) {\n                //\n            }\n        });\n        this.onParticipantUpdateCommandReceived = (r, e) => {\n            var _a, _b;\n            try {\n                const updatedParticipant = this.privParticipants.getParticipant(e.id);\n                if (updatedParticipant !== undefined) {\n                    switch (e.key) {\n                        case ConversationTranslatorCommandTypes.changeNickname:\n                            updatedParticipant.displayName = e.value;\n                            break;\n                        case ConversationTranslatorCommandTypes.setUseTTS:\n                            updatedParticipant.useTts = e.value;\n                            break;\n                        case ConversationTranslatorCommandTypes.setProfanityFiltering:\n                            updatedParticipant.profanity = e.value;\n                            break;\n                        case ConversationTranslatorCommandTypes.setMute:\n                            updatedParticipant.isMuted = e.value;\n                            break;\n                        case ConversationTranslatorCommandTypes.setTranslateToLanguages:\n                            updatedParticipant.translateToLanguages = e.value;\n                            break;\n                    }\n                    this.privParticipants.addOrUpdateParticipant(updatedParticipant);\n                    if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n                        (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated, [this.toParticipant(updatedParticipant)], e.sessionId));\n                    }\n                }\n            }\n            catch (e) {\n                //\n            }\n        };\n        this.onLockRoomCommandReceived = (r, e) => {\n            // TODO\n        };\n        this.onMuteAllCommandReceived = (r, e) => {\n            var _a, _b;\n            try {\n                this.privParticipants.participants.forEach((p) => p.isMuted = (p.isHost ? false : e.isMuted));\n                if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n                    (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated, this.toParticipants(false), e.sessionId));\n                }\n            }\n            catch (e) {\n                //\n            }\n        };\n        this.onParticipantJoinCommandReceived = (r, e) => {\n            var _a, _b;\n            try {\n                const newParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);\n                if (newParticipant !== undefined) {\n                    if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n                        (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, [this.toParticipant(newParticipant)], e.sessionId));\n                    }\n                }\n            }\n            catch (e) {\n                //\n            }\n        };\n        this.onParticipantLeaveCommandReceived = (r, e) => {\n            var _a, _b;\n            try {\n                const ejectedParticipant = this.privParticipants.getParticipant(e.participant.id);\n                if (ejectedParticipant !== undefined) {\n                    // remove the participant from the internal participants list\n                    this.privParticipants.deleteParticipant(e.participant.id);\n                    if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n                        // notify subscribers that the participant has left the conversation\n                        (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.LeftConversation, [this.toParticipant(ejectedParticipant)], e.sessionId));\n                    }\n                }\n            }\n            catch (e) {\n                //\n            }\n        };\n        this.onTranslationReceived = (r, e) => {\n            var _a, _b, _c, _d, _e, _f;\n            try {\n                switch (e.command) {\n                    case ConversationTranslatorMessageTypes.final:\n                        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.transcribed)) {\n                            (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.transcribed(this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n                        }\n                        break;\n                    case ConversationTranslatorMessageTypes.partial:\n                        if (!!((_c = this.privConversationTranslator) === null || _c === void 0 ? void 0 : _c.transcribing)) {\n                            (_d = this.privConversationTranslator) === null || _d === void 0 ? void 0 : _d.transcribing(this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n                        }\n                        break;\n                    case ConversationTranslatorMessageTypes.instantMessage:\n                        if (!!((_e = this.privConversationTranslator) === null || _e === void 0 ? void 0 : _e.textMessageReceived)) {\n                            (_f = this.privConversationTranslator) === null || _f === void 0 ? void 0 : _f.textMessageReceived(this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n                        }\n                        break;\n                }\n            }\n            catch (e) {\n                //\n            }\n        };\n        this.onParticipantsListReceived = (r, e) => {\n            var _a, _b, _c;\n            try {\n                // check if the session token needs to be updated\n                if (e.sessionToken !== undefined && e.sessionToken !== null) {\n                    this.privRoom.token = e.sessionToken;\n                }\n                // save the participants\n                this.privParticipants.participants = [...e.participants];\n                // enable the conversation\n                if (this.privParticipants.me !== undefined) {\n                    this.privIsReady = true;\n                }\n                if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n                    (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));\n                }\n                // if this is the host, update the nickname if needed\n                if (this.me.isHost) {\n                    const nickname = (_c = this.privConversationTranslator) === null || _c === void 0 ? void 0 : _c.properties.getProperty(PropertyId.ConversationTranslator_Name);\n                    if (nickname !== undefined && nickname.length > 0 && nickname !== this.me.displayName) {\n                        // issue a change nickname request\n                        this.changeNicknameAsync(nickname);\n                    }\n                }\n            }\n            catch (e) {\n                //\n            }\n        };\n        this.onConversationExpiration = (r, e) => {\n            var _a, _b;\n            try {\n                if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.conversationExpiration)) {\n                    (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.conversationExpiration(this.privConversationTranslator, e);\n                }\n            }\n            catch (e) {\n                //\n            }\n        };\n        this.privProperties = new PropertyCollection();\n        this.privManager = new ConversationManager();\n        // check the speech language\n        const language = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n        if (!language) {\n            speechConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], ConversationConnectionConfig.defaultLanguageCode);\n        }\n        this.privLanguage = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n        if (!id) {\n            // check the target language(s)\n            if (speechConfig.targetLanguages.length === 0) {\n                speechConfig.addTargetLanguage(this.privLanguage);\n            }\n            // check the profanity setting: speech and conversationTranslator should be in sync\n            const profanity = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceResponse_ProfanityOption]);\n            if (!profanity) {\n                speechConfig.setProfanity(ProfanityOption.Masked);\n            }\n            // check the nickname: it should pass this regex: ^\\w+([\\s-][\\w\\(\\)]+)*$\"\n            // TODO: specify the regex required. Nicknames must be unique or get the duplicate nickname error\n            // TODO: check what the max length is and if a truncation is required or if the service handles it without an error\n            let hostNickname = speechConfig.getProperty(PropertyId[PropertyId.ConversationTranslator_Name]);\n            if (hostNickname === undefined || hostNickname === null || hostNickname.length <= 1 || hostNickname.length > 50) {\n                hostNickname = \"Host\";\n            }\n            speechConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], hostNickname);\n        }\n        else {\n            this.privConversationId = id;\n        }\n        // save the speech config for future usage\n        this.privConfig = speechConfig;\n        // save the config properties\n        const configImpl = speechConfig;\n        Contracts.throwIfNull(configImpl, \"speechConfig\");\n        this.privProperties = configImpl.properties.clone();\n        this.privIsConnected = false;\n        this.privParticipants = new InternalParticipants();\n        this.privIsReady = false;\n        this.privTextMessageMaxLength = 1000;\n    }\n    set conversationTranslator(conversationTranslator) {\n        this.privConversationTranslator = conversationTranslator;\n    }\n    // get the internal data about a conversation\n    get room() {\n        return this.privRoom;\n    }\n    // get the wrapper for connecting to the websockets\n    get connection() {\n        return this.privConversationRecognizer; // this.privConnection;\n    }\n    // get / set the speech auth token\n    get authorizationToken() {\n        return this.privToken;\n    }\n    set authorizationToken(value) {\n        Contracts.throwIfNullOrWhitespace(value, \"authorizationToken\");\n        this.privToken = value;\n    }\n    // get the config\n    get config() {\n        return this.privConfig;\n    }\n    // get the conversation Id\n    get conversationId() {\n        return this.privRoom ? this.privRoom.roomId : this.privConversationId;\n    }\n    // get the properties\n    get properties() {\n        return this.privProperties;\n    }\n    // get the speech language\n    get speechRecognitionLanguage() {\n        return this.privLanguage;\n    }\n    get isMutedByHost() {\n        var _a, _b;\n        return ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost) ? false : (_b = this.privParticipants.me) === null || _b === void 0 ? void 0 : _b.isMuted;\n    }\n    get isConnected() {\n        return this.privIsConnected && this.privIsReady;\n    }\n    get participants() {\n        return this.toParticipants(true);\n    }\n    get me() {\n        return this.toParticipant(this.privParticipants.me);\n    }\n    get host() {\n        return this.toParticipant(this.privParticipants.host);\n    }\n    /**\n     * Create a new conversation as Host\n     * @param cb\n     * @param err\n     */\n    createConversationAsync(cb, err) {\n        try {\n            if (!!this.privConversationRecognizer) {\n                this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n            }\n            this.privManager.createOrJoin(this.privProperties, undefined, ((room) => {\n                if (!room) {\n                    this.handleError(new Error(this.privErrors.permissionDeniedConnect), err);\n                }\n                this.privRoom = room;\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Starts a new conversation as host.\n     * @param cb\n     * @param err\n     */\n    startConversationAsync(cb, err) {\n        try {\n            // check if there is already a recognizer\n            if (!!this.privConversationRecognizer) {\n                this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n            }\n            // check if there is conversation data available\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);\n            // connect to the conversation websocket\n            this.privParticipants.meId = this.privRoom.participantId;\n            this.privConversationRecognizer = ConversationRecognizerFactory.fromConfig(this, this.privConfig);\n            // Because ConversationTranslator manually sets up and manages the connection, Conversation\n            // has to forward serviceRecognizer connection events that usually get passed automatically\n            this.privConversationRecognizer.connected = this.onConnected;\n            this.privConversationRecognizer.disconnected = this.onDisconnected;\n            this.privConversationRecognizer.canceled = this.onCanceled;\n            this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;\n            this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;\n            this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;\n            this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;\n            this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;\n            this.privConversationRecognizer.translationReceived = this.onTranslationReceived;\n            this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;\n            this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;\n            this.privConversationRecognizer.connect(this.privRoom.token, (() => {\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Join a conversation as a participant.\n     * @param { IParticipant } participant - participant to add\n     * @param cb\n     * @param err\n     */\n    addParticipantAsync(participant, cb, err) {\n        Contracts.throwIfNullOrUndefined(participant, \"Participant\");\n        marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);\n    }\n    /**\n     * Join a conversation as a participant.\n     * @param conversation\n     * @param nickname\n     * @param lang\n     * @param cb\n     * @param err\n     */\n    joinConversationAsync(conversationId, nickname, lang, cb, err) {\n        try {\n            // TODO\n            // if (!!this.privConversationRecognizer) {\n            //     throw new Error(this.privErrors.permissionDeniedStart);\n            // }\n            Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversationId\"));\n            Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n            Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace(\"{arg}\", \"language\"));\n            // join the conversation\n            this.privManager.createOrJoin(this.privProperties, conversationId, ((room) => {\n                Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);\n                this.privRoom = room;\n                this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;\n                // join callback\n                if (!!cb) {\n                    cb(room.cognitiveSpeechAuthToken);\n                }\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Deletes a conversation\n     * @param cb\n     * @param err\n     */\n    deleteConversationAsync(cb, err) {\n        marshalPromiseToCallbacks(this.deleteConversationImplAsync(), cb, err);\n    }\n    deleteConversationImplAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);\n            Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);\n            yield this.privManager.leave(this.privProperties, this.privRoom.token);\n            this.dispose();\n        });\n    }\n    /**\n     * Issues a request to close the client websockets\n     * @param cb\n     * @param err\n     */\n    endConversationAsync(cb, err) {\n        marshalPromiseToCallbacks(this.endConversationImplAsync(), cb, err);\n    }\n    endConversationImplAsync() {\n        return this.close(true);\n    }\n    /**\n     * Issues a request to lock the conversation\n     * @param cb\n     * @param err\n     */\n    lockConversationAsync(cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n            if (!this.canSendAsHost) {\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"lock\")), err);\n            }\n            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getLockCommand(true), (() => {\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Issues a request to mute the conversation\n     * @param cb\n     * @param err\n     */\n    muteAllParticipantsAsync(cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n            Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n            // check the user's permissions\n            if (!this.canSendAsHost) {\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"mute\")), err);\n            }\n            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMuteAllCommand(true), (() => {\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Issues a request to mute a participant in the conversation\n     * @param userId\n     * @param cb\n     * @param err\n     */\n    muteParticipantAsync(userId, cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n            Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n            // check the connection is open (host + participant can perform the mute command)\n            if (!this.canSend) {\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n            }\n            // if not host, check the participant is not muting another participant\n            if (!this.me.isHost && this.me.id !== userId) {\n                this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n            }\n            // check the user exists\n            const exists = this.privParticipants.getParticipantIndex(userId);\n            if (exists === -1) {\n                this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n            }\n            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMuteCommand(userId, true), (() => {\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Issues a request to remove a participant from the conversation\n     * @param userId\n     * @param cb\n     * @param err\n     */\n    removeParticipantAsync(userId, cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            if (!!this.privTranscriberRecognizer && userId.hasOwnProperty(\"id\")) {\n                // Assume this is a transcription participant\n                marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb, err);\n            }\n            else {\n                Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n                Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n                if (!this.canSendAsHost) {\n                    this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"remove\")), err);\n                }\n                let participantId = \"\";\n                if (typeof userId === \"string\") {\n                    participantId = userId;\n                }\n                else if (userId.hasOwnProperty(\"id\")) {\n                    const participant = userId;\n                    participantId = participant.id;\n                }\n                else if (userId.hasOwnProperty(\"userId\")) {\n                    const user = userId;\n                    participantId = user.userId;\n                }\n                Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n                // check the participant exists\n                const index = this.participants.findIndex((p) => p.id === participantId);\n                if (index === -1) {\n                    this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n                }\n                (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getEjectCommand(participantId), (() => {\n                    this.handleCallback(cb, err);\n                }), ((error) => {\n                    this.handleError(error, err);\n                }));\n            }\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Issues a request to unlock the conversation\n     * @param cb\n     * @param err\n     */\n    unlockConversationAsync(cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n            if (!this.canSendAsHost) {\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unlock\")), err);\n            }\n            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getLockCommand(false), (() => {\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Issues a request to unmute all participants in the conversation\n     * @param cb\n     * @param err\n     */\n    unmuteAllParticipantsAsync(cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n            if (!this.canSendAsHost) {\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unmute all\")), err);\n            }\n            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMuteAllCommand(false), (() => {\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Issues a request to unmute a participant in the conversation\n     * @param userId\n     * @param cb\n     * @param err\n     */\n    unmuteParticipantAsync(userId, cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n            Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n            // check the connection is open (host + participant can perform the mute command)\n            if (!this.canSend) {\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n            }\n            // if not host, check the participant is not muting another participant\n            if (!this.me.isHost && this.me.id !== userId) {\n                this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n            }\n            // check the user exists\n            const exists = this.privParticipants.getParticipantIndex(userId);\n            if (exists === -1) {\n                this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n            }\n            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMuteCommand(userId, false), (() => {\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Send a text message\n     * @param message\n     * @param cb\n     * @param err\n     */\n    sendTextMessageAsync(message, cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n            Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", \"message\"));\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n            if (!this.canSend) {\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n            }\n            // TODO: is a max length check required?\n            if (message.length > this.privTextMessageMaxLength) {\n                this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"message length\")), err);\n            }\n            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMessageCommand(message), (() => {\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Change nickname\n     * @param message\n     * @param cb\n     * @param err\n     */\n    changeNicknameAsync(nickname, cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfDisposed(this.privIsDisposed);\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n            Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n            if (!this.canSend) {\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n            }\n            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getChangeNicknameCommand(nickname), (() => {\n                this.handleCallback(cb, err);\n            }), ((error) => {\n                this.handleError(error, err);\n            }));\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    isDisposed() {\n        return this.privIsDisposed;\n    }\n    dispose(reason) {\n        var _a;\n        if (this.isDisposed) {\n            return;\n        }\n        this.privIsDisposed = true;\n        (_a = this.config) === null || _a === void 0 ? void 0 : _a.close();\n        this.privConfig = undefined;\n        this.privLanguage = undefined;\n        this.privProperties = undefined;\n        this.privRoom = undefined;\n        this.privToken = undefined;\n        this.privManager = undefined;\n        this.privConversationRecognizer = undefined;\n        this.privIsConnected = false;\n        this.privIsReady = false;\n        this.privParticipants = undefined;\n    }\n    get transcriberRecognizer() {\n        return this.privTranscriberRecognizer;\n    }\n    connectTranscriberRecognizer(recognizer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!!this.privTranscriberRecognizer) {\n                yield this.privTranscriberRecognizer.close();\n            }\n            this.privTranscriberRecognizer = recognizer;\n            this.privTranscriberRecognizer.conversation = this;\n        });\n    }\n    get conversationInfo() {\n        const convId = this.conversationId;\n        const p = this.participants.map((part) => {\n            return {\n                id: part.id,\n                preferredLanguage: part.preferredLanguage,\n                voice: part.voice\n            };\n        });\n        const props = {};\n        for (const key of ConversationConnectionConfig.transcriptionEventKeys) {\n            const val = this.properties.getProperty(key, \"\");\n            if (val !== \"\") {\n                props[key] = val;\n            }\n        }\n        const info = { id: convId, participants: p, conversationProperties: props };\n        return info;\n    }\n    getKeepAlive() {\n        return JSON.stringify({\n            // tslint:disable-next-line: object-literal-shorthand\n            id: \"0\",\n            nickname: this.me.displayName,\n            participantId: this.privRoom.participantId,\n            roomId: this.privRoom.roomId,\n            type: ConversationTranslatorMessageTypes.keepAlive\n        });\n    }\n    addParticipantImplAsync(participant) {\n        const newParticipant = this.privParticipants.addOrUpdateParticipant(participant);\n        if (newParticipant !== undefined) {\n            if (!!this.privTranscriberRecognizer) {\n                const conversationInfo = this.conversationInfo;\n                conversationInfo.participants = [participant];\n                return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"join\");\n            }\n        }\n    }\n    removeParticipantImplAsync(participant) {\n        this.privParticipants.deleteParticipant(participant.id);\n        const conversationInfo = this.conversationInfo;\n        conversationInfo.participants = [participant];\n        return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"leave\");\n    }\n    close(dispose) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this.privIsConnected = false;\n                yield this.privConversationRecognizer.close();\n                yield ((_a = this.privTranscriberRecognizer) === null || _a === void 0 ? void 0 : _a.close());\n                this.privConversationRecognizer = undefined;\n                (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.dispose();\n            }\n            catch (e) {\n                // ignore error\n            }\n            if (dispose) {\n                this.dispose();\n            }\n        });\n    }\n    /** Helpers */\n    get canSend() {\n        var _a;\n        return this.privIsConnected && !((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isMuted);\n    }\n    get canSendAsHost() {\n        var _a;\n        return this.privIsConnected && ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost);\n    }\n    handleCallback(cb, err) {\n        if (!!cb) {\n            try {\n                cb();\n            }\n            catch (e) {\n                if (!!err) {\n                    err(e);\n                }\n            }\n            cb = undefined;\n        }\n    }\n    handleError(error, err) {\n        if (!!err) {\n            if (error instanceof Error) {\n                const typedError = error;\n                err(typedError.name + \": \" + typedError.message);\n            }\n            else {\n                err(error);\n            }\n        }\n    }\n    /** Participant Helpers */\n    toParticipants(includeHost) {\n        const participants = this.privParticipants.participants.map((p) => {\n            return this.toParticipant(p);\n        });\n        if (!includeHost) {\n            return participants.filter((p) => p.isHost === false);\n        }\n        else {\n            return participants;\n        }\n    }\n    toParticipant(p) {\n        return new Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);\n    }\n    getMuteAllCommand(isMuted) {\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n        return JSON.stringify({\n            command: ConversationTranslatorCommandTypes.setMuteAll,\n            // tslint:disable-next-line: object-literal-shorthand\n            participantId: this.privRoom.participantId,\n            roomid: this.privRoom.roomId,\n            type: ConversationTranslatorMessageTypes.participantCommand,\n            value: isMuted\n        });\n    }\n    getMuteCommand(participantId, isMuted) {\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n        Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\n        return JSON.stringify({\n            command: ConversationTranslatorCommandTypes.setMute,\n            // tslint:disable-next-line: object-literal-shorthand\n            participantId: participantId,\n            roomid: this.privRoom.roomId,\n            type: ConversationTranslatorMessageTypes.participantCommand,\n            value: isMuted\n        });\n    }\n    getLockCommand(isLocked) {\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n        return JSON.stringify({\n            command: ConversationTranslatorCommandTypes.setLockState,\n            // tslint:disable-next-line: object-literal-shorthand\n            participantId: this.privRoom.participantId,\n            roomid: this.privRoom.roomId,\n            type: ConversationTranslatorMessageTypes.participantCommand,\n            value: isLocked\n        });\n    }\n    getEjectCommand(participantId) {\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n        Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\n        return JSON.stringify({\n            command: ConversationTranslatorCommandTypes.ejectParticipant,\n            // tslint:disable-next-line: object-literal-shorthand\n            participantId: participantId,\n            roomid: this.privRoom.roomId,\n            type: ConversationTranslatorMessageTypes.participantCommand,\n        });\n    }\n    getChangeNicknameCommand(nickname) {\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n        Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n        return JSON.stringify({\n            command: ConversationTranslatorCommandTypes.changeNickname,\n            nickname,\n            // tslint:disable-next-line: object-literal-shorthand\n            participantId: this.privRoom.participantId,\n            roomid: this.privRoom.roomId,\n            type: ConversationTranslatorMessageTypes.participantCommand,\n            value: nickname\n        });\n    }\n    getMessageCommand(message) {\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n        Contracts.throwIfNullOrWhitespace(message, \"message\");\n        return JSON.stringify({\n            // tslint:disable-next-line: object-literal-shorthand\n            participantId: this.privRoom.participantId,\n            roomId: this.privRoom.roomId,\n            text: message,\n            type: ConversationTranslatorMessageTypes.instantMessage\n        });\n    }\n}\n\n//# sourceMappingURL=Conversation.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class ConversationCommon {\n    constructor(audioConfig) {\n        this.privAudioConfig = audioConfig;\n    }\n    handleCallback(cb, err) {\n        if (!!cb) {\n            try {\n                cb();\n            }\n            catch (e) {\n                if (!!err) {\n                    err(e);\n                }\n            }\n            cb = undefined;\n        }\n    }\n    handleError(error, err) {\n        if (!!err) {\n            if (error instanceof Error) {\n                const typedError = error;\n                err(typedError.name + \": \" + typedError.message);\n            }\n            else {\n                err(error);\n            }\n        }\n    }\n}\n\n//# sourceMappingURL=ConversationCommon.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nimport { SessionEventArgs } from \"../Exports\";\nexport class ConversationExpirationEventArgs extends SessionEventArgs {\n    constructor(expirationTime, sessionId) {\n        super(sessionId);\n        this.privExpirationTime = expirationTime;\n    }\n    /** How much longer until the conversation expires (in minutes). */\n    get expirationTime() {\n        return this.privExpirationTime;\n    }\n}\n\n//# sourceMappingURL=ConversationExpirationEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nimport { SessionEventArgs } from \"../Exports\";\nexport class ConversationParticipantsChangedEventArgs extends SessionEventArgs {\n    constructor(reason, participants, sessionId) {\n        super(sessionId);\n        this.privReason = reason;\n        this.privParticipant = participants;\n    }\n    get reason() {\n        return this.privReason;\n    }\n    get participants() {\n        return this.privParticipant;\n    }\n}\n\n//# sourceMappingURL=ConversationParticipantsChangedEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { TranscriberRecognizer } from \"../../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../../common/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { PropertyCollection, PropertyId, } from \"../Exports\";\nexport class ConversationTranscriber {\n    /**\n     * ConversationTranscriber constructor.\n     * @constructor\n     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer\n     */\n    constructor(audioConfig) {\n        this.privAudioConfig = audioConfig;\n        this.privProperties = new PropertyCollection();\n        this.privRecognizer = undefined;\n        this.privDisposedRecognizer = false;\n    }\n    /**\n     * @param {Conversation} converation - conversation to be recognized\n     */\n    joinConversationAsync(conversation, cb, err) {\n        const conversationImpl = conversation;\n        Contracts.throwIfNullOrUndefined(conversationImpl, \"Conversation\");\n        // ref the conversation object\n        // create recognizer and subscribe to recognizer events\n        this.privRecognizer = new TranscriberRecognizer(conversation.config, this.privAudioConfig);\n        Contracts.throwIfNullOrUndefined(this.privRecognizer, \"Recognizer\");\n        this.privRecognizer.connectCallbacks(this);\n        marshalPromiseToCallbacks(conversationImpl.connectTranscriberRecognizer(this.privRecognizer), cb, err);\n    }\n    /**\n     * Gets the authorization token used to communicate with the service.\n     * @member ConversationTranscriber.prototype.authorizationToken\n     * @function\n     * @public\n     * @returns {string} Authorization token.\n     */\n    get authorizationToken() {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    /**\n     * Gets/Sets the authorization token used to communicate with the service.\n     * @member ConversationTranscriber.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} token - Authorization token.\n     */\n    set authorizationToken(token) {\n        Contracts.throwIfNullOrWhitespace(token, \"token\");\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, token);\n    }\n    /**\n     * Gets the spoken language of recognition.\n     * @member ConversationTranscriber.prototype.speechRecognitionLanguage\n     * @function\n     * @public\n     * @returns {string} The spoken language of recognition.\n     */\n    get speechRecognitionLanguage() {\n        Contracts.throwIfDisposed(this.privDisposedRecognizer);\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n    }\n    /**\n     * The collection of properties and their values defined for this ConversationTranscriber.\n     * @member ConversationTranscriber.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The collection of properties and their values defined for this ConversationTranscriber.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    /**\n     * Starts conversation transcription, until stopTranscribingAsync() is called.\n     * User must subscribe to events to receive transcription results.\n     * @member ConversationTranscriber.prototype.startTranscribingAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the transcription has started.\n     * @param err - Callback invoked in case of an error.\n     */\n    startTranscribingAsync(cb, err) {\n        this.privRecognizer.startContinuousRecognitionAsync(cb, err);\n    }\n    /**\n     * Starts conversation transcription, until stopTranscribingAsync() is called.\n     * User must subscribe to events to receive transcription results.\n     * @member ConversationTranscriber.prototype.stopTranscribingAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the transcription has started.\n     * @param err - Callback invoked in case of an error.\n     */\n    stopTranscribingAsync(cb, err) {\n        this.privRecognizer.stopContinuousRecognitionAsync(cb, err);\n    }\n    /**\n     * Leave the current conversation. After this is called, you will no longer receive any events.\n     */\n    leaveConversationAsync(cb, err) {\n        this.privRecognizer.disconnectCallbacks();\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () { return; }))(), cb, err);\n    }\n    /**\n     * closes all external resources held by an instance of this class.\n     * @member ConversationTranscriber.prototype.close\n     * @function\n     * @public\n     */\n    close(cb, errorCb) {\n        Contracts.throwIfDisposed(this.privDisposedRecognizer);\n        marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n    }\n    /**\n     * Disposes any resources held by the object.\n     * @member ConversationTranscriber.prototype.dispose\n     * @function\n     * @public\n     * @param {boolean} disposing - true if disposing the object.\n     */\n    dispose(disposing) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privDisposedRecognizer) {\n                return;\n            }\n            if (!!this.privRecognizer) {\n                yield this.privRecognizer.close();\n                this.privRecognizer = undefined;\n            }\n            if (disposing) {\n                this.privDisposedRecognizer = true;\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=ConversationTranscriber.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nimport { CancellationEventArgsBase } from \"../CancellationEventArgsBase\";\nexport class ConversationTranslationCanceledEventArgs extends CancellationEventArgsBase {\n}\n\n//# sourceMappingURL=ConversationTranslationCanceledEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nimport { RecognitionEventArgs } from \"../Exports\";\nexport class ConversationTranslationEventArgs extends RecognitionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {ConversationTranslationResult} result - The translation recognition result.\n     * @param {number} offset - The offset.\n     * @param {string} sessionId - The session id.\n     */\n    constructor(result, offset, sessionId) {\n        super(offset, sessionId);\n        this.privResult = result;\n    }\n    /**\n     * Specifies the recognition result.\n     * @returns {ConversationTranslationResult} the recognition result.\n     */\n    get result() {\n        return this.privResult;\n    }\n}\n\n//# sourceMappingURL=ConversationTranslationEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nimport { TranslationRecognitionResult } from \"../TranslationRecognitionResult\";\nexport class ConversationTranslationResult extends TranslationRecognitionResult {\n    constructor(participantId, translations, originalLanguage, resultId, reason, text, duration, offset, errorDetails, json, properties) {\n        super(translations, resultId, reason, text, duration, offset, errorDetails, json, properties);\n        this.privId = participantId;\n        this.privOrigLang = originalLanguage;\n    }\n    /**\n     * The unique identifier for the participant this result is for.\n     */\n    get participantId() {\n        return this.privId;\n    }\n    /**\n     * The original language this result was in.\n     */\n    get originalLang() {\n        return this.privOrigLang;\n    }\n}\n\n//# sourceMappingURL=ConversationTranslationResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConversationConnectionConfig } from \"../../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../../common/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { AudioConfig, CancellationErrorCode, CancellationReason, ProfanityOption, PropertyCollection, PropertyId, SpeechTranslationConfig, TranslationRecognizer } from \"../Exports\";\nimport { ConversationImpl } from \"./Conversation\";\nimport { ConversationCommon, ConversationTranslationCanceledEventArgs, } from \"./Exports\";\nexport var SpeechState;\n(function (SpeechState) {\n    SpeechState[SpeechState[\"Inactive\"] = 0] = \"Inactive\";\n    SpeechState[SpeechState[\"Connecting\"] = 1] = \"Connecting\";\n    SpeechState[SpeechState[\"Connected\"] = 2] = \"Connected\";\n})(SpeechState || (SpeechState = {}));\n// tslint:disable:max-classes-per-file\n// child class of TranslationRecognizer meant only for use with ConversationTranslator\nclass ConversationTranslationRecognizer extends TranslationRecognizer {\n    constructor(speechConfig, audioConfig, translator) {\n        super(speechConfig, audioConfig);\n        this.privSpeechState = SpeechState.Inactive;\n        if (!!translator) {\n            this.privTranslator = translator;\n            this.sessionStarted = () => {\n                this.privSpeechState = SpeechState.Connected;\n            };\n            this.sessionStopped = () => {\n                this.privSpeechState = SpeechState.Inactive;\n            };\n            this.recognized = (tr, e) => __awaiter(this, void 0, void 0, function* () {\n                // TODO: add support for getting recognitions from here if own speech\n                var _a;\n                // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\n                if ((_a = e.result) === null || _a === void 0 ? void 0 : _a.errorDetails) {\n                    yield this.cancelSpeech();\n                    // TODO: format the error message contained in 'errorDetails'\n                    this.fireCancelEvent(e.result.errorDetails);\n                }\n            });\n            this.canceled = (r, e) => __awaiter(this, void 0, void 0, function* () {\n                if (this.privSpeechState !== SpeechState.Inactive) {\n                    try {\n                        yield this.cancelSpeech();\n                    }\n                    catch (error) {\n                        this.privSpeechState = SpeechState.Inactive;\n                    }\n                }\n            });\n        }\n    }\n    get state() {\n        return this.privSpeechState;\n    }\n    set state(newState) {\n        this.privSpeechState = newState;\n    }\n    onConnection() {\n        this.privSpeechState = SpeechState.Connected;\n    }\n    onDisconnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.privSpeechState = SpeechState.Inactive;\n            yield this.cancelSpeech();\n        });\n    }\n    /**\n     * Fire a cancel event\n     * @param error\n     */\n    fireCancelEvent(error) {\n        var _a, _b, _c;\n        try {\n            if (!!this.privTranslator.canceled) {\n                const cancelEvent = new ConversationTranslationCanceledEventArgs((_a = error === null || error === void 0 ? void 0 : error.reason) !== null && _a !== void 0 ? _a : CancellationReason.Error, (_b = error === null || error === void 0 ? void 0 : error.errorDetails) !== null && _b !== void 0 ? _b : error, (_c = error === null || error === void 0 ? void 0 : error.errorCode) !== null && _c !== void 0 ? _c : CancellationErrorCode.RuntimeError, undefined, error === null || error === void 0 ? void 0 : error.sessionId);\n                this.privTranslator.canceled(this.privTranslator, cancelEvent);\n            }\n        }\n        catch (e) {\n            //\n        }\n    }\n    cancelSpeech() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this.stopContinuousRecognitionAsync();\n                yield ((_a = this.privReco) === null || _a === void 0 ? void 0 : _a.disconnect());\n                this.privSpeechState = SpeechState.Inactive;\n            }\n            catch (e) {\n                // ignore the error\n            }\n        });\n    }\n}\n/***\n * Join, leave or connect to a conversation.\n */\nexport class ConversationTranslator extends ConversationCommon {\n    constructor(audioConfig) {\n        super(audioConfig);\n        this.privIsDisposed = false;\n        this.privIsSpeaking = false;\n        this.privErrors = ConversationConnectionConfig.restErrors;\n        this.privPlaceholderKey = \"abcdefghijklmnopqrstuvwxyz012345\";\n        this.privPlaceholderRegion = \"westus\";\n        this.privProperties = new PropertyCollection();\n    }\n    get properties() {\n        return this.privProperties;\n    }\n    get speechRecognitionLanguage() {\n        return this.privSpeechRecognitionLanguage;\n    }\n    get participants() {\n        var _a;\n        return (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.participants;\n    }\n    joinConversationAsync(conversation, nickname, param1, param2, param3) {\n        try {\n            if (typeof conversation === \"string\") {\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n                if (!!this.privConversation) {\n                    this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\n                }\n                let lang = param1;\n                if (lang === undefined || lang === null || lang === \"\") {\n                    lang = ConversationConnectionConfig.defaultLanguageCode;\n                }\n                // create a placeholder config\n                this.privSpeechTranslationConfig = SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);\n                this.privSpeechTranslationConfig.setProfanity(ProfanityOption.Masked);\n                this.privSpeechTranslationConfig.addTargetLanguage(lang);\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], lang);\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], nickname);\n                const endpoint = this.privProperties.getProperty(PropertyId.ConversationTranslator_Host);\n                if (endpoint) {\n                    this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Host], endpoint);\n                }\n                const speechEndpointHost = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Host);\n                if (speechEndpointHost) {\n                    this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], speechEndpointHost);\n                }\n                // join the conversation\n                this.privConversation = new ConversationImpl(this.privSpeechTranslationConfig);\n                this.privConversation.conversationTranslator = this;\n                this.privConversation.joinConversationAsync(conversation, nickname, lang, ((result) => {\n                    if (!result) {\n                        this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);\n                    }\n                    this.privSpeechTranslationConfig.authorizationToken = result;\n                    // connect to the ws\n                    this.privConversation.startConversationAsync((() => {\n                        this.handleCallback(param2, param3);\n                    }), ((error) => {\n                        this.handleError(error, param3);\n                    }));\n                }), ((error) => {\n                    this.handleError(error, param3);\n                }));\n            }\n            else if (typeof conversation === \"object\") {\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n                // save the nickname\n                this.privProperties.setProperty(PropertyId.ConversationTranslator_Name, nickname);\n                // ref the conversation object\n                this.privConversation = conversation;\n                // ref the conversation translator object\n                this.privConversation.conversationTranslator = this;\n                Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\n                Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n                this.privSpeechTranslationConfig = conversation.config;\n                this.handleCallback(param1, param2);\n            }\n            else {\n                this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")), param2);\n            }\n        }\n        catch (error) {\n            this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\n        }\n    }\n    /**\n     * Leave the conversation\n     * @param cb\n     * @param err\n     */\n    leaveConversationAsync(cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            // stop the speech websocket\n            yield this.cancelSpeech();\n            // stop the websocket\n            yield this.privConversation.endConversationImplAsync();\n            // https delete request\n            yield this.privConversation.deleteConversationImplAsync();\n            this.dispose();\n        }))(), cb, err);\n    }\n    /**\n     * Send a text message\n     * @param message\n     * @param cb\n     * @param err\n     */\n    sendTextMessageAsync(message, cb, err) {\n        var _a;\n        try {\n            Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n            Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\n            (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.sendTextMessageAsync(message, cb, err);\n        }\n        catch (error) {\n            this.handleError(error, err);\n        }\n    }\n    /**\n     * Start speaking\n     * @param cb\n     * @param err\n     */\n    startTranscribingAsync(cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            try {\n                Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n                Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n                if (this.privCTRecognizer === undefined) {\n                    yield this.connectTranslatorRecognizer();\n                }\n                Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);\n                if (!this.canSpeak) {\n                    this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n                }\n                yield this.startContinuousRecognition();\n                this.privIsSpeaking = true;\n            }\n            catch (error) {\n                this.privIsSpeaking = false;\n                yield this.cancelSpeech();\n                throw error;\n            }\n        }))(), cb, err);\n    }\n    /**\n     * Stop speaking\n     * @param cb\n     * @param err\n     */\n    stopTranscribingAsync(cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!this.privIsSpeaking) {\n                    // stop speech\n                    yield this.cancelSpeech();\n                    return;\n                }\n                // stop the recognition but leave the websocket open\n                this.privIsSpeaking = false;\n                yield new Promise((resolve, reject) => {\n                    var _a;\n                    (_a = this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.stopContinuousRecognitionAsync(resolve, reject);\n                });\n            }\n            catch (error) {\n                yield this.cancelSpeech();\n            }\n        }))(), cb, err);\n    }\n    isDisposed() {\n        return this.privIsDisposed;\n    }\n    dispose(reason, success, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (this.isDisposed && !this.privIsSpeaking) {\n                return;\n            }\n            yield this.cancelSpeech();\n            this.privIsDisposed = true;\n            (_a = this.privSpeechTranslationConfig) === null || _a === void 0 ? void 0 : _a.close();\n            this.privSpeechRecognitionLanguage = undefined;\n            this.privProperties = undefined;\n            this.privAudioConfig = undefined;\n            this.privSpeechTranslationConfig = undefined;\n            (_b = this.privConversation) === null || _b === void 0 ? void 0 : _b.dispose();\n            this.privConversation = undefined;\n        }))(), success, err);\n    }\n    /**\n     * Cancel the speech websocket\n     */\n    cancelSpeech() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this.privIsSpeaking = false;\n                yield ((_a = this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.onDisconnection());\n                this.privCTRecognizer = undefined;\n            }\n            catch (e) {\n                // ignore the error\n            }\n        });\n    }\n    /**\n     * Connect to the speech translation recognizer.\n     * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\n     * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\n     * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\n     * @param cb\n     * @param err\n     */\n    connectTranslatorRecognizer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.privAudioConfig === undefined) {\n                    this.privAudioConfig = AudioConfig.fromDefaultMicrophoneInput();\n                }\n                // clear the temp subscription key if it's a participant joining\n                if (this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key])\n                    === this.privPlaceholderKey) {\n                    this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Key], \"\");\n                }\n                // TODO\n                const token = encodeURIComponent(this.privConversation.room.token);\n                let endpointHost = this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], ConversationConnectionConfig.speechHost);\n                endpointHost = endpointHost.replace(\"{region}\", this.privConversation.room.cognitiveSpeechRegion);\n                const url = `wss://${endpointHost}${ConversationConnectionConfig.speechPath}?${ConversationConnectionConfig.configParams.token}=${token}`;\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Endpoint], url);\n                this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this);\n            }\n            catch (error) {\n                yield this.cancelSpeech();\n                throw error;\n            }\n        });\n    }\n    /**\n     * Handle the start speaking request\n     * @param cb\n     * @param err\n     */\n    startContinuousRecognition() {\n        return new Promise((resolve, reject) => {\n            this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);\n        });\n    }\n    get canSpeak() {\n        // is there a Conversation websocket available and has the Recognizer been set up\n        if (!this.privConversation.isConnected || !this.privCTRecognizer) {\n            return false;\n        }\n        // is the user already speaking\n        if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {\n            return false;\n        }\n        // is the user muted\n        if (this.privConversation.isMutedByHost) {\n            return false;\n        }\n        return true;\n    }\n}\n\n//# sourceMappingURL=ConversationTranslator.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nexport { Conversation, ConversationImpl } from \"./Conversation\";\nexport { ConversationCommon } from \"./ConversationCommon\";\nexport { ConversationExpirationEventArgs } from \"./ConversationExpirationEventArgs\";\nexport { ConversationParticipantsChangedEventArgs } from \"./ConversationParticipantsChangedEventArgs\";\nexport { ConversationTranslationCanceledEventArgs } from \"./ConversationTranslationCanceledEventArgs\";\nexport { ConversationTranslationEventArgs } from \"./ConversationTranslationEventArgs\";\nexport { ConversationTranslationResult } from \"./ConversationTranslationResult\";\nexport { ConversationTranslator } from \"./ConversationTranslator\";\nexport { ConversationTranscriber } from \"./ConversationTranscriber\";\nexport { Participant, User } from \"./IParticipant\";\nexport { ParticipantChangedReason } from \"./ParticipantChangedReason\";\n\n//# sourceMappingURL=Exports.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nimport { PropertyCollection } from \"../Exports\";\nexport class User {\n    constructor(userId) {\n        this.privUserId = userId;\n    }\n    get userId() {\n        return this.privUserId;\n    }\n}\n// tslint:disable-next-line: max-classes-per-file\nexport class Participant {\n    constructor(id, avatar, displayName, isHost, isMuted, isUsingTts, preferredLanguage, voice) {\n        this.privId = id;\n        this.privAvatar = avatar;\n        this.privDisplayName = displayName;\n        this.privIsHost = isHost;\n        this.privIsMuted = isMuted;\n        this.privIsUsingTts = isUsingTts;\n        this.privPreferredLanguage = preferredLanguage;\n        this.privVoice = voice;\n        this.privProperties = new PropertyCollection();\n    }\n    static From(id, language, voice) {\n        return new Participant(id, \"\", id, false, false, false, language, voice);\n    }\n    get avatar() {\n        return this.privAvatar;\n    }\n    get displayName() {\n        return this.privDisplayName;\n    }\n    get id() {\n        return this.privId;\n    }\n    get preferredLanguage() {\n        return this.privPreferredLanguage;\n    }\n    get isHost() {\n        return this.privIsHost;\n    }\n    get isMuted() {\n        return this.privIsMuted;\n    }\n    get isUsingTts() {\n        return this.privIsUsingTts;\n    }\n    get voice() {\n        return this.privVoice;\n    }\n    get properties() {\n        return this.privProperties;\n    }\n}\n\n//# sourceMappingURL=IParticipant.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nexport var ParticipantChangedReason;\n(function (ParticipantChangedReason) {\n    /** Participant has joined the conversation. */\n    ParticipantChangedReason[ParticipantChangedReason[\"JoinedConversation\"] = 0] = \"JoinedConversation\";\n    /** Participant has left the conversation. This could be voluntary, or involuntary\n     *  (e.g. they are experiencing networking issues).\n     */\n    ParticipantChangedReason[ParticipantChangedReason[\"LeftConversation\"] = 1] = \"LeftConversation\";\n    /** The participants' state has changed (e.g. they became muted, changed their nickname). */\n    ParticipantChangedReason[ParticipantChangedReason[\"Updated\"] = 2] = \"Updated\";\n})(ParticipantChangedReason || (ParticipantChangedReason = {}));\n\n//# sourceMappingURL=ParticipantChangedReason.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Define payload of speech recognition canceled result events.\n * @class TranslationRecognitionCanceledEventArgs\n */\nexport class TranslationRecognitionCanceledEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {string} sessionid - The session id.\n     * @param {CancellationReason} cancellationReason - The cancellation reason.\n     * @param {string} errorDetails - Error details, if provided.\n     * @param {TranslationRecognitionResult} result - The result.\n     */\n    constructor(sessionid, cancellationReason, errorDetails, errorCode, result) {\n        this.privCancelReason = cancellationReason;\n        this.privErrorDetails = errorDetails;\n        this.privResult = result;\n        this.privSessionId = sessionid;\n        this.privErrorCode = errorCode;\n    }\n    /**\n     * Specifies the recognition result.\n     * @member TranslationRecognitionCanceledEventArgs.prototype.result\n     * @function\n     * @public\n     * @returns {TranslationRecognitionResult} the recognition result.\n     */\n    get result() {\n        return this.privResult;\n    }\n    /**\n     * Specifies the session identifier.\n     * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId\n     * @function\n     * @public\n     * @returns {string} the session identifier.\n     */\n    get sessionId() {\n        return this.privSessionId;\n    }\n    /**\n     * The reason the recognition was canceled.\n     * @member TranslationRecognitionCanceledEventArgs.prototype.reason\n     * @function\n     * @public\n     * @returns {CancellationReason} Specifies the reason canceled.\n     */\n    get reason() {\n        return this.privCancelReason;\n    }\n    /**\n     * The error code in case of an unsuccessful recognition.\n     * Added in version 1.1.0.\n     * @return An error code that represents the error reason.\n     */\n    get errorCode() {\n        return this.privErrorCode;\n    }\n    /**\n     * In case of an unsuccessful recognition, provides details of the occurred error.\n     * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails\n     * @function\n     * @public\n     * @returns {string} A String that represents the error details.\n     */\n    get errorDetails() {\n        return this.privErrorDetails;\n    }\n}\n\n//# sourceMappingURL=TranslationRecognitionCanceledEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RecognitionEventArgs } from \"./Exports\";\n/**\n * Translation text result event arguments.\n * @class TranslationRecognitionEventArgs\n */\nexport class TranslationRecognitionEventArgs extends RecognitionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {TranslationRecognitionResult} result - The translation recognition result.\n     * @param {number} offset - The offset.\n     * @param {string} sessionId - The session id.\n     */\n    constructor(result, offset, sessionId) {\n        super(offset, sessionId);\n        this.privResult = result;\n    }\n    /**\n     * Specifies the recognition result.\n     * @member TranslationRecognitionEventArgs.prototype.result\n     * @function\n     * @public\n     * @returns {TranslationRecognitionResult} the recognition result.\n     */\n    get result() {\n        return this.privResult;\n    }\n}\n\n//# sourceMappingURL=TranslationRecognitionEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { SpeechRecognitionResult } from \"./Exports\";\n/**\n * Translation text result.\n * @class TranslationRecognitionResult\n */\nexport class TranslationRecognitionResult extends SpeechRecognitionResult {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {Translations} translations - The translations.\n     * @param {string} resultId - The result id.\n     * @param {ResultReason} reason - The reason.\n     * @param {string} text - The recognized text.\n     * @param {number} duration - The duration.\n     * @param {number} offset - The offset into the stream.\n     * @param {string} errorDetails - Error details, if provided.\n     * @param {string} json - Additional Json, if provided.\n     * @param {PropertyCollection} properties - Additional properties, if provided.\n     */\n    constructor(translations, resultId, reason, text, duration, offset, errorDetails, json, properties) {\n        super(resultId, reason, text, duration, offset, undefined, undefined, undefined, errorDetails, json, properties);\n        this.privTranslations = translations;\n    }\n    /**\n     * Presents the translation results. Each item in the dictionary represents\n     * a translation result in one of target languages, where the key is the name\n     * of the target language, in BCP-47 format, and the value is the translation\n     * text in the specified language.\n     * @member TranslationRecognitionResult.prototype.translations\n     * @function\n     * @public\n     * @returns {Translations} the current translation map that holds all translations requested.\n     */\n    get translations() {\n        return this.privTranslations;\n    }\n}\n\n//# sourceMappingURL=TranslationRecognitionResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { RecognitionMode, RecognizerConfig, TranslationConnectionFactory, TranslationServiceRecognizer, } from \"../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { Connection } from \"./Connection\";\nimport { Contracts } from \"./Contracts\";\nimport { PropertyId, Recognizer, } from \"./Exports\";\n/**\n * Translation recognizer\n * @class TranslationRecognizer\n */\nexport class TranslationRecognizer extends Recognizer {\n    /**\n     * Initializes an instance of the TranslationRecognizer.\n     * @constructor\n     * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.\n     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer\n     */\n    constructor(speechConfig, audioConfig) {\n        const configImpl = speechConfig;\n        Contracts.throwIfNull(configImpl, \"speechConfig\");\n        super(audioConfig, configImpl.properties, new TranslationConnectionFactory());\n        this.privDisposedTranslationRecognizer = false;\n        this.privProperties = configImpl.properties.clone();\n        if (this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationVoice, undefined) !== undefined) {\n            Contracts.throwIfNullOrWhitespace(this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationVoice), PropertyId[PropertyId.SpeechServiceConnection_TranslationVoice]);\n        }\n        Contracts.throwIfNullOrWhitespace(this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages), PropertyId[PropertyId.SpeechServiceConnection_TranslationToLanguages]);\n        Contracts.throwIfNullOrWhitespace(this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage), PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n    }\n    /**\n     * Gets the language name that was set when the recognizer was created.\n     * @member TranslationRecognizer.prototype.speechRecognitionLanguage\n     * @function\n     * @public\n     * @returns {string} Gets the language name that was set when the recognizer was created.\n     */\n    get speechRecognitionLanguage() {\n        Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n    }\n    /**\n     * Gets target languages for translation that were set when the recognizer was created.\n     * The language is specified in BCP-47 format. The translation will provide translated text for each of language.\n     * @member TranslationRecognizer.prototype.targetLanguages\n     * @function\n     * @public\n     * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.\n     */\n    get targetLanguages() {\n        Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n    }\n    /**\n     * Gets the name of output voice.\n     * @member TranslationRecognizer.prototype.voiceName\n     * @function\n     * @public\n     * @returns {string} the name of output voice.\n     */\n    get voiceName() {\n        Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationVoice, undefined);\n    }\n    /**\n     * Gets the authorization token used to communicate with the service.\n     * @member TranslationRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @returns {string} Authorization token.\n     */\n    get authorizationToken() {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    /**\n     * Gets/Sets the authorization token used to communicate with the service.\n     * @member TranslationRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} value - Authorization token.\n     */\n    set authorizationToken(value) {\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, value);\n    }\n    /**\n     * The collection of properties and their values defined for this TranslationRecognizer.\n     * @member TranslationRecognizer.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    /**\n     * Starts recognition and translation, and stops after the first utterance is recognized.\n     * The task returns the translation text as result.\n     * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitableonly\n     *       for single shot recognition like command or query. For long-running recognition,\n     *       use startContinuousRecognitionAsync() instead.\n     * @member TranslationRecognizer.prototype.recognizeOnceAsync\n     * @function\n     * @public\n     * @param cb - Callback that received the result when the translation has completed.\n     * @param err - Callback invoked in case of an error.\n     */\n    recognizeOnceAsync(cb, err) {\n        Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n        marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(RecognitionMode.Conversation), cb, err);\n    }\n    /**\n     * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.\n     * User must subscribe to events to receive translation results.\n     * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback that received the translation has started.\n     * @param err - Callback invoked in case of an error.\n     */\n    startContinuousRecognitionAsync(cb, err) {\n        marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(RecognitionMode.Conversation), cb, err);\n    }\n    /**\n     * Stops continuous recognition and translation.\n     * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback that received the translation has stopped.\n     * @param err - Callback invoked in case of an error.\n     */\n    stopContinuousRecognitionAsync(cb, err) {\n        marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);\n    }\n    /**\n     * dynamically remove a language from list of target language\n     * (can be used while recognition is ongoing)\n     * @member TranslationRecognizer.prototype.removeTargetLanguage\n     * @function\n     * @param lang - language to be removed\n     * @public\n     */\n    removeTargetLanguage(lang) {\n        Contracts.throwIfNullOrUndefined(lang, \"language to be removed\");\n        if (this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {\n            const languages = this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n            const index = languages.indexOf(lang);\n            if (index > -1) {\n                languages.splice(index, 1);\n                this.properties.setProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(\",\"));\n                this.updateLanguages(languages);\n            }\n        }\n    }\n    /**\n     * dynamically add a language to list of target language\n     * (can be used while recognition is ongoing)\n     * @member TranslationRecognizer.prototype.addTargetLanguage\n     * @function\n     * @param lang - language to be added\n     * @public\n     */\n    addTargetLanguage(lang) {\n        Contracts.throwIfNullOrUndefined(lang, \"language to be added\");\n        let languages = [];\n        if (this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {\n            languages = this.properties.getProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n            if (!languages.includes(lang)) {\n                languages.push(lang);\n                this.properties.setProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(\",\"));\n            }\n        }\n        else {\n            this.properties.setProperty(PropertyId.SpeechServiceConnection_TranslationToLanguages, lang);\n            languages = [lang];\n        }\n        this.updateLanguages(languages);\n    }\n    /**\n     * closes all external resources held by an instance of this class.\n     * @member TranslationRecognizer.prototype.close\n     * @function\n     * @public\n     */\n    close(cb, errorCb) {\n        Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n        marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n    }\n    /**\n     * handles ConnectionEstablishedEvent for conversation translation scenarios.\n     * @member TranslationRecognizer.prototype.onConnection\n     * @function\n     * @public\n     */\n    /* tslint:disable:no-empty */\n    onConnection() { }\n    /**\n     * handles disconnection events for conversation translation scenarios.\n     * @member TranslationRecognizer.prototype.onDisconnection\n     * @function\n     * @public\n     */\n    /* tslint:disable:no-empty */\n    onDisconnection() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    dispose(disposing) {\n        const _super = Object.create(null, {\n            dispose: { get: () => super.dispose }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.privDisposedTranslationRecognizer) {\n                return;\n            }\n            this.privDisposedTranslationRecognizer = true;\n            if (disposing) {\n                yield this.implRecognizerStop();\n                yield _super.dispose.call(this, disposing);\n            }\n        });\n    }\n    createRecognizerConfig(speechConfig) {\n        return new RecognizerConfig(speechConfig, this.properties);\n    }\n    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n        const configImpl = audioConfig;\n        return new TranslationServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);\n    }\n    updateLanguages(languages) {\n        const conn = Connection.fromRecognizer(this);\n        if (!!conn) {\n            conn.setMessageProperty(\"speech.context\", \"translationcontext\", { to: languages });\n            conn.sendMessageAsync(\"event\", JSON.stringify({\n                id: \"translation\",\n                name: \"updateLanguage\",\n                to: languages\n            }));\n        }\n    }\n}\n\n//# sourceMappingURL=TranslationRecognizer.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { SessionEventArgs } from \"./Exports\";\n/**\n * Translation Synthesis event arguments\n * @class TranslationSynthesisEventArgs\n */\nexport class TranslationSynthesisEventArgs extends SessionEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {TranslationSynthesisResult} result - The translation synthesis result.\n     * @param {string} sessionId - The session id.\n     */\n    constructor(result, sessionId) {\n        super(sessionId);\n        this.privResult = result;\n    }\n    /**\n     * Specifies the translation synthesis result.\n     * @member TranslationSynthesisEventArgs.prototype.result\n     * @function\n     * @public\n     * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.\n     */\n    get result() {\n        return this.privResult;\n    }\n}\n\n//# sourceMappingURL=TranslationSynthesisEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines translation synthesis result, i.e. the voice output of the translated\n * text in the target language.\n * @class TranslationSynthesisResult\n */\nexport class TranslationSynthesisResult {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {ResultReason} reason - The synthesis reason.\n     * @param {ArrayBuffer} audio - The audio data.\n     */\n    constructor(reason, audio) {\n        this.privReason = reason;\n        this.privAudio = audio;\n    }\n    /**\n     * Translated text in the target language.\n     * @member TranslationSynthesisResult.prototype.audio\n     * @function\n     * @public\n     * @returns {ArrayBuffer} Translated audio in the target language.\n     */\n    get audio() {\n        return this.privAudio;\n    }\n    /**\n     * The synthesis status.\n     * @member TranslationSynthesisResult.prototype.reason\n     * @function\n     * @public\n     * @returns {ResultReason} The synthesis status.\n     */\n    get reason() {\n        return this.privReason;\n    }\n}\n\n//# sourceMappingURL=TranslationSynthesisResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { PropertyCollection } from \"./Exports\";\n/**\n * Represents collection of parameters and their values.\n * @class Translations\n */\nexport class Translations {\n    constructor() {\n        // Use an PropertyCollection internally, just wrapping it to hide the | enum syntax it has.\n        this.privMap = new PropertyCollection();\n    }\n    /**\n     * Returns the parameter value in type String. The parameter must have the same type as String.\n     * Currently only String, int and bool are allowed.\n     * If the name is not available, the specified defaultValue is returned.\n     * @member Translations.prototype.get\n     * @function\n     * @public\n     * @param {string} key - The parameter name.\n     * @param {string} def - The default value which is returned if the parameter is not available in the collection.\n     * @returns {string} value of the parameter.\n     */\n    get(key, def) {\n        return this.privMap.getProperty(key, def);\n    }\n    /**\n     * Sets the String value of the parameter specified by name.\n     * @member Translations.prototype.set\n     * @function\n     * @public\n     * @param {string} key - The parameter name.\n     * @param {string} value - The value of the parameter.\n     */\n    set(key, value) {\n        this.privMap.setProperty(key, value);\n    }\n    /**\n     * Get the languages in the object in a String array.\n     * @member Translations.prototype.languages\n     * @function\n     * @public\n     * @returns {string[]} languages in translations object.\n     */\n    get languages() {\n        return this.privMap.keys;\n    }\n}\n\n//# sourceMappingURL=Translations.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { TurnStatusResponsePayload } from \"../common.speech/ServiceMessages/TurnStatusPayload\";\n/**\n * Defines contents of received message/events.\n * @class TurnStatusReceivedEventArgs\n */\nexport class TurnStatusReceivedEventArgs {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {string} turnStatus - The JSON-encoded turn status message.\n     */\n    constructor(turnStatus) {\n        this.privTurnStatus = TurnStatusResponsePayload.fromJSON(turnStatus);\n    }\n    /**\n     * Gets the interaction identifier associated with this turn status event.\n     * @member TurnStatusReceivedEventArgs.prototype.interactionId\n     * @function\n     * @public\n     * @returns {any} the received interaction id.\n     */\n    get interactionId() {\n        return this.privTurnStatus.interactionId;\n    }\n    /**\n     * Gets the conversation identifier associated with this turn status event.\n     * @member TurnStatusReceivedEventArgs.prototype.conversationId\n     * @function\n     * @public\n     * @returns {any} the received conversation id.\n     */\n    get conversationId() {\n        return this.privTurnStatus.conversationId;\n    }\n    /**\n     * Gets the received turn status code.\n     * @member TurnStatusReceivedEventArgs.prototype.statusCode\n     * @function\n     * @public\n     * @returns {number} the received turn status.\n     */\n    get statusCode() {\n        return this.privTurnStatus.statusCode;\n    }\n}\n\n//# sourceMappingURL=TurnStatusReceivedEventArgs.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Defines Voice Profile class for Speaker Recognition\n * @class VoiceProfile\n */\nexport class VoiceProfile {\n    /**\n     * Creates and initializes an instance of this class.\n     * @constructor\n     * @param {string} profileId - profileId of this Voice Profile.\n     * @param {VoiceProfileType} profileType - profileType of this Voice Profile.\n     */\n    constructor(profileId, profileType) {\n        this.privId = profileId;\n        this.privProfileType = profileType;\n    }\n    /**\n     * profileId of this Voice Profile instance\n     * @member VoiceProfile.prototype.profileId\n     * @function\n     * @public\n     * @returns {string} profileId of this Voice Profile instance.\n     */\n    get profileId() {\n        return this.privId;\n    }\n    /**\n     * profileType of this Voice Profile instance\n     * @member VoiceProfile.prototype.profileType\n     * @function\n     * @public\n     * @returns {VoiceProfileType} profile type of this Voice Profile instance.\n     */\n    get profileType() {\n        return this.privProfileType;\n    }\n}\n\n//# sourceMappingURL=VoiceProfile.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Context, OS, SpeakerIdMessageAdapter, SpeakerRecognitionConfig, } from \"../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { PropertyId, ResultReason, VoiceProfile, VoiceProfileEnrollmentResult, VoiceProfilePhraseResult, VoiceProfileResult, VoiceProfileType, } from \"./Exports\";\n/**\n * Defines VoiceProfileClient class for Speaker Recognition\n * Handles operations from user for Voice Profile operations (e.g. createProfile, deleteProfile)\n * @class VoiceProfileClient\n */\nexport class VoiceProfileClient {\n    /**\n     * VoiceProfileClient constructor.\n     * @constructor\n     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)\n     */\n    constructor(speechConfig) {\n        const speechConfigImpl = speechConfig;\n        Contracts.throwIfNull(speechConfigImpl, \"speechConfig\");\n        this.privProperties = speechConfigImpl.properties.clone();\n        this.implClientSetup();\n    }\n    /**\n     * Gets the authorization token used to communicate with the service.\n     * @member VoiceProfileClient.prototype.authorizationToken\n     * @function\n     * @public\n     * @returns {string} Authorization token.\n     */\n    get authorizationToken() {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n    /**\n     * Gets/Sets the authorization token used to communicate with the service.\n     * @member VoiceProfileClient.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} token - Authorization token.\n     */\n    set authorizationToken(token) {\n        Contracts.throwIfNullOrWhitespace(token, \"token\");\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, token);\n    }\n    /**\n     * The collection of properties and their values defined for this VoiceProfileClient.\n     * @member VoiceProfileClient.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.\n     */\n    get properties() {\n        return this.privProperties;\n    }\n    /**\n     * Create a speaker recognition voice profile\n     * @member VoiceProfileClient.prototype.createProfileAsync\n     * @function\n     * @public\n     * @param {VoiceProfileType} profileType Type of Voice Profile to be created\n     *        specifies the keyword to be recognized.\n     * @param {string} lang Language string (locale) for Voice Profile\n     * @param cb - Callback invoked once Voice Profile has been created.\n     * @param err - Callback invoked in case of an error.\n     */\n    createProfileAsync(profileType, lang, cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.privAdapter.createProfile(profileType, lang);\n            if (!result.ok) {\n                throw new Error(`createProfileAsync failed with code: ${result.status}, message: ${result.statusText}`);\n            }\n            const response = result.json;\n            const profile = new VoiceProfile(response.profileId, profileType);\n            return profile;\n        }))(), cb, err);\n    }\n    /**\n     * Get current information of a voice profile\n     * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync\n     * @function\n     * @public\n     * @param {VoiceProfile} profile Voice Profile to retrieve info for\n     * @param cb - Callback invoked once Voice Profile has been created.\n     * @param err - Callback invoked in case of an error.\n     */\n    retrieveEnrollmentResultAsync(profile, cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.privAdapter.getProfileStatus(profile);\n            return new VoiceProfileEnrollmentResult(result.ok ? ResultReason.EnrolledVoiceProfile : ResultReason.Canceled, result.data, result.statusText);\n        }))(), cb, err);\n    }\n    /**\n     * Get all voice profiles on account with given voice profile type\n     * @member VoiceProfileClient.prototype.getAllProfilesAsync\n     * @function\n     * @public\n     * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles\n     * @param cb - Callback invoked once Profile list has been returned.\n     * @param err - Callback invoked in case of an error.\n     */\n    getAllProfilesAsync(profileType, cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.privAdapter.getProfiles(profileType);\n            if (profileType === VoiceProfileType.TextIndependentIdentification) {\n                return VoiceProfileEnrollmentResult.FromIdentificationProfileList(result.json);\n            }\n            return VoiceProfileEnrollmentResult.FromVerificationProfileList(result.json);\n        }))(), cb, err);\n    }\n    /**\n     * Get valid authorization phrases for voice profile enrollment\n     * @member VoiceProfileClient.prototype.getAuthorizationPhrasesAsync\n     * @function\n     * @public\n     * @param {string} lang Language string (locale) for Voice Profile\n     * @param cb - Callback invoked once phrases have been returned.\n     * @param err - Callback invoked in case of an error.\n     */\n    getActivationPhrasesAsync(profileType, lang, cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.privAdapter.getPhrases(profileType, lang);\n            return new VoiceProfilePhraseResult(result.ok ? ResultReason.EnrollingVoiceProfile : ResultReason.Canceled, result.statusText, result.json);\n        }))(), cb, err);\n    }\n    /**\n     * Create a speaker recognition voice profile\n     * @member VoiceProfileClient.prototype.enrollProfileAsync\n     * @function\n     * @public\n     * @async\n     * @param {VoiceProfile} profile Voice Profile to create enrollment for\n     * @param {AudioConfig} audioConfig source info from which to create enrollment\n     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.\n     */\n    enrollProfileAsync(profile, audioConfig) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const configImpl = audioConfig;\n            Contracts.throwIfNullOrUndefined(configImpl, \"audioConfig\");\n            const result = yield this.privAdapter.createEnrollment(profile, configImpl);\n            return new VoiceProfileEnrollmentResult(result.ok ? ResultReason.EnrolledVoiceProfile : ResultReason.Canceled, result.data, result.statusText);\n        });\n    }\n    /**\n     * Delete a speaker recognition voice profile\n     * @member VoiceProfileClient.prototype.deleteProfileAsync\n     * @function\n     * @public\n     * @param {VoiceProfile} profile Voice Profile to be deleted\n     * @param cb - Callback invoked once Voice Profile has been deleted.\n     * @param err - Callback invoked in case of an error.\n     */\n    deleteProfileAsync(profile, cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.privAdapter.deleteProfile(profile);\n            return this.getResult(result, ResultReason.DeletedVoiceProfile);\n        }))(), cb, err);\n    }\n    /**\n     * Remove all enrollments for a speaker recognition voice profile\n     * @member VoiceProfileClient.prototype.resetProfileAsync\n     * @function\n     * @public\n     * @param {VoiceProfile} profile Voice Profile to be reset\n     * @param cb - Callback invoked once Voice Profile has been reset.\n     * @param err - Callback invoked in case of an error.\n     */\n    resetProfileAsync(profile, cb, err) {\n        marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.privAdapter.resetProfile(profile);\n            return this.getResult(result, ResultReason.ResetVoiceProfile);\n        }))(), cb, err);\n    }\n    /**\n     * Included for compatibility\n     * @member VoiceProfileClient.prototype.close\n     * @function\n     * @public\n     */\n    close() {\n        return;\n    }\n    // Does class setup, swiped from Recognizer.\n    implClientSetup() {\n        let osPlatform = (typeof window !== \"undefined\") ? \"Browser\" : \"Node\";\n        let osName = \"unknown\";\n        let osVersion = \"unknown\";\n        if (typeof navigator !== \"undefined\") {\n            osPlatform = osPlatform + \"/\" + navigator.platform;\n            osName = navigator.userAgent;\n            osVersion = navigator.appVersion;\n        }\n        const recognizerConfig = new SpeakerRecognitionConfig(new Context(new OS(osPlatform, osName, osVersion)), this.privProperties);\n        this.privAdapter = new SpeakerIdMessageAdapter(recognizerConfig);\n    }\n    getResult(result, successReason, cb) {\n        const response = new VoiceProfileResult(result.ok ? successReason : ResultReason.Canceled, result.statusText);\n        return (response);\n    }\n}\n\n//# sourceMappingURL=VoiceProfileClient.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { CancellationErrorCodePropertyName } from \"../common.speech/Exports\";\nimport { CancellationDetailsBase, CancellationErrorCode, CancellationReason, PropertyCollection, ResultReason, } from \"./Exports\";\n/**\n * Output format\n * @class VoiceProfileEnrollmentResult\n */\nexport class VoiceProfileEnrollmentResult {\n    constructor(reason, json, statusText) {\n        this.privReason = reason;\n        this.privProperties = new PropertyCollection();\n        if (this.privReason !== ResultReason.Canceled) {\n            if (!!json) {\n                this.privDetails = JSON.parse(json);\n                if (this.privDetails.enrollmentStatus.toLowerCase() === \"enrolling\") {\n                    this.privReason = ResultReason.EnrollingVoiceProfile;\n                }\n            }\n        }\n        else {\n            this.privErrorDetails = statusText;\n            this.privProperties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[CancellationErrorCode.ServiceError]);\n        }\n    }\n    static FromIdentificationProfileList(json) {\n        const results = [];\n        for (const item of json.profiles) {\n            const reason = item.enrollmentStatus.toLowerCase() === \"enrolling\" ?\n                ResultReason.EnrollingVoiceProfile : item.enrollmentStatus.toLowerCase() === \"enrolled\" ?\n                ResultReason.EnrolledVoiceProfile : ResultReason.Canceled;\n            const result = new VoiceProfileEnrollmentResult(reason, null, null);\n            result.privDetails = this.getIdentificationDetails(item);\n            results.push(result);\n        }\n        return results;\n    }\n    static FromVerificationProfileList(json) {\n        const results = [];\n        for (const item of json.profiles) {\n            const reason = item.enrollmentStatus.toLowerCase() === \"enrolling\" ?\n                ResultReason.EnrollingVoiceProfile : item.enrollmentStatus.toLowerCase() === \"enrolled\" ?\n                ResultReason.EnrolledVoiceProfile : ResultReason.Canceled;\n            const result = new VoiceProfileEnrollmentResult(reason, null, null);\n            result.privDetails = this.getVerificationDetails(item);\n            results.push(result);\n        }\n        return results;\n    }\n    get reason() {\n        return this.privReason;\n    }\n    get enrollmentsCount() {\n        return this.privDetails.enrollmentsCount;\n    }\n    get enrollmentsLength() {\n        return this.privDetails.enrollmentsLength;\n    }\n    get properties() {\n        return this.privProperties;\n    }\n    get enrollmentResultDetails() {\n        return this.privDetails;\n    }\n    get errorDetails() {\n        return this.privErrorDetails;\n    }\n    static getIdentificationDetails(json) {\n        return {\n            audioSpeechLength: json.speechTime ? parseFloat(json.speechTime) : 0,\n            enrollmentStatus: json.enrollmentStatus,\n            enrollmentsLength: json.enrollmentSpeechTime ? parseFloat(json.enrollmentSpeechTime) : 0,\n            profileId: json.profileId || json.identificationProfileId,\n            remainingEnrollmentSpeechLength: json.remainingEnrollmentSpeechTime ? parseFloat(json.remainingEnrollmentSpeechTime) : 0\n        };\n    }\n    static getVerificationDetails(json) {\n        return {\n            enrollmentStatus: json.enrollmentStatus,\n            enrollmentsCount: json.enrollmentsCount,\n            profileId: json.profileId || json.verificationProfileId,\n            remainingEnrollmentSpeechLength: json.remainingEnrollmentSpeechLength ? parseFloat(json.remainingEnrollmentSpeechLength) : 0,\n            remainingEnrollmentsCount: json.remainingEnrollments || json.remainingEnrollmentsCount\n        };\n    }\n}\n/**\n * @class VoiceProfileEnrollmentCancellationDetails\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class VoiceProfileEnrollmentCancellationDetails extends CancellationDetailsBase {\n    constructor(reason, errorDetails, errorCode) {\n        super(reason, errorDetails, errorCode);\n    }\n    /**\n     * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.\n     * @member VoiceProfileEnrollmentCancellationDetails.fromResult\n     * @function\n     * @public\n     * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.\n     * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.\n     */\n    static fromResult(result) {\n        const reason = CancellationReason.Error;\n        let errorCode = CancellationErrorCode.NoError;\n        if (!!result.properties) {\n            errorCode = CancellationErrorCode[result.properties.getProperty(CancellationErrorCodePropertyName, CancellationErrorCode[CancellationErrorCode.NoError])];\n        }\n        return new VoiceProfileEnrollmentCancellationDetails(reason, result.errorDetails, errorCode);\n    }\n}\n\n//# sourceMappingURL=VoiceProfileEnrollmentResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"./Contracts\";\nimport { VoiceProfileResult } from \"./Exports\";\n/**\n * Output format\n * @class VoiceProfilePhraseResult\n */\nexport class VoiceProfilePhraseResult extends VoiceProfileResult {\n    constructor(reason, statusText, json) {\n        super(reason, statusText);\n        this.privPhrases = [];\n        Contracts.throwIfNullOrUndefined(json, \"phrases array\");\n        for (const item of json) {\n            this.privPhrases.push(item.passPhrase || item.activationPhrase);\n        }\n    }\n    get phrases() {\n        return this.privPhrases;\n    }\n}\n\n//# sourceMappingURL=VoiceProfilePhraseResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { CancellationErrorCodePropertyName } from \"../common.speech/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { CancellationDetailsBase, CancellationErrorCode, CancellationReason, PropertyCollection, ResultReason, } from \"./Exports\";\n/**\n * Output format\n * @class VoiceProfileResult\n */\nexport class VoiceProfileResult {\n    constructor(reason, statusText) {\n        this.privReason = reason;\n        this.privProperties = new PropertyCollection();\n        if (reason === ResultReason.Canceled) {\n            Contracts.throwIfNullOrUndefined(statusText, \"statusText\");\n            this.privErrorDetails = statusText;\n            this.privProperties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[CancellationErrorCode.ServiceError]);\n        }\n    }\n    get reason() {\n        return this.privReason;\n    }\n    get properties() {\n        return this.privProperties;\n    }\n    get errorDetails() {\n        return this.privErrorDetails;\n    }\n}\n/**\n * @class VoiceProfileCancellationDetails\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class VoiceProfileCancellationDetails extends CancellationDetailsBase {\n    constructor(reason, errorDetails, errorCode) {\n        super(reason, errorDetails, errorCode);\n    }\n    /**\n     * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.\n     * @member VoiceProfileCancellationDetails.fromResult\n     * @function\n     * @public\n     * @param {VoiceProfileResult} result - The result that was canceled.\n     * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.\n     */\n    static fromResult(result) {\n        const reason = CancellationReason.Error;\n        let errorCode = CancellationErrorCode.NoError;\n        if (!!result.properties) {\n            errorCode = CancellationErrorCode[result.properties.getProperty(CancellationErrorCodePropertyName, CancellationErrorCode[CancellationErrorCode.NoError])];\n        }\n        return new VoiceProfileCancellationDetails(reason, result.errorDetails, errorCode);\n    }\n}\n\n//# sourceMappingURL=VoiceProfileResult.js.map\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * Output format\n * @class VoiceProfileType\n */\nexport var VoiceProfileType;\n(function (VoiceProfileType) {\n    /**\n     * Text independent speaker identification\n     * @member VoiceProfileType.TextIndependentIdentification\n     */\n    VoiceProfileType[VoiceProfileType[\"TextIndependentIdentification\"] = 0] = \"TextIndependentIdentification\";\n    /**\n     * Text dependent speaker verification\n     * @member VoiceProfileType.TextDependentVerification\n     */\n    VoiceProfileType[VoiceProfileType[\"TextDependentVerification\"] = 1] = \"TextDependentVerification\";\n    /**\n     * Text independent speaker verification\n     * @member VoiceProfileType.TextIndependentVerification\n     */\n    VoiceProfileType[VoiceProfileType[\"TextIndependentVerification\"] = 2] = \"TextIndependentVerification\";\n})(VoiceProfileType || (VoiceProfileType = {}));\n\n//# sourceMappingURL=VoiceProfileType.js.map\n","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n","module.exports = require('./lib/_stream_duplex.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('events').EventEmitter;\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","module.exports = require('./readable').PassThrough\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","module.exports = require('./readable').Transform\n","module.exports = require('./lib/_stream_writable.js');\n","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n","\nmodule.exports = require('./lib');\n\n","var util = require('util');\nvar Readable = require('stream').Readable;\nvar bind = require('component-bind');\n\n\nmodule.exports = BlobReadStream;\n\nutil.inherits(BlobReadStream, Readable);\n\n/**\n * Readable stream for Blob and File on browser.\n *\n * @param {Object} options\n * @api private\n */\nfunction BlobReadStream(blob, options) {\n  if (!(this instanceof BlobReadStream)) {\n    return new BlobReadStream(blob, options);\n  }\n\n  Readable.call(this, options);\n\n  options = options || {};\n  this.blob = blob;\n  this.slice = blob.slice || blob.webkitSlice || blob.mozSlice;\n  this.start = 0;\n  this.sync = options.synchronous || false;\n\n  var fileReader;\n\n  if (options.synchronous) {\n    fileReader = this.fileReader = new FileReaderSync();\n  } else {\n    fileReader = this.fileReader = new FileReader();\n  }\n\n  fileReader.onload = bind(this, '_onload');\n  fileReader.onerror = bind(this, '_onerror');\n}\n\nBlobReadStream.prototype._read = function(size) {\n  var start = this.start;\n  var end = this.start = this.start + size;\n  var chunk = this.slice.call(this.blob, start, end);\n\n  if (chunk.size) {\n    if (this.sync) {\n      var bufferChunk = new Buffer(new Uint8Array(this.fileReader.readAsArrayBuffer(chunk)));\n      this.push(bufferChunk);\n    } else {\n      this.fileReader.readAsArrayBuffer(chunk);\n    }\n  } else {\n    this.push(null);\n  }\n}\n\nBlobReadStream.prototype._onload = function(e) {\n  var chunk = new Buffer(new Uint8Array(e.target.result));\n  this.push(chunk);\n};\n\nBlobReadStream.prototype._onerror = function(e) {\n  var err = e.target.error;\n  this.emit('error', err);\n};\n\n","var Socket = require('./socket');\nvar IOStream = require('./iostream');\nvar BlobReadStream = require('./blob-read-stream');\n\n\nexports = module.exports = lookup;\n\n/**\n * Expose Node Buffer for browser.\n *\n * @api public\n */\nexports.Buffer = Buffer;\n\n/**\n * Expose Socket constructor.\n *\n * @api public\n */\nexports.Socket = Socket;\n\n/**\n * Expose IOStream constructor.\n *\n * @api public\n */\nexports.IOStream = IOStream;\n\n/**\n * Forces base 64 encoding when emitting. Must be set to true for Socket.IO v0.9 or lower.\n *\n * @api public\n */\nexports.forceBase64 = false;\n\n/**\n * Look up an existing Socket.\n *\n * @param {socket.io#Socket} socket.io\n * @param {Object} options\n * @return {Socket} Socket instance\n * @api public\n */\nfunction lookup(sio, options) {\n  options = options || {};\n  if (null == options.forceBase64) {\n    options.forceBase64 = exports.forceBase64;\n  }\n\n  if (!sio._streamSocket) {\n    sio._streamSocket = new Socket(sio, options);\n  }\n  return sio._streamSocket;\n}\n\n/**\n * Creates a new duplex stream.\n *\n * @param {Object} options\n * @return {IOStream} duplex stream\n * @api public\n */\nexports.createStream = function(options) {\n  return new IOStream(options);\n};\n\n/**\n * Creates a new readable stream for Blob/File on browser.\n *\n * @param {Blob} blob\n * @param {Object} options\n * @return {BlobReadStream} stream\n * @api public\n */\nexports.createBlobReadStream = function(blob, options) {\n  return new BlobReadStream(blob, options);\n};\n","var util = require('util');\nvar Duplex = require('stream').Duplex;\nvar bind = require('component-bind');\nvar uuid = require('./uuid');\nvar debug = require('debug')('socket.io-stream:iostream');\n\n\nmodule.exports = IOStream;\n\nutil.inherits(IOStream, Duplex);\n\n/**\n * Duplex\n *\n * @param {Object} options\n * @api private\n */\nfunction IOStream(options) {\n  if (!(this instanceof IOStream)) {\n    return new IOStream(options);\n  }\n\n  IOStream.super_.call(this, options);\n\n  this.options = options;\n  this.id = uuid();\n  this.socket = null;\n\n  // Buffers\n  this.pushBuffer = [];\n  this.writeBuffer = [];\n\n  // Op states\n  this._readable = false;\n  this._writable = false;\n  this.destroyed = false;\n\n  // default to *not* allowing half open sockets\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\n\n  this.on('finish', this._onfinish);\n  this.on('end', this._onend);\n  this.on('error', this._onerror);\n}\n\n/**\n * Ensures that no more I/O activity happens on this stream.\n * Not necessary in the usual case.\n *\n * @api public\n */\nIOStream.prototype.destroy = function() {\n  debug('destroy');\n\n  if (this.destroyed) {\n    debug('already destroyed');\n    return;\n  }\n\n  this.readable = this.writable = false;\n\n  if (this.socket) {\n    debug('clean up');\n    this.socket.cleanup(this.id);\n    this.socket = null;\n  }\n\n  this.destroyed = true;\n};\n\n/**\n * Local read\n *\n * @api private\n */\nIOStream.prototype._read = function(size) {\n  var push;\n\n  // We can not read from the socket if it's destroyed obviously ...\n  if (this.destroyed) return;\n\n  if (this.pushBuffer.length) {\n    // flush buffer and end if it exists.\n    while (push = this.pushBuffer.shift()) {\n      if (!push()) break;\n    }\n    return;\n  }\n\n  this._readable = true;\n\n  // Go get data from remote stream\n  // Calls\n  // ._onread remotely\n  // then\n  // ._onwrite locally\n  this.socket._read(this.id, size);\n};\n\n\n/**\n * Read from remote stream\n *\n * @api private\n */\nIOStream.prototype._onread = function(size) {\n  var write = this.writeBuffer.shift();\n  if (write) return write();\n\n  this._writable = true;\n};\n\n/**\n * Write local data to remote stream\n * Calls\n * remtote ._onwrite\n *\n * @api private\n */\nIOStream.prototype._write = function(chunk, encoding, callback) {\n  var self = this;\n\n  function write() {\n    // We can not write to the socket if it's destroyed obviously ...\n    if (self.destroyed) return;\n\n    self._writable = false;\n    self.socket._write(self.id, chunk, encoding, callback);\n  }\n\n  if (this._writable) {\n    write();\n  } else {\n    this.writeBuffer.push(write);\n  }\n};\n\n/**\n * Write the data fetched remotely\n * so that we can now read locally\n *\n * @api private\n */\nIOStream.prototype._onwrite = function(chunk, encoding, callback) {\n  var self = this;\n\n  function push() {\n    self._readable = false;\n    var ret = self.push(chunk || '', encoding);\n    callback();\n    return ret;\n  }\n\n  if (this._readable) {\n    push();\n  } else {\n    this.pushBuffer.push(push);\n  }\n};\n\n/**\n * When ending send 'end' event to remote stream\n *\n * @api private\n */\nIOStream.prototype._end = function() {\n  if (this.pushBuffer.length) {\n    // end after flushing buffer.\n    this.pushBuffer.push(bind(this, '_done'));\n  } else {\n    this._done();\n  }\n};\n\n/**\n * Remote stream just ended\n *\n * @api private\n */\nIOStream.prototype._done = function() {\n  this._readable = false;\n\n  // signal the end of the data.\n  return this.push(null);\n};\n\n/**\n * the user has called .end(), and all the bytes have been\n * sent out to the other side.\n * If allowHalfOpen is false, or if the readable side has\n * ended already, then destroy.\n * If allowHalfOpen is true, then we need to set writable false,\n * so that only the writable side will be cleaned up.\n *\n * @api private\n */\nIOStream.prototype._onfinish = function() {\n  debug('_onfinish');\n  // Local socket just finished\n  // send 'end' event to remote\n  if (this.socket) {\n    this.socket._end(this.id);\n  }\n\n  this.writable = false;\n  this._writableState.ended = true;\n\n  if (!this.readable || this._readableState.ended) {\n    debug('_onfinish: ended, destroy %s', this._readableState);\n    return this.destroy();\n  }\n\n  debug('_onfinish: not ended');\n\n  if (!this.allowHalfOpen) {\n    this.push(null);\n\n    // just in case we're waiting for an EOF.\n    if (this.readable && !this._readableState.endEmitted) {\n      this.read(0);\n    }\n  }\n};\n\n/**\n * the EOF has been received, and no more bytes are coming.\n * if the writable side has ended already, then clean everything\n * up.\n *\n * @api private\n */\nIOStream.prototype._onend = function() {\n  debug('_onend');\n  this.readable = false;\n  this._readableState.ended = true;\n\n  if (!this.writable || this._writableState.finished) {\n    debug('_onend: %s', this._writableState);\n    return this.destroy();\n  }\n\n  debug('_onend: not finished');\n\n  if (!this.allowHalfOpen) {\n    this.end();\n  }\n};\n\n/**\n * When error in local stream\n * notyify remote\n * if err.remote = true\n * then error happened on remote stream\n *\n * @api private\n */\nIOStream.prototype._onerror = function(err) {\n  // check if the error came from remote stream.\n  if (!err.remote && this.socket) {\n    // notify the error to the corresponding remote stream.\n    this.socket._error(this.id, err);\n  }\n\n  this.destroy();\n};\n","var util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar IOStream = require('./iostream');\nvar slice = Array.prototype.slice;\n\nexports.Encoder = Encoder;\nexports.Decoder = Decoder;\n\nutil.inherits(Encoder, EventEmitter);\n\nfunction Encoder() {\n  EventEmitter.call(this);\n}\n\n/**\n * Encode streams to placeholder objects.\n *\n * @api public\n */\nEncoder.prototype.encode = function(v) {\n  if (v instanceof IOStream) {\n    return this.encodeStream(v);\n  } else if (util.isArray(v)) {\n    return this.encodeArray(v);\n  } else if (v && 'object' == typeof v) {\n    return this.encodeObject(v);\n  }\n  return v;\n}\n\nEncoder.prototype.encodeStream = function(stream) {\n  this.emit('stream', stream);\n\n  // represent a stream in an object.\n  var v = { $stream: stream.id };\n  if (stream.options) {\n    v.options = stream.options;\n  }\n  return v;\n}\n\nEncoder.prototype.encodeArray = function(arr) {\n  var v = [];\n  for (var i = 0, len = arr.length; i < len; i++) {\n    v.push(this.encode(arr[i]));\n  }\n  return v;\n}\n\nEncoder.prototype.encodeObject = function(obj) {\n  var v = {};\n  for (var k in obj) {\n    if (obj.hasOwnProperty(k)) {\n      v[k] = this.encode(obj[k]);\n    }\n  }\n  return v;\n}\n\nutil.inherits(Decoder, EventEmitter);\n\nfunction Decoder() {\n  EventEmitter.call(this);\n}\n\n/**\n * Decode placeholder objects to streams.\n *\n * @api public\n */\nDecoder.prototype.decode = function(v) {\n  if (v && v.$stream) {\n    return this.decodeStream(v);\n  } else if (util.isArray(v)) {\n    return this.decodeArray(v);\n  } else if (v && 'object' == typeof v) {\n    return this.decodeObject(v);\n  }\n  return v;\n}\n\nDecoder.prototype.decodeStream = function(obj) {\n  var stream = new IOStream(obj.options);\n  stream.id = obj.$stream;\n  this.emit('stream', stream);\n  return stream;\n}\n\nDecoder.prototype.decodeArray = function(arr) {\n  var v = [];\n  for (var i = 0, len = arr.length; i < len; i++) {\n    v.push(this.decode(arr[i]));\n  }\n  return v;\n}\n\nDecoder.prototype.decodeObject = function(obj) {\n  var v = {};\n  for (var k in obj) {\n    if (obj.hasOwnProperty(k)) {\n      v[k] = this.decode(obj[k]);\n    }\n  }\n  return v;\n}\n","var util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar bind = require('component-bind');\nvar IOStream = require('./iostream');\nvar parser = require('./parser');\nvar debug = require('debug')('socket.io-stream:socket');\nvar emit = EventEmitter.prototype.emit;\nvar on = EventEmitter.prototype.on;\nvar slice = Array.prototype.slice;\n\n\nexports = module.exports = Socket;\n\n/**\n * Base event name for messaging.\n *\n * @api public\n */\nexports.event = '$stream';\n\nexports.events = [\n  'error',\n  'newListener',\n  'removeListener'\n];\n\nutil.inherits(Socket, EventEmitter);\n\n/**\n * Bidirectional stream socket which wraps Socket.IO.\n *\n * @param {socket.io#Socket} socket.io\n * @api public\n */\nfunction Socket(sio, options) {\n  if (!(this instanceof Socket)) {\n    return new Socket(sio, options);\n  }\n\n  EventEmitter.call(this);\n\n  options = options || {};\n\n  this.sio = sio;\n  this.forceBase64 = !!options.forceBase64;\n  this.streams = {};\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n\n  var eventName = exports.event;\n  sio.on(eventName, bind(this, emit));\n  sio.on(eventName + '-read', bind(this, '_onread'));\n  sio.on(eventName + '-write', bind(this, '_onwrite'));\n  sio.on(eventName + '-end', bind(this, '_onend'));\n  sio.on(eventName + '-error', bind(this, '_onerror'));\n  sio.on('error', bind(this, emit, 'error'));\n  sio.on('disconnect', bind(this, '_ondisconnect'));\n\n  this.encoder.on('stream', bind(this, '_onencode'));\n  this.decoder.on('stream', bind(this, '_ondecode'));\n}\n\n/**\n * Original emit function.\n *\n * @api private\n */\nSocket.prototype.$emit = emit;\n\n/**\n * Emits streams to this corresponding server/client.\n *\n * @return {Socket} self\n * @api public\n */\nSocket.prototype.emit = function(type) {\n  if (~exports.events.indexOf(type)) {\n    return emit.apply(this, arguments);\n  }\n  this._stream.apply(this, arguments);\n  return this;\n};\n\nSocket.prototype.on = function(type, listener) {\n  if (~exports.events.indexOf(type)) {\n    return on.apply(this, arguments);\n  }\n\n  this._onstream(type, listener);\n  return this;\n};\n\n/**\n * Sends a new stream request.\n *\n * @param {String} event type\n * @api private\n */\nSocket.prototype._stream = function(type) {\n  debug('sending new streams');\n\n  var self = this;\n  var args = slice.call(arguments, 1);\n  var ack = args[args.length - 1];\n  if ('function' == typeof ack) {\n    args[args.length - 1] = function() {\n      var args = slice.call(arguments);\n      args = self.decoder.decode(args);\n      ack.apply(this, args);\n    };\n  }\n\n  args = this.encoder.encode(args);\n  var sio = this.sio;\n  sio.emit.apply(sio, [exports.event, type].concat(args));\n};\n\n/**\n * Notifies the read event.\n *\n * @api private\n */\nSocket.prototype._read = function(id, size) {\n  this.sio.emit(exports.event + '-read', id, size);\n};\n\n/**\n * Requests to write a chunk.\n *\n * @api private\n */\nSocket.prototype._write = function(id, chunk, encoding, callback) {\n  if (Buffer.isBuffer(chunk)) {\n    if (this.forceBase64) {\n      encoding = 'base64';\n      chunk = chunk.toString(encoding);\n    } else if (!global.Buffer) {\n      // socket.io can't handle Buffer when using browserify.\n      if (chunk.toArrayBuffer) {\n        chunk = chunk.toArrayBuffer();\n      } else {\n        chunk = chunk.buffer;\n      }\n    }\n  }\n  this.sio.emit(exports.event + '-write', id, chunk, encoding, callback);\n};\n\nSocket.prototype._end = function(id) {\n  this.sio.emit(exports.event + '-end', id);\n};\n\nSocket.prototype._error = function(id, err) {\n  this.sio.emit(exports.event + '-error', id, err.message || err);\n};\n\n/**\n * Handles a new stream request.\n *\n * @param {String} event type\n * @param {Function} listener\n *\n * @api private\n */\nSocket.prototype._onstream = function(type, listener) {\n  if ('function' != typeof listener) {\n    throw TypeError('listener must be a function');\n  }\n\n  function onstream() {\n    debug('new streams');\n    var self = this;\n    var args = slice.call(arguments);\n    var ack = args[args.length - 1];\n    if ('function' == typeof ack) {\n      args[args.length - 1] = function() {\n        var args = slice.call(arguments);\n        args = self.encoder.encode(args);\n        ack.apply(this, args);\n      };\n    }\n\n    args = this.decoder.decode(args);\n    listener.apply(this, args);\n  }\n\n  // for removeListener\n  onstream.listener = listener;\n\n  on.call(this, type, onstream);\n};\n\nSocket.prototype._onread = function(id, size) {\n  debug('read: \"%s\"', id);\n\n  var stream = this.streams[id];\n  if (stream) {\n    stream._onread(size);\n  } else {\n    debug('ignore invalid stream id');\n  }\n};\n\nSocket.prototype._onwrite = function(id, chunk, encoding, callback) {\n  debug('write: \"%s\"', id);\n\n  var stream = this.streams[id];\n  if (!stream) {\n    callback('invalid stream id: ' + id);\n    return;\n  }\n\n  if (global.ArrayBuffer && chunk instanceof ArrayBuffer) {\n    // make sure that chunk is a buffer for stream\n    chunk = new Buffer(new Uint8Array(chunk));\n  }\n  stream._onwrite(chunk, encoding, callback);\n};\n\nSocket.prototype._onend = function(id) {\n  debug('end: \"%s\"', id);\n\n  var stream = this.streams[id];\n  if (!stream) {\n    debug('ignore non-existent stream id: \"%s\"', id);\n    return;\n  }\n\n  stream._end();\n};\n\nSocket.prototype._onerror = function(id, message) {\n  debug('error: \"%s\", \"%s\"', id, message);\n\n  var stream = this.streams[id];\n  if (!stream) {\n    debug('invalid stream id: \"%s\"', id);\n    return;\n  }\n\n  var err = new Error(message);\n  err.remote = true;\n  stream.emit('error', err);\n};\n\nSocket.prototype._ondisconnect = function() {\n  var stream;\n  for (var id in this.streams) {\n    stream = this.streams[id];\n    stream.destroy();\n\n    // Close streams when the underlaying\n    // socket.io connection is closed (regardless why)\n    stream.emit('close');\n    stream.emit('error', new Error('Connection aborted'));\n  }\n};\n\nSocket.prototype._onencode = function(stream) {\n  if (stream.socket || stream.destroyed) {\n    throw new Error('stream has already been sent.');\n  }\n\n  var id = stream.id;\n  if (this.streams[id]) {\n    throw new Error('Encoded stream already exists: ' + id);\n  }\n\n  this.streams[id] = stream;\n  stream.socket = this;\n};\n\nSocket.prototype._ondecode = function(stream) {\n  var id = stream.id;\n  if (this.streams[id]) {\n    this._error(id, new Error('Decoded stream already exists: ' + id));\n    return;\n  }\n\n  this.streams[id] = stream;\n  stream.socket = this;\n};\n\nSocket.prototype.cleanup = function(id) {\n  delete this.streams[id];\n};\n\n","// UUID function from https://gist.github.com/jed/982883\n// More lightweight than node-uuid\nfunction b(\n  a                  // placeholder\n){\n  return a           // if the placeholder was passed, return\n    ? (              // a random number from 0 to 15\n      a ^            // unless b is 8,\n      Math.random()  // in which case\n      * 16           // a random number from\n      >> a/4         // 8 to 11\n      ).toString(16) // in hexadecimal\n    : (              // or otherwise a concatenated string:\n      [1e7] +        // 10000000 +\n      -1e3 +         // -1000 +\n      -4e3 +         // -4000 +\n      -8e3 +         // -80000000 +\n      -1e11          // -100000000000,\n      ).replace(     // replacing\n        /[018]/g,    // zeroes, ones, and eights with\n        b            // random hex digits\n      )\n}\n\nmodule.exports = b;\n","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","var __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nimport * as cookie from 'cookie';\r\nimport { hasDocumentCookie, parseCookies, readCookie } from './utils';\r\nvar Cookies = /** @class */ (function () {\r\n    function Cookies(cookies, options) {\r\n        var _this = this;\r\n        this.changeListeners = [];\r\n        this.HAS_DOCUMENT_COOKIE = false;\r\n        this.cookies = parseCookies(cookies, options);\r\n        new Promise(function () {\r\n            _this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();\r\n        }).catch(function () { });\r\n    }\r\n    Cookies.prototype._updateBrowserValues = function (parseOptions) {\r\n        if (!this.HAS_DOCUMENT_COOKIE) {\r\n            return;\r\n        }\r\n        this.cookies = cookie.parse(document.cookie, parseOptions);\r\n    };\r\n    Cookies.prototype._emitChange = function (params) {\r\n        for (var i = 0; i < this.changeListeners.length; ++i) {\r\n            this.changeListeners[i](params);\r\n        }\r\n    };\r\n    Cookies.prototype.get = function (name, options, parseOptions) {\r\n        if (options === void 0) { options = {}; }\r\n        this._updateBrowserValues(parseOptions);\r\n        return readCookie(this.cookies[name], options);\r\n    };\r\n    Cookies.prototype.getAll = function (options, parseOptions) {\r\n        if (options === void 0) { options = {}; }\r\n        this._updateBrowserValues(parseOptions);\r\n        var result = {};\r\n        for (var name_1 in this.cookies) {\r\n            result[name_1] = readCookie(this.cookies[name_1], options);\r\n        }\r\n        return result;\r\n    };\r\n    Cookies.prototype.set = function (name, value, options) {\r\n        var _a;\r\n        if (typeof value === 'object') {\r\n            value = JSON.stringify(value);\r\n        }\r\n        this.cookies = __assign(__assign({}, this.cookies), (_a = {}, _a[name] = value, _a));\r\n        if (this.HAS_DOCUMENT_COOKIE) {\r\n            document.cookie = cookie.serialize(name, value, options);\r\n        }\r\n        this._emitChange({ name: name, value: value, options: options });\r\n    };\r\n    Cookies.prototype.remove = function (name, options) {\r\n        var finalOptions = (options = __assign(__assign({}, options), { expires: new Date(1970, 1, 1, 0, 0, 1), maxAge: 0 }));\r\n        this.cookies = __assign({}, this.cookies);\r\n        delete this.cookies[name];\r\n        if (this.HAS_DOCUMENT_COOKIE) {\r\n            document.cookie = cookie.serialize(name, '', finalOptions);\r\n        }\r\n        this._emitChange({ name: name, value: undefined, options: options });\r\n    };\r\n    Cookies.prototype.addChangeListener = function (callback) {\r\n        this.changeListeners.push(callback);\r\n    };\r\n    Cookies.prototype.removeChangeListener = function (callback) {\r\n        var idx = this.changeListeners.indexOf(callback);\r\n        if (idx >= 0) {\r\n            this.changeListeners.splice(idx, 1);\r\n        }\r\n    };\r\n    return Cookies;\r\n}());\r\nexport default Cookies;\r\n","import Cookies from './Cookies';\r\nexport default Cookies;\r\n","import * as cookie from 'cookie';\r\nexport function hasDocumentCookie() {\r\n    // Can we get/set cookies on document.cookie?\r\n    return typeof document === 'object' && typeof document.cookie === 'string';\r\n}\r\nexport function cleanCookies() {\r\n    document.cookie.split(';').forEach(function (c) {\r\n        document.cookie = c\r\n            .replace(/^ +/, '')\r\n            .replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');\r\n    });\r\n}\r\nexport function parseCookies(cookies, options) {\r\n    if (typeof cookies === 'string') {\r\n        return cookie.parse(cookies, options);\r\n    }\r\n    else if (typeof cookies === 'object' && cookies !== null) {\r\n        return cookies;\r\n    }\r\n    else {\r\n        return {};\r\n    }\r\n}\r\nexport function isParsingCookie(value, doNotParse) {\r\n    if (typeof doNotParse === 'undefined') {\r\n        // We guess if the cookie start with { or [, it has been serialized\r\n        doNotParse =\r\n            !value || (value[0] !== '{' && value[0] !== '[' && value[0] !== '\"');\r\n    }\r\n    return !doNotParse;\r\n}\r\nexport function readCookie(value, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var cleanValue = cleanupCookieValue(value);\r\n    if (isParsingCookie(cleanValue, options.doNotParse)) {\r\n        try {\r\n            return JSON.parse(cleanValue);\r\n        }\r\n        catch (e) {\r\n            // At least we tried\r\n        }\r\n    }\r\n    // Ignore clean value if we failed the deserialization\r\n    // It is not relevant anymore to trim those values\r\n    return value;\r\n}\r\nfunction cleanupCookieValue(value) {\r\n    // express prepend j: before serializing a cookie\r\n    if (value && value[0] === 'j' && value[1] === ':') {\r\n        return value.substr(2);\r\n    }\r\n    return value;\r\n}\r\n","'use strict';\n\nvar required = require('requires-port')\n  , qs = require('querystringify')\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i\n  , windowsDriveLetter = /^[a-zA-Z]:/\n  , whitespace = '[\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x20\\\\xA0\\\\u1680\\\\u180E\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200A\\\\u202F\\\\u205F\\\\u3000\\\\u2028\\\\u2029\\\\uFEFF]'\n  , left = new RegExp('^'+ whitespace +'+');\n\n/**\n * Trim a given string.\n *\n * @param {String} str String to trim.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(left, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address, url) {     // Sanitize what is left of the address\n    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') globalVar = window;\n  else if (typeof global !== 'undefined') globalVar = global;\n  else if (typeof self !== 'undefined') globalVar = self;\n  else globalVar = {};\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */\nfunction isSpecial(scheme) {\n  return (\n    scheme === 'file:' ||\n    scheme === 'ftp:' ||\n    scheme === 'http:' ||\n    scheme === 'https:' ||\n    scheme === 'ws:' ||\n    scheme === 'wss:'\n  );\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address, location) {\n  address = trimLeft(address);\n  location = location || {};\n\n  var match = protocolre.exec(address);\n  var protocol = match[1] ? match[1].toLowerCase() : '';\n  var forwardSlashes = !!match[2];\n  var otherSlashes = !!match[3];\n  var slashesCount = 0;\n  var rest;\n\n  if (forwardSlashes) {\n    if (otherSlashes) {\n      rest = match[2] + match[3] + match[4];\n      slashesCount = match[2].length + match[3].length;\n    } else {\n      rest = match[2] + match[4];\n      slashesCount = match[2].length;\n    }\n  } else {\n    if (otherSlashes) {\n      rest = match[3] + match[4];\n      slashesCount = match[3].length;\n    } else {\n      rest = match[4]\n    }\n  }\n\n  if (protocol === 'file:') {\n    if (slashesCount >= 2) {\n      rest = rest.slice(2);\n    }\n  } else if (isSpecial(protocol)) {\n    rest = match[4];\n  } else if (protocol) {\n    if (forwardSlashes) {\n      rest = rest.slice(2);\n    }\n  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n    rest = match[4];\n  }\n\n  return {\n    protocol: protocol,\n    slashes: forwardSlashes || isSpecial(protocol),\n    slashesCount: slashesCount,\n    rest: rest\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '', location);\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (\n    extracted.protocol === 'file:' && (\n      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||\n    (!extracted.slashes &&\n      (extracted.protocol ||\n        extracted.slashesCount < 2 ||\n        !isSpecial(url.protocol)))\n  ) {\n    instructions[3] = [/(.*)/, 'pathname'];\n  }\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address, url);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // Default to a / for pathname if none exists. This normalizes the URL\n  // to always have a /\n  //\n  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n    url.pathname = '/' + url.pathname;\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    default:\n      url[part] = value;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes || isSpecial(url.protocol) ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = qs;\n\nmodule.exports = Url;\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChUA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5QA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5HA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjPA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvfA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtMA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnOA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvlBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnMA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChKA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3FA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/ZA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnOA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnKA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3PA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClPA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnLA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/RA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrOA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1JA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9EA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1SA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7GA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7WA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9JA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrOA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrOA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5EA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACl8BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzPA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrHA;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzEA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;;;;;;;;;;;;ACAA;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrCA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;A","sourceRoot":""}